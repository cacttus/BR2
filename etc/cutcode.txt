



 //float fNear = 1;
 //float fFar = 1000;
 //float _f_hfov = (float)M_PI / (float)4;    // - Default Horizontal Field of view
 //float _f_tan_fov_2 = tanf(_f_hfov / 2.0f);
 //float vpWidth_2 = _f_tan_fov_2*fNear;

 //float arat_1 = 1.0f / ((float)w / (float)h);

 //vec3 a =vec3(100, 100, 100);
 //vec3 b =vec3(0, 0, 0);
 //vec3 c = vec3(0, 1, 0);
 //
 //_mView = mat4::getLookAt(a, b, c);
 //
 //float vw = vpWidth_2;
 //float vh = vpWidth_2*arat_1;
 //_mProj =
 //    Mat44::getProjection(
 //        fNear, fFar,
 //        -vw, vw,
 //        -vh, vh

 //    );//void Engine::makeTestMesh() {
//    //*Create a test primitive to test x platform opengl rendering
//    //GLuint buf;
//    std::vector<v_v3n3x2> verts;
//    std::vector<v_index> inds;
//
//    float size = 5.0f;
//    verts.push_back(v_v3n3x2());
//    verts.push_back(v_v3n3x2());
//    verts.push_back(v_v3n3x2());
//    verts.push_back(v_v3n3x2());
//
//    verts[0].v = vec3(-1, -1, 0) * size;
//    verts[0].x = vec2(0, 0);
//    verts[0].n = vec3(0, -1, 0);
//
//    verts[1].v = vec3(1, -1, 0) * size;
//    verts[1].x = vec2(1, 0);
//    verts[1].n = vec3(0, -1, 0);
//
//    verts[2].v = vec3(1, 1, 0) * size;
//    verts[2].x = vec2(1, 1);
//    verts[2].n = vec3(0, -1, 0);
//
//    verts[3].v = vec3(-1, 1, 0) * size;
//    verts[3].x = vec2(0, 1);
//    verts[3].n = vec3(0, -1, 0);
//
//    inds.push_back(0);
//    inds.push_back(1);
//    inds.push_back(3);
//
//    inds.push_back(1);
//    inds.push_back(2);
//    inds.push_back(3);
//
//    _pMesh = new Mesh(ctx);
//    _pMesh->fillData(&verts, &inds);
//    _pMesh->setTexture(_pTex);
//
//}
//void Engine::makeTestVao() {
//    ctx->glGenVertexArrays(1, &vao);
//    ctx->glBindVertexArray(vao);
//
//    ctx->glEnableVertexAttribArray(0);
//    errchk();
//    ctx->glBindBuffer(GL_ARRAY_BUFFER, vbuf);
//    errchk();
//    ctx->glVertexAttribPointer(
//        0,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.
//        3,                  // size
//        GL_FLOAT,           // type
//        GL_FALSE,           // normalized?
//        sizeof(v_v3n3x2),   // stride
//        (GLvoid*)0            // array buffer offset
//    );
//    errchk();
//
//    ctx->glEnableVertexAttribArray(1);
//    errchk();
//    ctx->glBindBuffer(GL_ARRAY_BUFFER, vbuf);
//    errchk();
//    ctx->glVertexAttribPointer(
//        1,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.
//        3,                  // size
//        GL_FLOAT,           // type
//        GL_FALSE,           // normalized?
//        sizeof(v_v3n3x2),   // stride
//        (GLvoid*)(sizeof(vec4))            // array buffer offset
//    );
//    errchk();
//    ctx->glEnableVertexAttribArray(2);
//    errchk();
//    ctx->glBindBuffer(GL_ARRAY_BUFFER, vbuf);
//    errchk();
//    ctx->glVertexAttribPointer(
//        2,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.
//        2,                  // size
//        GL_FLOAT,           // type
//        GL_FALSE,           // normalized?
//        sizeof(v_v3n3x2),   // stride
//        (GLvoid*)(sizeof(vec4) + sizeof(vec4))            // array buffer offset
//    );
//    errchk();
//
//    ctx->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibuf);
//
//    ctx->glBindVertexArray(0);
//}
//void Engine::drawTestPrim() {
//    ctx->glBindVertexArray(vao);
//    ctx->glActiveTexture(GL_TEXTURE0);
//    _pTex->bind();
//
//    ctx->glUseProgram(prog);
//
//    ctx->glUniformMatrix4fv(ufModel, 1, GL_FALSE, (GLfloat*)&_mModel);
//    ctx->glUniformMatrix4fv(ufView, 1, GL_FALSE, (GLfloat*)&_mView);
//    ctx->glUniformMatrix4fv(ufProj, 1, GL_FALSE, (GLfloat*)&_mProj);
//
//    ctx->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibuf);
//
//    glDrawElements(GL_TRIANGLES,  6, GL_UNSIGNED_INT, (GLvoid*)0);
//    errchk();
//
//    ctx->glBindVertexArray(0);
//    ctx->glDisableVertexAttribArray(0);
//    ctx->glDisableVertexAttribArray(1);
//    ctx->glDisableVertexAttribArray(2);
//    ctx->glBindBuffer(GL_ARRAY_BUFFER, 0);
//    ctx->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
//
//}
//void Engine::makeTestPrim() {
//    //*Create a test primitive to test x platform opengl rendering
//    //GLuint buf;
//    v_v3n3x2 verts[4];
//    float size = 5.0f;
//    verts[0].v = vec3(-1, -1, 0) * size;
//    verts[0].x = vec2(0, 0);
//    verts[0].n = vec3(0, -1, 0);
//
//    verts[1].v = vec3(1, -1, 0) * size;
//    verts[1].x = vec2(1, 0);
//    verts[1].n = vec3(0, -1, 0);
//
//    verts[2].v = vec3(1, 1, 0) * size;
//    verts[2].x = vec2(1, 1);
//    verts[2].n = vec3(0, -1, 0);
//
//    verts[3].v = vec3(-1, 1, 0) * size;
//    verts[3].x = vec2(0, 1);
//    verts[3].n = vec3(0, -1, 0);
//
//    //verts[3] = vec3(1, 0, 0) * size;
//    //verts[4] = vec3(-1, 0, 0) * size;
//    //verts[5] = vec3(1, 0, 0) * size;
//    //verts[6] = vec3(-1, 0, 0) * size;
//    //verts[7] = vec3(1, 0, 0) * size;
//
//    ctx->glGenBuffers(1, &vbuf);
//    ctx->glBindBuffer(GL_ARRAY_BUFFER, vbuf);
//    ctx->glBufferData(GL_ARRAY_BUFFER, sizeof(v_v3n3x2) * 4, (GLvoid*)verts, GL_STATIC_DRAW);
//    ctx->glBindBuffer(GL_ARRAY_BUFFER, 0);
//
//    errchk();
//    t_uint32 inds[6];
//    inds[0] = 0;
//    inds[1] = 1;
//    inds[2] = 3;
//    
//    inds[3] = 1;
//    inds[4] = 2;
//    inds[5] = 3;
//
//    ctx->glGenBuffers(1, &ibuf);
//    ctx->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibuf);
//    ctx->glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(t_uint32) * 6, (GLvoid*)inds, GL_STATIC_DRAW);
//    ctx->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
//
//    errchk();
//}

//void Engine::test() {
//
//}
//void Engine::loadTestTexture() {
// //   _pTex = new Texture2DSpec("./data/testimg.png");
//}
//void Engine::makeTestShader() {
//
//    loadShaders("./data/diffuse.vs", "./data/diffuse.ps");
//
//    //ctx->glUseProgram(prog);
//
//    //ufModel = ctx->glGetUniformLocation(prog, "_ufModel");
//    //ufView = ctx->glGetUniformLocation(prog, "_ufView");
//    //ufProj = ctx->glGetUniformLocation(prog, "_ufProj");
//    //if (ufModel == -1 || ufView == -1 || ufProj == -1) {
//    //    Utils::debugBreak();
//    //}
//    //errchk();
//}




        //_mLocal = _mBind;
        //_mLocal = _mInvBind * _mLocal * _mBind;

        //   mat4 mIBind = getJoint()->getInvBindMatrix();
        //  mat4 mBind = getJoint()->getBindMatrix();
        //FINALLY GOT IT TO WORK FOR ONE JOINT
        // B-1 * S * B.. So long as matrixes are Left-to_right associative, eg. trnasforms happen left first, then right
        // _skinMatrix = mIBind * mLocal * mIBind.inverseOf();
        //   mat4 mComb = mLocal * mBind * parentSkinConcat;
        //*************
        //* Bone Space test ** this effectively tests the bones in their own spaces.
        //  _skinMatrix = mIBind * mLocal * mIBind.inverseOf(); //mBind * parentSkinConcat;
        // _skinMatrix = mIBind * mComb; //mBind * parentSkinConcat;
        //if (false)
        //{
        //    mat4 mInverseTest = mLocal * mLocal.transpose();
        //    int n = 0;
        //    n++;
        //}
        // mat4 mConcat = mBind  * parentSkinConcat;
        //if (false)
        //{
        //    //Test
        //    vec4 pos;
        //    vec4 scl;
        //    vec4 rot;
        //    _skinMatrix.decompose(pos, rot, scl);
        //    rot.w = 180 * (rot.w / M_PI);
        //    mLocal.decompose(pos, rot, scl);
        //    rot.w = 180 * (rot.w / M_PI);
        //    parentSkinConcat.decompose(pos, rot, scl);
        //    rot.w = 180 * (rot.w / M_PI);
        //    //Test
        //    int n = 0;
        //    n++;
        //}




    


   // _lut.insert(std::make_pair(iv, newGq));

    //for (int zz = 0; zz < Utils::getNumCellsWidth(); ++zz) {
    //    for (int yy = 0; yy < Utils::getNumCellsHeight(); ++yy) {
    //        for (int xx = 0; xx < Utils::getNumCellsWidth(); ++xx) {

    //            vec3 tileOffset = vec3(
    //                xx * Utils::getCellWidth()
    //                , yy * Utils::getCellHeight()
    //                , zz * Utils::getCellWidth()
    //            );
    //            tileOffset += baseOrigin;


    //            //std::shared_ptr<AtlasSprite> psT = pa->getSprite(BwMat::Grass);
    //            //AssertOrThrow2(psT != nullptr);
    //            //std::shared_ptr<AtlasSprite> psS = pa->getSprite(BwMat::Dirt);
    //            //AssertOrThrow2(psS != nullptr);
    //            //std::shared_ptr<AtlasSprite> psB = pa->getSprite(BwMat::Plank);
    //            //AssertOrThrow2(psB != nullptr);

    //            // Utils::factoryConstructQuad(&inds, &verts, iBaseIdx, tileOffset, ps);
    //            GridCell* newGq = new GridCell(this, xx, yy, zz, BwMat::Grass, BwMat::Dirt, BwMat::Plank);

    //            //Build lut
    //            ivec3* iv = new ivec3(newGq->getGridPos()->getLocalX(), newGq->getGridPos()->getLocalY(), newGq->getGridPos()->getLocalZ());
    //            _lut.insert(std::make_pair(iv, newGq));
    //        }
    //    }
    //}

    ///* c   d
    //   a   b */
    //int32_t iBaseIdx = 0;
    //for (int j = 0, jind = 0; j < Utils::getNumCellsWidth(); ++j, ++jind) {
    //    for (int i = 0, iind = 0; i < Utils::getNumCellsWidth(); ++i, ++iind) {
    //        vec3 tileOffset = vec3(i*Utils::getCellWidth(), 0, j*Utils::getCellWidth());
    //        tileOffset += baseOrigin;

    //        BwMat::e mat = (BwMat::e)(rand() % (int)4);
    //        std::shared_ptr<AtlasSprite> ps = pa->getSprite(mat);
    //        AssertOrThrow2(ps != nullptr);

    //        Utils::factoryConstructQuad(&inds, &verts, iBaseIdx, tileOffset, ps);
    //        GridCell* newGq = new GridCell(this, iind, jind, mat);

    //        //Build lut
    //        ivec3* iv = new ivec3(newGq->getGridPos()->getLocalX(), 0, newGq->getGridPos()->getLocalZ());
    //        _lut.insert(std::make_pair(iv, newGq));
    //    }
    //}




	//void WorldGrid::makeTestSkeleton() {
//    GridObj* bRoot, *bLThigh, *bRThigh, *bLLeg,
//        *bRLeg, *bSpine, *bLShoulder,
//        *bRShoulder, *bLArm, *bRArm, *bHead;
//    float h = 25;
//    int rhead = 5;
//
//    bRoot       = makeTestBone("root"       ,nullptr      , vec3( 0, 1, 0), h * 3     , 0, "" );
//    bLThigh     = makeTestBone("root"       ,bRoot        , vec3(-1, 0, 0), h * 1.5   , 3, "" );
//    bRThigh     = makeTestBone("root"       ,bRoot        , vec3( 1, 0, 0), h * 1.5   , 4, "" );
//    bLLeg       = makeTestBone("root"       ,bLThigh      , vec3( 0,-1, 0), h * 2     , 1, "./data/md-ch-foot.obj" );
//    bRLeg       = makeTestBone("root"       ,bRThigh      , vec3( 0,-1, 0), h * 2     , 2, "./data/md-ch-foot.obj" );
//    bSpine      = makeTestBone("root"       ,bRoot        , vec3( 0, 1, 0), h * 4     , 0, "./data/md-ch-bod.obj" );
//    bLShoulder  = makeTestBone("root"       ,bSpine       , vec3(-1, 0, 0), h * 1.5   , 3, "" );
//    bRShoulder  = makeTestBone("root"       ,bSpine       , vec3( 1, 0, 0), h * 1.5   , 4, "" );
//    bLArm       = makeTestBone("root"       ,bLShoulder   , vec3( 0,-1, 0), h * 2     , 2, "./data/md-ch-arm.obj" );
//    bRArm       = makeTestBone("root"       ,bRShoulder   , vec3( 0,-1, 0), h * 2     , 1, "./data/md-ch-arm.obj" );
//    bHead       = makeTestBone("root"       ,bSpine       , vec3( 0, 1, 0), h * 1     , rhead, "./data/md-ch-head.obj" );
//
//    _pTestSkeleton = bRoot;
//
//    _pTestSkeleton->getAnimator()->setDuration(3);
//    _pTestSkeleton->getAnimator()->setId(0);
//    _pTestSkeleton->getAnimator()->setLoop(true);
//    _pTestSkeleton->getAnimator()->start();
//
//    addObj(_pTestSkeleton);
//}
//GridObj* WorldGrid::makeTestBone(t_string boneName, GridObj* pParent, vec3 dir, float len, int iRotID, t_string mesh) {
//
//    int aid;
//    vec3 parentOrigin;
//    Animation* anim;
//
//    if (pParent) {
//        //mat4 mCt;
//        //pParent->getBindConcat(mCt);
//        //vec4 v2 = mCt * vec4(0, 0, 0, 1);
//        parentOrigin = pParent->getBone()->getEnd();// vec3(v2.x, v2.y, v2.z);
//    }
//    else {
//        parentOrigin = vec3(0, 0, 0);
//    }
//
//    vec3 vBoneBeg = parentOrigin;
//    vec3 vBoneEnd = parentOrigin + dir*len;
//    mat4 mBind;
//    mBind = mat4::getTranslation(vBoneBeg);
//
//    Bone* b = new Bone(boneName, mBind, vBoneBeg, vBoneEnd);
//
//    if (iRotID > 0) {
//        aid = 0;
//        t_string n = "walk";
//        anim = new Animation(n, aid);
//
//        mat4 m1, m2, m3;
//        if (iRotID == 1 || iRotID == 2) {
//            m1 = mat4::identity();
//            m2 = mat4::getRotationRad(M_PI / 3, vec3(1, 0, 0));
//            m3 = mat4::getRotationRad(-M_PI / 3, vec3(1, 0, 0));
//
//            if (iRotID == 1) {
//
//                anim->getKeyFrames().push_back(new KeyFrame(m1, 0.0f));
//                anim->getKeyFrames().push_back(new KeyFrame(m2, 0.333f));
//                anim->getKeyFrames().push_back(new KeyFrame(m3, 0.666f));
//                anim->getKeyFrames().push_back(new KeyFrame(m1, 1.0f));
//                b->addAnimation(anim);
//            }
//            else if (iRotID == 2) {
//                anim->getKeyFrames().push_back(new KeyFrame(m1, 0.0f));
//                anim->getKeyFrames().push_back(new KeyFrame(m3, 0.333f));
//                anim->getKeyFrames().push_back(new KeyFrame(m2, 0.666f));
//                anim->getKeyFrames().push_back(new KeyFrame(m1, 1.0f));
//                b->addAnimation(anim);
//            }
//        }
//        else {
//            m1 = mat4::identity();
//            float dd =8;
//            m2 = mat4::getRotationRad(M_PI / dd, vec3(0, 1, 0));
//            m3 = mat4::getRotationRad(-M_PI / dd, vec3(0, 1, 0));
//
//             if (iRotID == 3) {
//                anim->getKeyFrames().push_back(new KeyFrame(m1, 0.0f));
//                anim->getKeyFrames().push_back(new KeyFrame(m3, 0.333f));
//                anim->getKeyFrames().push_back(new KeyFrame(m2, 0.666f));
//                anim->getKeyFrames().push_back(new KeyFrame(m1, 1.0f));
//                b->addAnimation(anim);
//            }
//             else if (iRotID == 4) {
//                 anim->getKeyFrames().push_back(new KeyFrame(m1, 0.0f));
//                 anim->getKeyFrames().push_back(new KeyFrame(m3, 0.333f));
//                 anim->getKeyFrames().push_back(new KeyFrame(m2, 0.666f));
//                 anim->getKeyFrames().push_back(new KeyFrame(m1, 1.0f));
//                 b->addAnimation(anim);
//             }
//        }
//    }
//
//    if (iRotID > 0) {
//        aid = 1;
//        t_string n = "idle";
//        anim = new Animation(n, aid);
//
//        mat4 m1, m2, m3;
//        if (iRotID == 5) {
//            m1 = mat4::identity();
//            m2 = mat4::getRotationRad(M_PI / 3, vec3(0, 1, 0));
//            m3 = mat4::getRotationRad(-M_PI / 3, vec3(0, 1, 0));
//            float fkeys = 5;
//            anim->getKeyFrames().push_back(new KeyFrame(m1, 0 / fkeys));
//            anim->getKeyFrames().push_back(new KeyFrame(m2, 1 / fkeys));
//            anim->getKeyFrames().push_back(new KeyFrame(m1, 2 / fkeys));
//            anim->getKeyFrames().push_back(new KeyFrame(m3, 3 / fkeys));
//            anim->getKeyFrames().push_back(new KeyFrame(m1, 4 / fkeys));
//            b->addAnimation(anim);
//        }
//    }
//    //pNewObj1->addMesh(_pContext->getMeshCache()->getOrLoad());
//    GridObj* pNewObj2 = new GridObj(this, GridObjType::e::CubeThing);
//    pNewObj2->loadMesh("./data/md-icos.obj", "./data/tx-brick-des.png");
//    pNewObj2->setScale(vec3(14, 14, 14));
//    pNewObj2->setPos(vBoneBeg);
//    pNewObj2->setBone(b);
//
//    if (pParent != nullptr) {
//        //can't duplicate bones
//        //if (mesh.length() > 0) {
//        //    GridObj* pNewObj1 = new GridObj(this, GridObjType::e::CubeThing);
//        //    pNewObj1->loadMesh(mesh, "./data/tx-brick-des.png");
//        //    pNewObj1->setScale(vec3(14, 14, 14));
//        //    pNewObj1->setPos(vBoneEnd);
//        //    pNewObj1->setBone(b);
//        //    pParent->addChildObj(pNewObj1);
//        //}
//        pParent->addChildObj(pNewObj2);
//    }
//    else {
//
//    }
//
//    return pNewObj2;
//}

//void WorldGrid::findEmptySpotsS4(GridCell* q, std::vector<GridCell*>& __out_ spots) {
//
//    GridCell* neighbor;
//    ;
//
//    neighbor = getGlobalQuadForIndex(q->getRelativeNeighborPosGlobal(ivec3(-1, Utils::Mid(), 0)));
//    if (neighbor != nullptr && neighbor->getOccupied() == false) {
//        spots.push_back(neighbor);
//    }
//
//    neighbor = getGlobalQuadForIndex(q->getRelativeNeighborPosGlobal(ivec3(0, Utils::Mid(), -1)));
//    if (neighbor != nullptr && neighbor->getOccupied() == false) {
//        spots.push_back(neighbor);
//    }
//
//    neighbor = getGlobalQuadForIndex(q->getRelativeNeighborPosGlobal(ivec3(1, Utils::Mid(), 0)));
//    if (neighbor != nullptr && neighbor->getOccupied() == false) {
//        spots.push_back(neighbor);
//    }
//
//    neighbor = getGlobalQuadForIndex(q->getRelativeNeighborPosGlobal(ivec3(0, Utils::Mid(), 1)));
//    if (neighbor != nullptr && neighbor->getOccupied() == false) {
//        spots.push_back(neighbor);
//    }
//    
//}






            //if (gc->isBlock()) {
            //    gn = gc->getNeighbor(GSide::e::gL);//left
            //    if (gn != nullptr && (gn->isEmpty() || gn->isRamp())) {
            //        ps = pa->getSprite(gc->getMatSide());
            //        Utils::makeFace(vBlock[btl], vBlock[bbl], vBlock[ttl], vBlock[tbl], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tLc;
            //    }
            //    gn = gc->getNeighbor(GSide::e::gR);//right
            //    if (gn != nullptr && (gn->isEmpty() || gn->isRamp())) {
            //        ps = pa->getSprite(gc->getMatSide());
            //        Utils::makeFace(vBlock[bbr], vBlock[btr], vBlock[tbr], vBlock[ttr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tRc;
            //    }
            //    gn = gc->getNeighbor(GSide::e::gA);//back
            //    if (gn != nullptr && (gn->isEmpty() || gn->isRamp())) {
            //        ps = pa->getSprite(gc->getMatSide());
            //        Utils::makeFace(vBlock[bbl], vBlock[bbr], vBlock[tbl], vBlock[tbr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tAc;
            //    }
            //    gn = gc->getNeighbor(GSide::e::gF);//front
            //    if (gn != nullptr && (gn->isEmpty()||gn->isRamp())) {
            //        ps = pa->getSprite(gc->getMatSide());
            //        Utils::makeFace(vBlock[btr], vBlock[btl], vBlock[ttr], vBlock[ttl], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tFc;
            //    }

            //    //Capping quad
            //    if (cell_y == Utils::getNumCellsHeight() - 1) {
            //        ps = pa->getSprite(gc->getMatBot());
            //        Utils::makeFace(vBlock[tbl], vBlock[tbr], vBlock[ttl] , vBlock[ttr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tTc;
            //    }
            //}
            //else if (gc->isEmpty()) {
            //    gn = gc->getNeighbor(GSide::e::gB);//bot
            //    if (gn != nullptr && gn->isBlock()) {
            //        ps = pa->getSprite(gn->getMatTop());
            //        Utils::makeFace(vBlock[bbl], vBlock[bbr], vBlock[btl], vBlock[btr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gn->getTopBits() |= GridCell::Tbit::tTc;
            //    }
            //    //TODO: fix this
            //    //the base plagio is rendering feven when cell should be solid
            //   /* else if (cell_y == 0) {
            //        ps = pa->getSprite(BwMat::e::Plagio);
            //        Utils::makeFace(vBlock[bbl], vBlock[bbr], vBlock[btl], vBlock[btr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tBc;
            //    }*/


            //    // - Bottom of above cell
            //    gn = gc->getNeighbor(GSide::e::gT);//top
            //    if (gn != nullptr && gn->isBlock()) {
            //        ps = pa->getSprite(gn->getMatBot());
            //        Utils::makeFace(vBlock[tbr], vBlock[tbl], vBlock[ttr], vBlock[ttl], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gn->getTopBits() |= GridCell::Tbit::tBc;
            //    }
            //}
            //else if (gc->isRamp()) {

            //    if (gc->getGeom() == BwGeom::e::RampA) {
            //        //Top
            //        ps = pa->getSprite(gc->getMatTop());
            //        Utils::makeFace(vBlock[bbl], vBlock[bbr], vBlock[ttl], vBlock[ttr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tTc;
            //    }
            //    else if (gc->getGeom() == BwGeom::e::RampF) {
            //        //Top
            //        ps = pa->getSprite(gc->getMatTop());
            //        Utils::makeFace(vBlock[btr], vBlock[btl], vBlock[tbr], vBlock[tbl], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tTc;
            //    }
            //    else if (gc->getGeom() == BwGeom::e::RampL) {
            //        //Top
            //        ps = pa->getSprite(gc->getMatTop());
            //        Utils::makeFace(vBlock[btl], vBlock[bbl], vBlock[ttr], vBlock[tbr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tTc;
            //    }
            //    else if (gc->getGeom() == BwGeom::e::RampR) {
            //        //Top
            //        ps = pa->getSprite(gc->getMatTop());
            //        Utils::makeFace(vBlock[bbr], vBlock[btr], vBlock[tbl], vBlock[ttl], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //        gc->getTopBits() |= GridCell::Tbit::tTc;
            //    }
            //    ////TESTING FOR NOW
            //    //gn = gc->getNeighbor(GSide::e::gL);//left
            //    //if (gn != nullptr && gn->isEmpty()) {
            //    //    ps = pa->getSprite(gc->getMatSide());
            //    //    Utils::makeFace(vBlock[btl], vBlock[bbl], vBlock[ttl], vBlock[tbl], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //    //    gc->getTopBits() |= GridCell::Tbit::tLc;
            //    //}
            //    //gn = gc->getNeighbor(GSide::e::gR);//right
            //    //if (gn != nullptr && gn->isEmpty()) {
            //    //    ps = pa->getSprite(gc->getMatSide());
            //    //    Utils::makeFace(vBlock[bbr], vBlock[btr], vBlock[tbr], vBlock[ttr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //    //    gc->getTopBits() |= GridCell::Tbit::tRc;
            //    //}
            //    //gn = gc->getNeighbor(GSide::e::gA);//back
            //    //if (gn != nullptr && gn->isEmpty()) {
            //    //    ps = pa->getSprite(gc->getMatSide());
            //    //    Utils::makeFace(vBlock[bbl], vBlock[bbr], vBlock[tbl], vBlock[tbr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //    //    gc->getTopBits() |= GridCell::Tbit::tAc;
            //    //}
            //    //gn = gc->getNeighbor(GSide::e::gF);//front
            //    //if (gn != nullptr && gn->isEmpty()) {
            //    //    ps = pa->getSprite(gc->getMatSide());
            //    //    Utils::makeFace(vBlock[btr], vBlock[btl], vBlock[ttr], vBlock[ttl], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //    //    gc->getTopBits() |= GridCell::Tbit::tFc;
            //    //}
            //    //gn = gc->getNeighbor(GSide::e::gT);//top
            //    //if (gn != nullptr && gn->isEmpty()) {
            //    //    ps = pa->getSprite(gc->getMatTop());
            //    //    Utils::makeFace(vBlock[tbl], vBlock[tbr], vBlock[ttl], vBlock[ttr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //    //    gc->getTopBits() |= GridCell::Tbit::tTc;
            //    //}
            //    //gn = gc->getNeighbor(GSide::e::gB);//bot
            //    //if (gn != nullptr && gn->isEmpty()) {
            //    //    ps = pa->getSprite(gc->getMatBot());
            //    //    Utils::makeFace(vBlock[btl], vBlock[btr], vBlock[bbl], vBlock[bbr], *(verts_level[iLevel]), *(inds_level[iLevel]), vp, ps);
            //    //    gc->getTopBits() |= GridCell::Tbit::tBc;
            //    //}
            //}


    //}
    //else if (bMusic) {
    //    _pMusic = Mix_Load(file);
    //}
    //if (SDL_LoadWAV(file.c_str(), &wav_spec, &wav_buffer, &wav_length) == NULL) {
    //    BroLogError("Couldn't load sound or music file, ", file);
    //    fprintf(stderr, "Couldn'tLoad awave %s\n", SDL_GetError());
    //}
    //else {
    //} //void World25::updateLights() {
 //    //Collide any char visible cell with a torch bound box.
 //    Quad2f c;
 //    ivec2 p0, p1;
 //    CongaRoom* cr = dynamic_cast<CongaRoom*>(getContext()->getRoom());
 //    bool bEditMode = cr->getGameMode() == GameMode::e::Edit;
 //    Box3f lightBox, charBox;
 //    vec3 charCenter;
 //
 //
 //    //for (GridMap::iterator it = _gridMap.begin(); it != _gridMap.end(); it++) {
 //    //    World25Grid* gg = it->second;
 //    //    gg->resetLighting(bEditMode);
 //    //}
 //
 //    if (bEditMode == false) {
 //
 //        ////Reset all visible grids.
 //        std::vector<World25Grid*> charVisibleGrids;
 //        for (PixObj* pChar : _pSmasher->getPlayerChars()) {
 //            charCenter = pChar->getCenter();
 //
 //            //Reset all visible grids.
 //            c._p0 = -pChar->getAwarenessRadius();
 //            c._p1 = pChar->getAwarenessRadius();
 //            getNodeRangeForBox(&c, &p0, &p1);
 //            for (t_int32 k = p0.y; k <= p1.y; ++k) {
 //                for (t_int32 i = p0.x; i <= p1.x; ++i) {
 //                    ivec2 cv(i, k);
 //                    World25Grid* pg = getNodeAtPos(cv);
 //                    if (pg != nullptr) {
 //                        charVisibleGrids.push_back(pg);
 //                    }
 //                }
 //            }
 //        }
 //        for (World25Grid* pGrid : charVisibleGrids) {
 //            pGrid->resetLighting(bEditMode);
 //        }
 //
 //        for (PixObj* pChar : _pSmasher->getPlayerChars()) {
 //            charCenter = pChar->getCenter();
 //
 //            //Collect all intersecting lights.
 //            std::vector<PixObj*> charVisibleLights;
 //            charBox._min = pChar->getCenter() - pChar->getAwarenessRadius();
 //            charBox._max = pChar->getCenter() + pChar->getAwarenessRadius();
 //            charBox.validateBoundBox();
 //
 //            for (PixObj* pLight : _pSmasher->getLights()) {
 //                AssertOrThrow2(pLight->getLight() != nullptr);
 //
 //                lightBox._min = pLight->getCenter() - pLight->getLight()->_fRadius;
 //                lightBox._max = pLight->getCenter() + pLight->getLight()->_fRadius;
 //                lightBox.validateBoundBox();
 //
 //                if (charBox.cubeIntersect_EasyOut_Inclusive(&lightBox)) {
 //                    charVisibleLights.push_back(pLight);
 //                }
 //            }
 //
 //            //Get all visible tiles.
 //            std::map<WorldCell*, CellVisibility> charVisibleTiles;
 //            std::set<Box3f*> occluders;
 //            getVisibleCellsForAwarenessBox(&charBox, charVisibleTiles, occluders, nullptr);
 //            occluders.clear();
 //
 //            //Intersect tiles with lights.
 //            vec3 tileCenter;
 //            vec3 lightCenter;
 //
 //            for (PixObj* pLight : charVisibleLights) {
 //                //WorldCell* pLightCell = getGlobalCellForPoint(pLight->getCenter());
 //
 //                lightBox._min = pLight->getCenter() - pLight->getLight()->_fRadius;
 //                lightBox._max = pLight->getCenter() + pLight->getLight()->_fRadius;
 //                lightCenter = pLight->getCenter();
 //                lightCenter.z = 0;
 //                lightBox.validateBoundBox();
 //
 //                //Run the awareness a second time for the light and only for the set of the char visible tiles.
 //                std::map<WorldCell*, CellVisibility> lightVisibleTiles;
 //                getVisibleCellsForAwarenessBox(&lightBox, lightVisibleTiles, occluders, &charVisibleTiles);
 //                occluders.clear();
 //
 //                for (std::map<WorldCell*, CellVisibility>::iterator ite = lightVisibleTiles.begin(); 
 //                    ite!=lightVisibleTiles.end(); ite++ ) {
 //                    WorldCell* pTile = ite->first;
 //
 //                    tileCenter = pTile->getBoundBoxPhysical()->center();
 //                  //  tileCenter.z = 0;
 //                    //We don't care about how many objects.  For
 //                    //now we just say if there's any objects at all then
 //                    //the tile is "blocked" and not visible in front of a light.
 //                    
 //                    //These need to be normalized for the lambertian.
 //
 //                    //Compute Occlusion Percentage
 //                    float fOccludeValue = 1.0f;;
 //                    //TODO: ---***Redo this - this adds light to the dark areas behind
 //                    // occluded things, making the light refract behind them. so it doens't
 //                    // look so choppy
 //                 //   if (cellIsOccluder(pTile)) {
 //                 //      vec3 lightTile = (lightCenter - tileCenter).normalize();
 //                 //      vec3 charTile = (charCenter - tileCenter).normalize();
 //                 //      fOccludeValue = lightTile.dot(charTile);
 //                 //   }
 //                 //   else {
 //                //        fOccludeValue = 1.0f;
 //                //    }
 //
 //                    //Compute visibility Percentage
 //                    float fVisibilityPct = 0;
 //                    std::map<WorldCell*, CellVisibility>::iterator itecc = charVisibleTiles.find(ite->first);
 //                    if(itecc != charVisibleTiles.end()){
 //                        fVisibilityPct = itecc->second._fVisCount / 4.0f;
 //                    }
 //                    else {
 //                        fVisibilityPct = 0;
 //                    }
 //                    fVisibilityPct += ite->second._fVisCount;
 //                    fVisibilityPct = fVisibilityPct / CellVisibility::getMaxVis()*2.0f;
 //
 //                    //Compute Point Light distance percentage.
 //                    float fLightAtten = (tileCenter - lightCenter).squaredLength();
 //
 //                    //Add the lambert value to the tile
 //                    float lambert = fVisibilityPct * fOccludeValue;
 //                    pTile->getLightData()->addLambert(pLight->getLight(), lambert, fLightAtten);
 //
 //                    //Add lambert value to objects
 //                    std::set<PixObj*>* tileObjs = pTile->getCellManifold()->getObjects();
 //                    std::set<PixObj*>::iterator itLightOb = tileObjs->begin();
 //                    for (; itLightOb!= tileObjs->end(); itLightOb++) {
 //                        PixObj* tileob = *itLightOb;
 //                        //We COULD do object distances but for now it's best to keep it simple
 //                        //dist2 = (tileob->getCenter() - lightCenter).squaredLength();
 //                        tileob->getLightData()->addLambert(pLight->getLight(), lambert, fLightAtten);
 //                    }
 //
 //
 //                   
 //                }
 //            }
 //
 //            //Do fog (Optional)
 //            //NOTE: Fogging doesn't actually work with our setup.
 //            //We'll need to pass fog in as a separate color and blend to that color - right now it just
 //            // dims the tiles.
 //            //for (std::map<WorldCell*, CellVisibility>::iterator ite = charVisibleTiles.begin();
 //            //    ite != charVisibleTiles.end(); ite++) {
 //            //    WorldCell* pTile = ite->first;
 //
 //            //    if (pTile->getLightData()->isVisible()) {
 //
 //            //        tileCenter = pTile->getCenterR3();
 //            //        tileCenter.z = 0;
 //
 //            //        //Compute Character "fog" Distance
 //            //        float fFogAtten = (charCenter - tileCenter).length();
 //            //        pTile->getLightData()->doFog(fFogAtten, pChar->getAwarenessRadius() );
 //            //    }
 //
 //            //}
 //
 //
 //
 //        }
 //    }//bEditMode == false
 //
 //}

 /*
 //this should literally be the viewport box projected onto the world
 //Intersect viewport w / world
 vec3 pos;

 bool bh[4];

 vec3 d1 = getWorld25Plane()->intersectLinePoint(FST_PT(FrustumPoint::fpt_fbl), FST_PT(FrustumPoint::fpt_nbl), &bh[0]);
 vec3 d2 = getWorld25Plane()->intersectLinePoint(FST_PT(FrustumPoint::fpt_fbr), FST_PT(FrustumPoint::fpt_nbr), &bh[1]);
 vec3 d3 = getWorld25Plane()->intersectLinePoint(FST_PT(FrustumPoint::fpt_ftl), FST_PT(FrustumPoint::fpt_ntl), &bh[2]);
 vec3 d4 = getWorld25Plane()->intersectLinePoint(FST_PT(FrustumPoint::fpt_ftr), FST_PT(FrustumPoint::fpt_ntr), &bh[3]);


 if (bh[0] && bh[1] && bh[2] && bh[3]) {
 vec3 vi = vec3::minv(d1, vec3::minv(d2, vec3::minv(d3, d4)));
 vec3 va = vec3::maxv(d1, vec3::maxv(d2, vec3::maxv(d3, d4)));

 c._p0 = vec2(vi.x, vi.y);
 c._p1 = vec2(va.x, va.y);

 }
 else {
 //One or more didn't hit.  No box.
 c._p0 = vec2(-40, -40);
 c._p1 = vec2(40, 40);
 }*/

 //Update Lights
 //20170327 replacing this with the light / char update routine.
 //CongaRoom* cr = dynamic_cast<CongaRoom*>(getContext()->getRoom());
 //PixObj* pChar = getObj(cr->getFocusChar());
 //if(pChar != nullptr){
 //    WorldCell* pCharCell = getGlobalCellForPoint2d(pChar->getPos());
 //    if(pCharCell != nullptr){
 //        if(_pCharCellLast != pCharCell) { 
 //            updateLights();
 //            _pCharCellLast = pCharCell;
 //        }
 //    }
 //}


     /*
    std::vector<TileBufferVert> verts;
    std::vector<v_index> inds;


    for (int iy = 0; iy < CongaUtils::getNumCellsWidth(); ++iy) {
        for (int ix = 0; ix < CongaUtils::getNumCellsWidth(); ++ix) {
            ivec2 vi(ix,iy);
            WorldCell* pCell = getCellForIndex(vi);

            if (pCell != nullptr) {
                if (pCell->getBaseTile() != nullptr) {
                    makeMeshVert(verts, ix, iy, 0, grids, iBlank);//BL
                    makeMeshVert(verts, ix, iy, 1, grids, iBlank);//BR
                    makeMeshVert(verts, ix, iy, 2, grids, iBlank);//TL
                    makeMeshVert(verts, ix, iy, 3, grids, iBlank);//TR
                }
            }
        }
    }

    size_t iInd = 0;
    int vind = 0;

    for (int vind = 0; vind < verts.size(); vind+=4) {
        inds.push_back( vind + 0 ); //Tri1 CCW
        inds.push_back( vind + 1 );
        inds.push_back( vind + 3 );
        inds.push_back( vind + 0 ); //Tri2 CCW
        inds.push_back( vind + 3 );
        inds.push_back( vind + 2 );
    }


   //TileMesh->copyToGpu(&verts, &inds);
   */

   






 /*
 //Update lights, set them to 0
 //update tiles
 for (WorldCell* cell : _vecTopoCache) {
 if (cell->getBaseTile() != nullptr) {
 if (cell->getLightData()->isVisible()) {
 iLeft = iRight = iBot = iTop = iBlankFrame;
 iDomL = iDomR = iDomB = iDomT = 0;

 iTile = cell->getBaseTile()->getFrameAtlasIndex();
 if (iTile != MOTION25_INVALID_FRAME) {
 iMask = cell->getBaseTile()->getSpec()->getMaskSpec()->getFrames()[0];

 if (cell->getNeighbor(World25Side::e::gL) != nullptr) {
 if (cell->getNeighbor(World25Side::e::gL)->getBaseTile() != nullptr) {
 iLeft = cell->getNeighbor(World25Side::e::gL)->getBaseTile()->getFrameAtlasIndex();
 }
 }
 if (cell->getNeighbor(World25Side::e::gR) != nullptr) {
 if (cell->getNeighbor(World25Side::e::gR)->getBaseTile() != nullptr) {
 iRight = cell->getNeighbor(World25Side::e::gR)->getBaseTile()->getFrameAtlasIndex();
 }
 }
 if (cell->getNeighbor(World25Side::e::gB) != nullptr) {
 if (cell->getNeighbor(World25Side::e::gB)->getBaseTile() != nullptr) {
 iBot = cell->getNeighbor(World25Side::e::gB)->getBaseTile()->getFrameAtlasIndex();
 }
 }
 if (cell->getNeighbor(World25Side::e::gT) != nullptr) {
 if (cell->getNeighbor(World25Side::e::gT)->getBaseTile() != nullptr) {
 iTop = cell->getNeighbor(World25Side::e::gT)->getBaseTile()->getFrameAtlasIndex();
 }
 }

 //vOrigin = cell->getOriginR3();
 // vmin.construct(vOrigin.x, vOrigin.y);
 // vmax.construct(vOrigin.x + cw, vOrigin.y + cw);
 // midz = getWorld25Plane()->getBaseTileZIndex();
 // vColor = cell->getLightData()->getLightValue();

 const ivec2& iv = cell->getLocalPos();
 //Get the 4 verts.
 int offBL = TileMesh25::offBL(iv.x, iv.y);
 int offBR = TileMesh25::offBR(iv.x, iv.y);
 int offTL = TileMesh25::offTL(iv.x, iv.y);
 int offTR = TileMesh25::offTL(iv.x, iv.y);

 verts[offBL].c += cell->getLightData()->getLightValue();

 packVtx(cell, verts[offBL].viTile);

 // if (cell->getBaseTile() != nullptr) {
 //     CongaUtils::addWorldTile(pPlane, pAtlas,
 //         qbm,
 //         vmin, vmax, midz, vColor,
 //         iTile, iMask, iLeft, iRight, iBot, iTop);
 // }
 }
 }
 }
 }
 */

    //Update all tiles.
  //  Hash32 iTile, iMask, iLeft, iRight, iBot, iTop;
  //  int iDomL, iDomR, iDomB, iDomT;
   // vec2 vmin, vmax;
 //   vec3 vOrigin;
   // float midz;
   // vec3 vColor;



   //void World25Grid::gatherObjs()
//{
//    //**Deprecatd physics usess this now
//
//    //Should be called once per frame to update objects.
//    _mapFrameObjs.clear();
//    for (QuadLut::iterator it = _quadLut.begin(); it != _quadLut.end(); it++) {
//        WorldCell* cell = it->second;
//        for(std::set<PixObjId>::iterator obit = cell->getObjs().begin(); obit != cell->getObjs().end(); obit++){
//            PixObjId obid = *obit;
//#ifdef _DEBUG
//            if(_mapFrameObjs.find(obid) != _mapFrameObjs.end()){
//                //There's a dupe obuject here.
//                Gu::debugBreak();
//                
//                //Remove here.
//                //cell->removeObj(obid);
//
//            }
//            else
//#endif
//            {
//                _mapFrameObjs.insert(obid);
//            }
//
//        }
//    }
//}


//void World25Grid::resetLighting(bool bMakeBright) {
//    QuadLut::iterator qit = _quadLut.begin();
//    for (; qit != _quadLut.end(); qit++) {
//        WorldCell* cell = qit->second;
//
//        if (bMakeBright) {
//            cell->getLightData()->setBright();
//        }
//        else {
//            cell->getLightData()->setDark();
//        }
//    }
//    std::set<PixObj*>::iterator it;
//    it = getManifold()->getAll()->begin();
//    for (; it != getManifold()->getAll()->end(); ++it) {
//        PixObj* ob = *it;
//        if (bMakeBright) {
//            ob->getLightData()->setBright();
//        }
//        else {
//            ob->getLightData()->setDark();
//        }
//    }
//
//
//}




//void World25::getVisibleCellsForAwarenessBox(Box3f* pAwarenessBox, 
//    std::map<WorldCell*, CellVisibility>& __out_ visSet,
//    std::set<Box3f*>& __out_ setOccluders,
//    std::map<WorldCell*, CellVisibility>* __opt_ onlyIncludeSet) {
//    CellVisibility vis;
//
//
//    //TODO: this might be faster if we use the phy / manifolds.
//    WorldCell* pc = getGlobalCellForPoint2d(pAwarenessBox->center());
//    if (pc != nullptr) {
//        std::set<WorldCell*> toMarch;
//        std::set<WorldCell*> toAdd;
//
//        t_timeval iMarchStamp = Gu::getMicroSeconds();
//
//        //Put the seed cell in.
//        toMarch.insert(pc);
//        
//        vis._fVisCount = CellVisibility::getMaxVis();
//
//        if (onlyIncludeSet != nullptr) {
//            if (onlyIncludeSet->find(pc) != onlyIncludeSet->end()) {
//                visSet.insert(std::make_pair(pc, vis));
//            }
//        }
//        else {
//            visSet.insert(std::make_pair(pc, vis));
//        }
//
//
//        while (toMarch.size())
//        {
//            for (WorldCell* pCell : toMarch)
//            {
//                for (int iNeighbor = 0; iNeighbor < WorldCell::c_nNeighbors; ++iNeighbor)
//                {
//                    WorldCell* pNeighbor = pCell->getNeighbor((World25Side::e)iNeighbor);
//                    if (pNeighbor != nullptr && pNeighbor->_iLightMarchStamp != iMarchStamp)
//                    {
//                        pCell->_iLightMarchStamp = iMarchStamp;
//
//                        //Don't include tiles that have no sprite on them.
//                        if (pNeighbor->getBaseTile() != nullptr) {
//                            //First check visible
//                            if (pAwarenessBox->cubeIntersect_EasyOut_Inclusive(pNeighbor->getBoundBoxBvh()))
//                            {
//                                bool bVisible;
//                                bVisible = cellOcclusionQuery(pAwarenessBox, pNeighbor->getBoundBoxPhysical(), setOccluders, vis);
//                                
//                                //If visible, add tSZZ the set
//                                if (bVisible == true) {
//                                    // pNeighbor->_bIsOccluder = false;
//                                   addOccluders(pNeighbor, setOccluders);
//                                   //     setOccluders.insert(pNeighbor->getBoundBoxPhysical());
//                                   // }
//
//                                    if (onlyIncludeSet != nullptr) {
//                                        if (onlyIncludeSet->find(pNeighbor) != onlyIncludeSet->end()) {
//                                            toAdd.insert(pNeighbor);
//                                            visSet.insert(std::make_pair(pNeighbor, vis));
//                                        }
//                                    }
//                                    else {
//                                        toAdd.insert(pNeighbor);
//                                        visSet.insert(std::make_pair(pNeighbor, vis));
//                                    }
//                                }
//                            }
//                        }
//
//                    }
//
//
//
//                }
//            }
//
//
//            toMarch.clear();
//            for (WorldCell* pAdd : toAdd) {
//                toMarch.insert(pAdd);
//            }
//            toAdd.clear();
//
//        }
//
//        toMarch.clear();
//        toAdd.clear();
//
//    }
//    else {
//        //RutRo
//    }
//
//}

    //if(in_01(t0.x)){
    //    tx = t0.x;
    //}
    //if(in_01(t1.x) && (t1.x < t0.x)){
    //    tx = t1.x;
    //}
    //if (in_01(t0.y)) {
    //    ty = t0.y;
    //}
    //if (in_01(t1.y) && (t1.y < t0.y)) {
    //    ty = t1.y;
    //}    
    //if (in_01(t0.z)) {
    //    tz = t0.z;
    //}
    //if (in_01(t1.z) && (t1.z < t0.z)) {
    //    tz = t1.z;
    //}
    //if(((tx < 0) && countX) || ((ty < 0) && countY) || ((tz < 0) && countZ)) {
    //    return false;
    //} 
    //return broMin(tx, broMin(ty, tz));


    /*
    //Attempt to see if the given values intersect.  
    if ( (bCheckingIfStuck==true) || (countX && countY)) {
        if (int_intersect_t(t0.x, t1.x, t0.y, t1.y) == false) {
            return false;
        }
    }
    if ((bCheckingIfStuck == true) || (countY && countZ)) {
        if (int_intersect_t(t0.y, t1.y, t0.z, t1.z) == false) {
            return false;
        }
    }
    if ((bCheckingIfStuck == true) || (countX && countZ)) {
        if (int_intersect_t(t0.x, t1.x, t0.z, t1.z) == false) {
            return false;
        }
    }
    */



	/*
void World25Grid::split(Gn2* parent, float maxHeight, WorldCellFile* pFile, int* iCell, World25GridGen::e eg) {

    float width = parent->_box._max.x - parent->_box._min.x;
    float height = parent->_box._max.y - parent->_box._min.y;

    if (height <= maxHeight) {
        vec3 origin = getOriginR3();
        float cw = CongaUtils::getCellWidth();
        float ch = CongaUtils::getCellHeight();

        //Create a node data
        vec3 wv;
        wv.x = parent->_box._min.x + cw * 0.5f;
        wv.y = parent->_box._min.y + ch * 0.5f;
        wv.z = parent->_box._min.z + cw * 0.5f;

        
        //Here:
        //Get a point in cell 0 (the bottom left cell)
        //then add the cell width to that point for x, and z. this makes us our 4 cells.
        //each "final" parent has 4 cells.
        

        wv = wv - origin;
        int ix;
        int iy;
        int iz;

        ix = (int)(wv.x / cw);
        iy = (int)(wv.y / ch);
        iz = (int)(wv.z / cw);

        parent->_pCell = makeCell(ix, iy, iz, pFile, iCell, eg, parent);// new WorldCell();
    }
    else {
        Gn2* c[8];

        // c  d
        // a  b   >>X  ^Y

        //|----*max
        //|    |
        //*min-|

       // float w2 = (parent->_quad._max().x - parent->_quad._min().x) * 0.5f;
      //  float cx = parent->_quad._min().x + w2;
       // float cy = parent->_quad._min().y + w2;

        parent->_vecChildren = new  std::vector<Gn2*>();
        for(int ic=0; ic<8; ++ic){
            c[ic] = new Gn2();
            c[ic]->_box = parent->_box;
            parent->_vecChildren->push_back(c[ic]);
        }

        //   6 7
        //   4 5
        // 2 3
        // 0 1  >X  ^Y  /^ Z

        vec3 vc = parent->_box.center();

        c[0]->_box._max.x = vc.x;
        c[0]->_box._max.y = vc.y;
        c[0]->_box._max.z = vc.z;

        c[1]->_box._min.x = vc.x;
        c[1]->_box._max.y = vc.y;
        c[1]->_box._max.z = vc.z;

        c[2]->_box._max.x = vc.x;
        c[2]->_box._max.y = vc.y;
        c[2]->_box._min.z = vc.z;

        c[3]->_box._min.x = vc.x;
        c[3]->_box._max.y = vc.y;
        c[3]->_box._min.z = vc.z;
        //
        c[4]->_box._max.x = vc.x;
        c[4]->_box._min.y = vc.y;
        c[4]->_box._max.z = vc.z;

        c[5]->_box._min.x = vc.x;
        c[5]->_box._min.y = vc.y;
        c[5]->_box._max.z = vc.z;

        c[6]->_box._max.x = vc.x;
        c[6]->_box._min.y = vc.y;
        c[6]->_box._min.z = vc.z;

        c[7]->_box._min.x = vc.x;
        c[7]->_box._min.y = vc.y;
        c[7]->_box._min.z = vc.z;

        for (int ic = 0; ic<8; ++ic) {
            split(c[ic], maxHeight, pFile, iCell, eg);
        }
    }
}*/

/*
void World25Grid::makeMeshVerts(TileMesh25* pTileMesh, WorldCell* pCell){
    TileBufferVert* p0, *p1, *p2, *p3;

    World25Grid* grids[9];
    getN9(grids);
    int iBlank = _pWorld25->getWorldAtlas()->getLinearTileOffset(
        _pWorld25->getMotionBucket()->getBlankTile()->getFrames()[0]
    );

    if(pTileMesh->isFull() == false){
        pTileMesh->getQuad(p0, p1, p2, p3);

        int ix = pCell->getLocalPos().x;
        int iy = pCell->getLocalPos().y;
        if (pCell != nullptr) {
            if (pCell->getBaseTile() != nullptr) {
                makeMeshVert(*p0, ix, iy, 0, grids, iBlank);//BL
                makeMeshVert(*p1, ix, iy, 1, grids, iBlank);//BR
                makeMeshVert(*p2, ix, iy, 2, grids, iBlank);//TL
                makeMeshVert(*p3, ix, iy, 3, grids, iBlank);//TR
            }
        }
    }
}
void World25Grid::makeMeshVert(TileBufferVert& vert, int ix, int iy, int iCorner, World25Grid* grids[9], int iBlank) {
    WorldCell* cells[9];
    
    //TileBufferVert vert;
    if(iCorner == 0){
        vert.v = getOriginR3() + vec3( ix      * CongaUtils::getCellWidth(),  iy     * CongaUtils::getCellWidth(), 0);
    }
    else if(iCorner == 1){
        vert.v = getOriginR3() + vec3((ix + 1) * CongaUtils::getCellWidth(),  iy     * CongaUtils::getCellWidth(), 0);
    }
    else if(iCorner == 2){
        vert.v = getOriginR3() + vec3( ix      * CongaUtils::getCellWidth(), (iy + 1)* CongaUtils::getCellWidth(), 0);
    }
    else if(iCorner == 3){
        vert.v = getOriginR3() + vec3((ix + 1) * CongaUtils::getCellWidth(), (iy + 1)* CongaUtils::getCellWidth(), 0);
    }

    vert.c.construct(0, 0, 0);
    vert.viTile = 0;

    //getC4Corner(ix, iy, iCorner, grids, cells);
    getC9Cell(ix, iy, grids, cells);

    addQuadVertInfluence(vert, 24, 0, iBlank, cells[0], cells[4], cells[1], cells[3]);
    addQuadVertInfluence(vert, 16, 0, iBlank, cells[1], cells[4], nullptr, nullptr );
    addQuadVertInfluence(vert, 8 , 0, iBlank, cells[2], cells[4], cells[1], cells[5]);

    addQuadVertInfluence(vert, 0 , 0, iBlank, cells[3], cells[4], nullptr, nullptr );
    addQuadVertInfluence(vert, 24, 1, iBlank, cells[4], cells[4], nullptr, nullptr );
    addQuadVertInfluence(vert, 16, 1, iBlank, cells[5], cells[4], nullptr, nullptr );

    addQuadVertInfluence(vert, 8 , 1, iBlank, cells[6], cells[4], cells[3], cells[7]);
    addQuadVertInfluence(vert, 0 , 1, iBlank, cells[7], cells[4], nullptr, nullptr );
    addQuadVertInfluence(vert, 24, 2, iBlank, cells[8], cells[4], cells[5], cells[7]);
    
    if(cells[4] != nullptr) {
        if(cells[4]->getBaseTile() != nullptr){
            std::shared_ptr<Atlas> pAtlas = _pWorld25->getWorldAtlas();
            int iTile = pAtlas->getLinearTileOffset(
                cells[4]->getBaseTile()->getSpec()->getMaskSpec()->getFrames()[0]
            );
            vert.viTile.z |= (iTile << 16);
        }
    }

    vert.uv.x = (iCorner == 1 || iCorner == 3) ? 1.0f : 0.0f; // U
    vert.uv.y = (iCorner == 2 || iCorner == 3) ? 1.0f : 0.0f; // V

    //verts.push_back(vert);
}
void World25Grid::getC4Corner(int cx, int cy, int corner, World25Grid* grids[9], WorldCell* (&out_cells)[4]) {

    if(corner == 0) { //BL
        out_cells[0] = getCellForVtx(cx - 1, cy - 1, grids); // BL
        out_cells[1] = getCellForVtx(cx    , cy - 1, grids); // BR
        out_cells[2] = getCellForVtx(cx - 1, cy    , grids); // TL
        out_cells[3] = getCellForVtx(cx    , cy    , grids); // TR
    }
    else if(corner == 1) { //BR
        out_cells[0] = getCellForVtx(cx    , cy - 1, grids); // BL
        out_cells[1] = getCellForVtx(cx + 1, cy - 1, grids); // BR
        out_cells[2] = getCellForVtx(cx    , cy    , grids); // TL
        out_cells[3] = getCellForVtx(cx + 1, cy    , grids); // TR
    }
    else if(corner == 2) { //TL
        out_cells[0] = getCellForVtx(cx - 1, cy    , grids); // BL
        out_cells[1] = getCellForVtx(cx    , cy    , grids); // BR
        out_cells[2] = getCellForVtx(cx - 1, cy + 1, grids); // TL
        out_cells[3] = getCellForVtx(cx    , cy + 1, grids); // TR
    }
    else if(corner == 3) { //TE
        out_cells[0] = getCellForVtx(cx    , cy    , grids); // BL
        out_cells[1] = getCellForVtx(cx + 1, cy    , grids); // BR
        out_cells[2] = getCellForVtx(cx    , cy + 1, grids); // TL
        out_cells[3] = getCellForVtx(cx + 1, cy + 1, grids); // TR
    }
}
void World25Grid::getC9Cell(int cellX, int cellY, World25Grid* grids[9], WorldCell* (&out_cells)[9]) {
    int ic=0;
    for(int iy=-1; iy<=1; iy++){
        for(int ix=-1; ix<=1; ix++){
            out_cells[ic++] = getCellForVtx(cellX + ix, cellY + iy, grids); // BL
        }
    }
}
void World25Grid::addQuadVertInfluence(TileBufferVert& vert, int bitShift, int comp, int iBlank,
    WorldCell* pN0, WorldCell* pN1, WorldCell* pN2, WorldCell* pN3) {
    int iTile = 0;
    std::shared_ptr<Atlas> pAtlas = _pWorld25->getWorldAtlas();

    int tile0 = -1;
    int tile1 = -1;
    int tile2 = -1;
    int tile3 = -1;

    if (pN0 != nullptr) {
        if (pN0->getBaseTile() != nullptr) {
            tile0 = pN0->getBaseTile()->getSpec()->getBaseTileIndex();
           // vert.c += pN0->getLightData()->getLightValue();
        }
    }
    if (pN1 != nullptr) {
        if (pN1->getBaseTile() != nullptr) {
            tile1 = pN1->getBaseTile()->getSpec()->getBaseTileIndex();
        }
    }
    if (pN2 != nullptr) {
        if (pN2->getBaseTile() != nullptr) {
            tile2 = pN2->getBaseTile()->getSpec()->getBaseTileIndex();
        }
    }
    if (pN3 != nullptr) {
        if (pN3->getBaseTile() != nullptr) {
            tile3 = pN3->getBaseTile()->getSpec()->getBaseTileIndex();
        }
    }

    //here - set the neighbor texture ID to the texture of the greater "index"
    // because we have to sort this way or else you'll get invalid neighboring textures.

    if(tile0 == -1 && tile1 == -1 && tile2 == -1 && tile3 == -1) { // Blank
        iTile = iBlank;
    }
    else if(tile0 >= tile1 && tile0 >= tile2 && tile0 >= tile3){
        iTile = pAtlas->getLinearTileOffset(pN0->getBaseTile()->getFrameAtlasIndex());
    }
    else if (tile1 >= tile0 && tile1 >= tile2 && tile1 >= tile3) {
        iTile = pAtlas->getLinearTileOffset(pN1->getBaseTile()->getFrameAtlasIndex());
    }
    else if (tile2 >= tile0 && tile2 >= tile1 && tile2 >= tile3) {
        iTile = pAtlas->getLinearTileOffset(pN2->getBaseTile()->getFrameAtlasIndex());
    }
    else if (tile3 >= tile0 && tile3 >= tile1 && tile3 >= tile2) {
        iTile = pAtlas->getLinearTileOffset(pN3->getBaseTile()->getFrameAtlasIndex());
    }

    if (comp == 0) {
        vert.viTile.x |= (iTile << bitShift);
    }
    else if (comp == 1) {
        vert.viTile.y |= (iTile << bitShift);
    }
    else if (comp == 2) {
        vert.viTile.z |= (iTile << bitShift);
    }
    else if (comp == 3) {
        vert.viTile.w |= (iTile << bitShift);
    }
    else {
        BroThrowNotImplementedException();
    }
}
*/
//void World25Grid::getN9(World25Grid* __out_(&neighbor)[9]) {
//    //Get this grid, and the 8 surrounding grids.
//    // This is indexed as follows
//    // 6  7  8
//    // 3  4  5
//    // 0  1  2
//    // ---> +x  ^+y
//    // where index 4 is this node.
//    int fw = CongaUtils::getNodeWidth();
//    for (int z = -1; z <= 1; ++z) {
//    for (int y = -1; y <= 1; ++y) {
//    for (int x = -1; x <= 1; ++x) {
//        //Fix this function - it's wrong.  
//        Gu::debugBreak();
//        int nOff = (z+1) * 9 + (y+1) * 3 + (x+1);
//        float xOff = x * CongaUtils::getNodeWidth();
//        float yOff = y * CongaUtils::getNodeHeight();
//        float zOff = z * CongaUtils::getNodeWidth();
//
//        neighbor[nOff] = getNeighborOffset(xOff, yOff, zOff);
//    }
//    }
//}
//WorldCell* World25Grid::getCellForVtx(int vt_x, int vt_y, int vt_z, World25Grid* grids[9]) {
//    int gridI, gridJ;
//    ivec2 viInd;
//    WorldCell* pRet = nullptr;
//
//    //*Bottom left corner of cell is the vertex.
//    //Loop Over
//    if(vt_x < 0) {
//        gridI = 0;
//        viInd.x = CongaUtils::getNumCellsWidth() - 1;
//    }
//    else if(vt_x == CongaUtils::getNumCellsWidth()) {
//        gridI = 2;
//        viInd.x = 0;
//    }
//    else {
//        gridI = 1;
//        viInd.x = vt_x;
//    }
//
//    if (vt_z < 0) {
//        gridJ = 0;
//        viInd.y = CongaUtils::getNumCellsWidth() - 1;
//    }
//    else if (vt_z == CongaUtils::getNumCellsWidth()) {
//        gridJ = 2;
//        viInd.y = 0;
//    }
//    else {
//        gridJ = 1;
//        viInd.y = vt_z;
//    }
//
//    int iGrid = 3 * gridJ + gridI;
//    
//    if(grids[iGrid] != nullptr) {
//        if(iGrid==4){
//            //Center
//            int nnn=0;
//            nnn++;
//        }
//
//        pRet = grids[iGrid]->getCellForIndex(viInd);
//    }
//    else {
//        pRet =  nullptr;
//    }
//
//    return pRet;
//}



//void World25Grid::gatherVisibleObjects(float delta, std::set<PixObj*>& setCollected, std::shared_ptr<FrustumBase> pFrust) {
//
//    //Copies all the objects to the quad buffer.
//    std::set<PixObj*>::iterator it;
//    W25ObjManfiold* pManifold = getManifold();
//    it = pManifold->getAll()->begin();
//    vec3 vp;
//    for (; it != pManifold->getAll()->end(); ++it) {
//        PixObj* ob = *it;
//        if(pFrust->hasAABB(ob->getBoundBoxObject())) {
//            setCollected.insert(ob);
//        }
//    }
//}



    // c  d     c2  c3
    // a  b     c0  c1
    //if(!a && !b && !c && !d){
    //    //Emp[ty
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Empty;
    //}
    //else if( a && !b && !c && !d){
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri02;
    //    addConfigTriangle(eSide, c0, c1, c2);
    //}
    //else if (!a && b && !c && !d) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri03;
    //    addConfigTriangle(eSide, c0, c1, c3);
    //}
    //else if (!a && !b && c && !d) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri01;
    //    addConfigTriangle(eSide, c0, c3, c2);
    //}
    //else if (!a && !b && !c && d) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri04;
    //    addConfigTriangle(eSide, c1, c3, c2);
    //}
    //else {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Quad;
    //    addConfigQuad(eSide, c0, c1, c2, c3);
    //}

    //if(c && d){
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Quad;
    //    addConfigQuad(eSide, c0, c1, c2, c3); 
    //}
    //else if(c && b){
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Quad;
    //    addConfigQuad(eSide, c0, c1, c2, c3);
    //}
    //else if (d && a) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Quad;
    //    addConfigQuad(eSide, c0, c1, c2, c3);
    //}
    //else if (d && a) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Quad;
    //    addConfigQuad(eSide, c0, c1, c2, c3);
    //}
    //else if (c) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri01;
    //    addConfigTriangle(eSide, c0, c3, c2);
    //}
    //else if (d) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri04;
    //    addConfigTriangle(eSide, c1, c3, c2);
    //}
    //Add a quad or a triangle based on the side configuration
    // 2   3
    // 0   1
    //    bool v0 = getCornerVal(c0);
    //bool v1 = getCornerVal(c1);
    //bool v2 = getCornerVal(c2);
    //bool v3 = getCornerVal(c3);
    //if (v0 && v1 && v2 && v3) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Quad;
    //    addConfigQuad(eSide, c0, c1, c2, c3);
    //}
    //else if (v0 && v3 && v2) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri01;
    //    addConfigTriangle(eSide, c0, c3, c2);
    //}
    //else if (v0 && v1 && v2) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri02;
    //    addConfigTriangle(eSide, c0, c1, c2);
    //}
    //else if (v0 && v1 && v3) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri03;
    //    addConfigTriangle(eSide, c0, c1, c3);
    //}
    //else if (v1 && v3 && v2) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri04;
    //    addConfigTriangle(eSide, c1, c3, c2);
    //}
    //extended
    //else if (v0 && v3 || v3 && v2 || v0 && v2) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri01;
    //    addConfigTriangle(eSide, c0, c3, c2);
    //}
    //else if (v0 && v1 || v1 && v2 || v0 && v2) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri02;
    //    addConfigTriangle(eSide, c0, c1, c2);
    //}
    //else if (v0 && v1 || v1 && v3 || v0 && v3) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri03;
    //    addConfigTriangle(eSide, c0, c1, c3);
    //}
    //else if (v2 && v1 || v1 && v3 || v2 && v3) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri04;
    //    addConfigTriangle(eSide, c1, c3, c2);
    //}
    //else {
    //    //Empty
    //    //This will remove all the misc configs that don't have a configuration.
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Empty;
    //}



	        //if (sc == W25SideConf::e::Conf_Quad ) {
        //    vv = cc->getVerts(eSide)[0];
        //    vv.v += vp;
        //    vv.x = xbl;
        //    verts_level->push_back(vv);

        //    vv = cc->getVerts(eSide)[1];
        //    vv.v += vp;
        //    vv.x = xbr;
        //    verts_level->push_back(vv);
        //    
        //    vv = cc->getVerts(eSide)[2];
        //    vv.v += vp;
        //    vv.x = xtl;
        //    verts_level->push_back(vv);

        //    vv = cc->getVerts(eSide)[3];
        //    vv.v += vp;
        //    vv.x = xtr;
        //    verts_level->push_back(vv);

        //    for (int ii = 0; ii < cc->getIndexes(eSide).size(); ++ii) {
        //        inds_level->push_back(vtxBase + cc->getIndexes(eSide)[ii]);
        //    }

        //}
        //else 







/*
void W25MeshConf::triangulateCross(W25Plane::e ePlane, int c0, int c1, int c2, int c3, int oppBot, int oppTop){
    //bool a = getCornerVal(c0);
    //bool b = getCornerVal(c1);
    //bool c = getCornerVal(c2);
    //bool d = getCornerVal(c3);

    bool op0 = getCornerVal(oppBot);
    bool op1 = getCornerVal(oppTop);
    //Conf_Tri01
    //   2---3
    //   | /
    //   0
    //
    //Conf_Tri02 - a
    //   2
    //   | \
    //   0---1
    //
    //Conf_Tri03 - b
    //       3
    //     / |
    //   0---1
    //
    //Conf_Tri04
    //   2---3
    //     \ |
    //       1
    if(op0 || op1){
        //Side will not be shown , there is a vertex there
        _eSideConf[ePlane] = W25SideConf::e::Conf_Empty;
    }
    else {
        //This is the same configuration as a side except it's hidden when an OPP vertex is visible
        triangulateSide(ePlane, c0, c1, c2, c3);
    }
}
void W25MeshConf::triangulateSide(
    W25Plane::e eSide,
    int ia, int ib, int ic, int id
) {

 
    bool a = getCornerVal(ia);
    bool b = getCornerVal(ib);
    bool c = getCornerVal(ic);
    bool d = getCornerVal(id);
     

    //, Conf_Tri01
    ////+---+
    ////| /
    ////+
    //, Conf_Tri02 - a
    ////+
    ////| \
    // //+---+
    //, Conf_Tri03 - b
    ////    +
    ////  / |
    ////+---+
    //, Conf_Tri04
    ////+---+
    ////  \ |
    ////    +
    // 
    //c----d
    //|    |
    //a----b
    //1) Exclude planes.  No planes.  Volume Only.
    //if (a && b && c && d) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Quad;
    //    addConfigQuad(eSide, ia, ib, ic, id);
    //}
    //else if (a && d && c) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri01;
    //    addConfigTriangle(eSide, ia, id, ic);
    //}
    //else if (a && b && c) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri02;
    //    addConfigTriangle(eSide, ia, ib, ic);
    //}
    //else if (a && b && d) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri03;
    //    addConfigTriangle(eSide, ia, ib, id);
    //}
    //else if (b && d && c) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri04;
    //    addConfigTriangle(eSide, ib, id, ic);
    //}


    //else if (d) {
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Tri03;
    //    addConfigTriangle(eSide, ia, ib, id);
    //}
    //else {
    //    //Empty
    //    //This will remove all the misc configs that don't have a configuration.
    //    _eSideConf[eSide] = W25SideConf::e::Conf_Empty;
    //}

}
void W25MeshConf::triangulateCap(W25Plane::e side) {
    //We use a "highest float" mechanism.
    int b0 = 0, b1 = 1, b2 = 4, b3 = 5; // Bottom V8 Indexes
    int t0 = 2, t1 = 3, t2 = 6, t3 = 7; // Top

    bool vb0 = getCornerVal(b0);
    bool vb1 = getCornerVal(b1);
    bool vb2 = getCornerVal(b2);
    bool vb3 = getCornerVal(b3);

    bool vt0 = getCornerVal(t0);
    bool vt1 = getCornerVal(t1);
    bool vt2 = getCornerVal(t2);
    bool vt3 = getCornerVal(t3);

    //t2  t3         ^
    //t0  t1  --> x  |z

    //The resulting corner indexes, and whether they have a value.
    int t00; 
    int t01; 
    int t02; 
    int t03; 

    //if(vt0 && vt1 && vt2 && vt3) { 
    //    addConfigTriangle(side, t0, t1, t3);
    //    addConfigTriangle(side, t0, t3, t2);
    //}
    //if (vt0 && vt1 && vt2) {
    //    addConfigTriangle(side, t0, t1, t2);
    //    if(vb3) {
    //        addConfigTriangle(side, t1, b3, t2);
    //    }
    //}
    //if (vt0 && vt1 && vt2) {
    //    addConfigTriangle(side, t0, t1, t2);
    //    addConfigTriangle(side, t1, b3, t2);
    //}


    //no matter what we alwaysa need the top triangles.
    //2 - but we can't have volume-less planes.
    //But here is the problem - we don't make tops when all 3 vertexes are not present, but we may still have
    // a side there. Because the other side isn't present (missing a vertex) . we remove the top
    // and we have a stranded side.
    if (side == World25Side::e::gT) {
        //Flip
        _eSideConf[World25Side::e::gT] = W25SideConf::e::Conf_Top;
        t00 = vt0 ? t0 : (vb0 ? b0 : -1);
        t01 = vt1 ? t1 : (vb1 ? b1 : -1);
        t02 = vt2 ? t2 : (vb2 ? b2 : -1);
        t03 = vt3 ? t3 : (vb3 ? b3 : -1);
        
        //t00 = vt0 ? t0 : b0;
        //t01 = vt1 ? t1 : b1;
        //t02 = vt2 ? t2 : b2;
        //t03 = vt3 ? t3 : b3;
    }
    else {
        _eSideConf[World25Side::e::gB] = W25SideConf::e::Conf_Bot;
        t00 = vb0 ? b1 : (vt0 ? b1 : -1);
        t01 = vb1 ? b0 : (vt1 ? b0 : -1);
        t02 = vb2 ? b3 : (vt2 ? b3 : -1);
        t03 = vb3 ? b2 : (vt3 ? b2 : -1);

        //t00 = vb0 ? b1 : t1;
        //t01 = vb1 ? b0 : t0;
        //t02 = vb2 ? b3 : t3;
        //t03 = vb3 ? b2 : t2;
    }

    ////If the corners have value then add them as triangles.
    if(t00 != -1 && t01 != -1 && t03 != -1) {
        addConfigTriangle(side, t00, t01, t03);
    }
    if(t00 != -1 && t03 != -1 && t02 != -1) {
        addConfigTriangle(side, t00, t03, t02);
    }
}
*/




//void W25MeshMaker::makeFace(vec3& bl, vec3& br, vec3& tl, vec3& tr,
//    std::vector<v_v3c3x2n3>& verts, std::vector<v_index>& inds, vec3& vOffset, std::shared_ptr<AtlasSprite> ps) {
//    vec3 d1 = tl - bl;
//    vec3 d2 = br - bl;
//    vec3 n = (d1.cross(d2)).normalize();
//
//    int ic = verts.size();
//
//    vec2 xbl, xbr, xtl, xtr;
//    if (ps != nullptr) {
//        AssertOrThrow2(ps != nullptr);
//        _pWorldAtlas->getTCoords(&(ps->_viGridPos), &xbl, &xbr, &xtl, &xtr);
//    }
//    else {
//        //Store these
//        xbl = vec2(-1, 0);
//        xbr = vec2(-2, 0);
//        xtl = vec2(-3, 0);
//        xtr = vec2(-4, 0);
//    }
//
//    //bl
//    v_v3c3x2n3 vv;
//    vv.n = n;
//    // vv.x = vec2(0, 0);
//    vv.x = xbl;
//    vv.v = vOffset + bl;
//    vv.c.construct(1,1,1);
//    verts.push_back(vv);
//    //br
//    vv.n = n;
//    // vv.x = vec2(1, 0);
//    vv.x = xbr;
//    vv.v = vOffset + br;
//    vv.c.construct(1, 1, 1);
//    verts.push_back(vv);
//    //tl
//    vv.n = n;
//    //vv.x = vec2(0, 1);
//    vv.x = xtl;
//    vv.v = vOffset + tl;
//    vv.c.construct(1, 1, 1);
//    verts.push_back(vv);
//    //tr
//    vv.n = n;
//    //vv.x = vec2(1, 1);
//    vv.x = xtr;
//    vv.v = vOffset + tr;
//    vv.c.construct(1, 1, 1);
//    verts.push_back(vv);
//    
//    inds.push_back(ic + 0);
//    inds.push_back(ic + 1);
//    inds.push_back(ic + 3);
//
//    inds.push_back(ic + 0);
//    inds.push_back(ic + 3);
//    inds.push_back(ic + 2);
//}



    //No longer use conf to/bot. Instead use this to deter
    /*
    else if (sc == W25SideConf::e::Conf_Top || sc == W25SideConf::e::Conf_Bot) {
    //Top/bot
    if(cc->getVerts(eSide).size() >0){
    vv = cc->getVerts(eSide)[0];
    vv.v += vp;
    vv.x = xbl;
    verts_level->push_back(vv);

    vv = cc->getVerts(eSide)[1];
    vv.v += vp;
    vv.x = xbr;
    verts_level->push_back(vv);

    vv = cc->getVerts(eSide)[2];
    vv.v += vp;
    vv.x = xtr;
    verts_level->push_back(vv);
    }

    if (cc->getVerts(eSide).size() >3) {
    vv = cc->getVerts(eSide)[3];
    vv.v += vp;
    vv.x = xbl;
    verts_level->push_back(vv);

    vv = cc->getVerts(eSide)[4];
    vv.v += vp;
    vv.x = xtr;
    verts_level->push_back(vv);

    vv = cc->getVerts(eSide)[5];
    vv.v += vp;
    vv.x = xtl;
    verts_level->push_back(vv);
    }

    for (int ii = 0; ii < cc->getIndexes(eSide).size(); ++ii) {
    inds_level->push_back(vtxBase + cc->getIndexes(eSide)[ii]);
    }

    }
    */

	

    //W25Sc::e c_c = getW25Config(gc->getGeom())->getTcConf(iSide, iTri);
    //W25Sc::e n_c = getW25Config(gn->getGeom())->getTcConf(opp, iTri);
    //
    //bool c_p = getW25Config(gc->getGeom())->getPConf(iSide, iTri);
    //bool n_p = getW25Config(gn->getGeom())->getPConf(opp, iTri);

    //W25Vc::e c_v = getW25Config(gc->getGeom())->getVisConf(iSide);
    //W25Vc::e n_v = getW25Config(gn->getGeom())->getVisConf(iSide);
    //
    //if(c_nt == 0) {
    //    bIsHidden = true;
    //}
    //else if(c_nt==2 && n_nt==2 && c_p && n_p){
    //    //Quad and planar
    //    bIsHidden = true;
    //}
    //else if (n_nt == 2 && n_p && c_p) {

    //}
    //else if(c_nt==2){

    //}


    //Side config for neighbor

   // if(cc_n->

    //Check for hidden side.
    //DEBUG - don't hide for now.
    //if (cc_n && (cc_n->getGeomId() != W25GEOM_EMPTY)) {
        
      //  if ((W25Plane::e)iSide == World25Side::e::gT) {
      //      //if ((sc == W25SideConf::e::Conf_Top) && (nsc == W25SideConf::e::Conf_Bot)) {
      //      //    bIsHidden = true;
      //      //}
      //  }
      //  else if ((W25Plane::e)iSide == World25Side::e::gB) {
      //      //         if ((sc == W25SideConf::e::Conf_Bot) && (nsc == W25SideConf::e::Conf_Top)) {
      //      //             bIsHidden = true;
      //      //         }
      //  }
      //  else {
      //      //Hide cells with solid matching sides.  Don't do neighbor hiding for top/bpttom (irregular)
      //      //      if (nsc == W25Sc::e::Conf_Quad && bInPlane) {
      //      //          bIsHidden = true;
      //      //      }
      //      // *NOTE: FIX OppSideConf 4/13/17
      //      //   else 
      //      //            if (getOppSideConf(sc) == nsc ) {
      //      //            //TODO: test this later
      //      //            //Hide sides that have the same "mirror" config - which inadvertently will hide the triangles.
      //      //            bIsHidden = true;
      //      //        }
      //  }
    //}



	
//void WorldCell::addObj(PixObj* ob) { 
//    _vecObjects.insert(ob->getId());
//    ob->setCurCell(this);
//
//    stackObjects();
// //   _pWorld25Grid->gatherObjs();
//}
//void WorldCell::removeObj(PixObj* ob){
//    std::set<PixObjId>::iterator it = _vecObjects.find(ob->getId());
//    if (it != _vecObjects.end()) {
//        _vecObjects.erase(it);
//    }
//    ob->setCurCell(nullptr);
//
//    stackObjects();
//  //  _pWorld25Grid->gatherObjs();
//}
//void WorldCell::stackObjects() {
//    //Add the object and re-stack objects
//    vec3 vPos = getGPos().getVec3();
//
//    vPos.z = CongaUtils::getObjectZIndexBase();
//
//    std::set<PixObjId>::iterator it = _vecObjects.begin();
//
//    for (;it!=_vecObjects.end(); it++) {
//        PixObjId obid = *it;
//        PixObj* ob = _pWorld25Grid->getWorld25()->getObj(obid);
//        if (ob != nullptr) {
//            if(ob->getState() != PixObjState::e::Moving){
//                ob->setPos(vPos);
//            }
//          //  ob->update(0);//**do not call update!!
//        }
//        vPos += CongaUtils::getObjectStackIncrement();
//    }
//}
//WorldCell::CellSize WorldCell::fudgePack() {
//    if(_pMotion==nullptr){
//        return 0;
//    }
//    else{
//        return (WorldCell::CellSize)_pMotion->getFrameAtlasIndex();
//    }
//}

//void WorldCell::setSolidTile(Motion25Spec* sp){
//    DEL_MEM(_pBaseTile);
//    if(sp!=nullptr){
//        _pBaseTile = new Motion25(sp);
//    }
//}
//void WorldCell::setLiquidTile(Motion25Spec* sp) {
//    DEL_MEM(_pLiquidTile);
//    if (sp != nullptr) {
//        _pLiquidTile = new Motion25(sp);
//    }
//}
//void WorldCell::setNineMotion(Motion25Spec* sp) {
//    DEL_MEM(_pNineTile);
//    if (sp != nullptr) {
//        _pNineTile = new Motion25(sp);
//    }
//}
//void WorldCell::getObjectList(std::vector<PixObj*>& __out_ vecObj) {
//    //This will give us all the objects which have their CENTER in this cell
//    vecObj.clear();
//
//    std::multimap<float ,PixObj*>::iterator ite = _pManifold->getObjects()->begin();
//    for(;ite != _pManifold->getObjects()->end(); ite++) {
//        PixObj* ob = ite->second;
//        //This should allow for all ponits to be included only in single cells.
//        if(this->getBoundBoxBvh()->containsBottomLeftInclusive(ob->getBoundBoxObject()->center())){
//            vecObj.push_back(ob);
//        }
//    }
//}
//void WorldCell::getSnappedObjectList(std::vector<PixObj*>& __out_ vecSnapped) {
//    vecSnapped.clear();
//
//    std::vector<PixObj*> vecCollected;
//    std::vector<float> vecCollected_z;
//    std::vector<float> vecSnapped_z;
//
//    std::set<PixObj*>::iterator ite = _pManifold->getObjects().begin();
//    for(;ite != _pManifold->getObjects().end(); ite++) {
//        PixObj* ob = *ite;
//        //This should allow for all ponits to be included only in single cells.
//        if(this->getBoundBox()->containsBottomLeftInclusive(ob->getBoundBoxObject()->center())){
//            vecCollected.push_back(ob);
//            vecCollected_z.push_back(ob->getBoundBoxObject()->center().z);
//        }
//    }
//
//    //Sort objects by Z center of the bound box
//    while(vecCollected.size()) {
//        //float minz = FLT_MAX;
//        //PixObj* obMin;
//        float cz = *(vecSnapped_z.rbegin());
//        size_t i;
//        for (i=0; i<vecCollected_z.size(); i++){
//            float fz = vecCollected_z[i];
//            if(vecSnapped_z.size() == 0 || cz < fz){
//                break;
//            }
//        }
//
//        if(i>=0 && i<vecCollected_z.size()){
//            vecSnapped.push_back(vecCollected[i]);
//            vecSnapped_z.push_back(vecCollected_z[i]);
//            vecCollected_z.erase(vecCollected_z.begin()+i);
//        }
//
//    }
//
//    vecCollected.clear();
//    vecCollected_z.clear();
//    vecSnapped_z.clear();
//
//}




        //std::set<World25Grid* > vecGridsToSave;
        //std::map<World25Grid*, std::set<int>> vecMeshesLevel;
        //std::set<World25Grid*> vecMeshesGrid;

        //for (WorldEdit we : _vecWorldEdits) {
        //    if (bRedoMeshes == true) {
        //        if (we._pCell != nullptr) {
        //            std::map<World25Grid*, std::set<int>>::iterator ite = vecMeshesLevel.find(we._pGrid);
        //            if (ite == vecMeshesLevel.end()) {
        //                vecMeshesLevel.insert(std::make_pair(we._pGrid, std::set<int>()));
        //                ite = vecMeshesLevel.find(we._pGrid);
        //            }
        //            //Add this cell level if the whole grid isn't set.
        //            if (ite->second.find(-1) == ite->second.end()) {
        //                ite->second.insert(we._pCell->getLevel());
        //                for (int i = 0; i<6; ++i) {
        //                    ite->second.insert(we._pCell->getLevel());
        //                }
        //            }
        //        }
        //        else if (we._pGrid != nullptr) {
        //            //Insert -1 meaning "whole grid.
        //            std::map<World25Grid*, std::set<int>>::iterator ite = vecMeshesLevel.find(we._pGrid);
        //            if (ite == vecMeshesLevel.end()) {
        //                vecMeshesLevel.insert(std::make_pair(we._pGrid, std::set<int>()));
        //                ite = vecMeshesLevel.find(we._pGrid);
        //            }
        //            //Clear out other stuff, we're redoing the whole grid.
        //            ite->second.clear();
        //            ite->second.insert(-1);
        //        }
        //    }
        //    if (we._pCell != nullptr) {
        //        vecGridsToSave.insert(we._pCell->getGrid());
        //    }
        //    else if (we._pGrid != nullptr) {
        //        vecGridsToSave.insert(we._pGrid);
        //    }
        //}
		//vec3 World25::getProjectedViewCenter() {
//    ///View as projected DIRECTLY from the viewport center.
//    vec3 v1 = getContext()->getCamera()->getFrustum()->PointAt(FrustumPoint::fpt_nbl);
//    vec3 v2 = getContext()->getCamera()->getFrustum()->PointAt(FrustumPoint::fpt_ntr);
//
//    vec3 vc = v1 + (v2 - v1)*0.5f;
//
//    return vc;
//}
//vec3 World25::getRaycastViewCenter() {
//    //View as projected from the frustum.
//
//    vec3 av1 = FST_PT(FrustumPoint::fpt_nbl);
//    vec3 av2 = FST_PT(FrustumPoint::fpt_ntr);
//    vec3 ac = av1 + (av2 - av1) * 0.5f;
//
//    vec3 bv1 = FST_PT(FrustumPoint::fpt_fbl);
//    vec3 bv2 = FST_PT(FrustumPoint::fpt_ftr);
//    vec3 bc = bv1 + (bv2 - bv1) * 0.5f;
//
//    bool bh;
//    vec3 d1 = getWorld25Plane()->intersectLinePoint(ac, bc, &bh);
//
//    //We were getting some anomolies with the grid snap situation.
//    d1.x = round(d1.x, 4);
//    d1.y = round(d1.y, 4);
//    d1.z = round(d1.z, 4);
//
//    return d1;
//
//}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//Methods

//void Pt_quadratic(Vector3& s_p, const Vector3& s_v, const Vector3& a_2, float mt);
//void Pt_linear(Vector3& s_p, const Vector3& s_v, float mt);

//
//// - When two spheres collide, slide them against one another instead of reacting
//void sphere_slide_sphere(
//    const Vector3& s1_p,    // sphere postiion
//    Vector3& s1_v,            // sphere velocity
//    const Vector3& s1_n,    // [in] normal pointing towards center of sphere.
//    float s1_r,                // sphere radius
//    float s1_f,                // sphere friction
//
//    const Vector3& s2_p,    // sphere position
//    Vector3& s2_v,            // sphere vlocity
//    const Vector3& s2_n,    // [in] normal pointing towards center of sphere.
//    float s2_r,                // sphere radius
//    float s2_f                // sphere friction
//    );
//
//// - When two spheres collide, bounce them off of each other.
//void sphere_bounce_sphere(
//    const Vector3& s1_p, // [in] position of Sphere 1
//    Vector3& s1_v,            // [in/out] velocity
//    const Vector3& s1_n,    // [in] normal pointing towards center of sphere.
//    float s1_f,                // [in] friction [0,1]
//    float s1_e,                // [in] elasticity [0,1]
//
//    const Vector3& s2_p,    // position of Sphere 2...
//    Vector3& s2_v,
//    const Vector3& s2_n,
//    float s2_f,
//    float s2_e
//    );
//
//// + Slide a sphere along a plane.
//void sphere_slide_plane(
//    const Vector3& s_p,    // - Position
//    float s_m,            // - mass
//    float s_r,            // radius
//    Vector3& s_v,    // - [in] Velocity (modified)
//    const Vector3& s_v_n,    // - Normalized velocity.
//    float s_v_len,    // - Length of velocity
//    float ct,        // - Collision time
//    const Vector3& p_n,            // - Plane normal
//    float p_d,        // plane d
//    float p_f,        // - Plane friction    
//    float p_e        // - Plane elasticity
//    );
//void sphere_slide_plane_homo(
//    const Vector3& s_p,    // - Position
//    float s_m,            // - mass
//    float s_r,            // radius
//    Vector3& s_v,    // - [in] Velocity (modified)
//    const Vector3& s_v_n,    // - Normalized velocity.
//    float s_v_len,    // - Length of velocity
//    float ct,        // - Collision time
//    const Vector3& p_n,            // - Plane normal
//    float p_d,        // plane d
//    float p_f,        // - Plane friction    
//    float p_e        // - Plane elasticity
//    ,float nDot010
//    ,float tooSteep
//    );
//// + Bounce a sphere off of a plane
//void sphere_bounce_plane(
//    const Vector3& s_p,    // - Position
//    float s_m,        // - Sphere Mass
//    Vector3& s_v,    // - [in] Velocity (modified)
//    const Vector3& s_v_n,    // - Normalized velocity.
//    float s_v_len,    // - Length of velocity
//    float ct,        // - Collision time
//    const Vector3& p_n,            // - Plane normal
//    float p_d,        // - Plane d
//    float p_f,        // - Plane friction
//    float p_e        // - Plane Elasticity
//    );
//void sphere_slide_line(
//                        const Vector3& s_p,    // - Position
//                        float s_m,        // - Sphere Mass
//                        float s_r,        // - sphere Radius
//                        Vector3& s_v,    // - [in] Velocity (modified)
//                        const Vector3& s_v_n,    // - Normalized velocity.
//                        float s_v_len,    // - Length of velocity
//                        float ct,        // - Collision time
//                        float p_f,        // - Plane friction
//                        float p_e        // - Plane Elasticity
//                        );


// - Get the time t along a sphere's velocity where it collides with a plane.
// (the point where the sphere collides is s_p + s_v*out_t where t=[0,1])

// - Get the time t along a sphere's velocity where it colldies with a plane
//bool 
//    sphere_plane_collision_quadratic(
//    const Vector3& a_2, // accelleration / 2
//    const Vector3& s_p, // position of sphere
//    const Vector3& s_v, // velocity of sphere
//    float s_r, // radius of sphere
//    const Vector3& p_n, // normal of plane
//    float p_d,     // d value of plane
//    float& out_t
//    );
// - Returns the time that a sphere collides with a line segment.
//t_int 
//sphere_line_collision_linear(
//    const Vector3& s_p, // position of sphere
//    float s_r, // radius of sphere
//    const Vector3& p0,    // Line P0
//    const Vector3& p1,    // Line P1
//    float& out_t //[out] collision time
//    );
//t_int 
//swept_sphere_line_collision_linear(
//    const Vector3& s_p, // position of sphere
//    const Vector3& s_v, // velocity of sphere
//    float s_r, // radius of sphere
//    const Vector3& p0,    // Line P0
//    const Vector3& p1,    // Line P1
//    float& out_t //[out] collision time
//    );
// - Finds the closest collision which will be either a physics mesh OR a physics object.
// If it is the former then the physics object pointer will be zero.
// if it is the latter, then the physics mesh pointer will be zero.
/*int find_closeset_collision(
    PhysicsMesh*& pMesh, TRef<PhysicsPlane3>& pPlane, PhysicsObject*& pObj, 
    const PhysicsObject* pSphere,
    const Vector3& s_p, const Vector3& s_v, float s_r, 
    const Vector3& g_v, float& time);

*/
// OLD EQUATIONS (don't use)
// +---MOVEMENT ALGORITHMS----+
//Vector3 sphere_plane_contact(/*todo const*/ Vector3& s_p, // - Point of sphere
//    const Vector3& s_v,    // - [in/out] Velocity of sphere
//    const Vector3& s_v_n,    // normalized velocity. [in]
//    float s_r,            // - Radius of sphere    
//    const Plane3f& plane,    // plane
//    float& t);                // - [out]
//
//// +-----REACTION ALGORITHMS-----+
//void conserve_energy_1(const SurfaceProps& p, Vector3& s1_v, float s1_e, float s1_e_lost, float s1_m);
//void conserve_energy_2(const SurfaceProps& s1, 
//    Vector3& s1_v,    // IN/OUT
//    float s1_e,
//    float s1_e_lost,
//    float s1_m,
//    const SurfaceProps& s2, 
//    Vector3& s2_v,    // IN/OUT
//    float s2_e,
//    float s2_e_lost,
//    float s2_m
//    );
//float get_energy(Vector3& v_in);
//float get_energy_lost(const Vector3& v_in, float lost_percent);
//void do_bounce_plane(const Vector3& normal, Vector3& s_v);

/**
* EdgeCollide() and getLowestRoot()
*    Nicked from Kasper Fauberrys article
*    on collisison response.
*/
/**
*    Collide with a line in 3D.
*
*    returns true if a collision happened.
*/

//cp is the collision point, p1,p2,p3 is the triangle
//returns true if we collided

/**
*    Sphere Collision
*    Solves for time t when two spheres collide ( returns true or false )
*    This is my equation for spheres colliding given the basic physics equations and
*    a constraint.
*    Returns true if there was a collision
*    t - the collision time from [0,1]
*/

/*
*
*
*    Advanced Sphere collision ( very good) from gamedev.
*    Oleg Dopertchouk (2000)
*
*    @return 0 - No collision
*    1 - Collision
*    2 - Spheres are intersecting
*/
//t_int 
//adv_sphereCollide( 
//                  const Vector3& v1, const Vector3& p1,  t_float r1,
//                  const Vector3& v2, const Vector3& p2, t_float r2 );


/*
collide hull with aabb
should work.  this is the equation from the frustum box collision

**normals for hull planes point inwards.
*/
//FORCE_INLINE int hull_collide_box(
//                                Cube3f* pCube,
//                                Plane3f* pPlanes,
//                                t_int32 nPlanes
//                                )
//{
//    // AssertOrThrow2((bool)(pCube->max>=pCube->min));
//    bool ret = false; // Inside the frustum
//    Vec3f min,max;   
//    float d1, d2;
//
//   for(int i = 0; i < nPlanes; ++i) 
//   { 
//        min=pCube->min, max=pCube->max;    
//
//        //  - Calculate the negative and positive vertex
//        if(pPlanes[i].n.x < 0) 
//        { 
//            min.x = pCube->max.x; 
//            max.x = pCube->min.x; 
//        } 
//
//        if(pPlanes[i].n.y < 0) 
//        { 
//            min.y = pCube->max.y; 
//            max.y = pCube->min.y; 
//        } 
//
//        if(pPlanes[i].n.z < 0) 
//        { 
//            min.z = pCube->max.z; 
//            max.z = pCube->min.z; 
//        } 
//
//        d1 = pPlanes[i].dist(max);
//        d2 = pPlanes[i].dist(min);
//
//        if(d1< 0.0f && d2<0.0f) 
//            return false;
//   } 
//   return true;
//
//}

//STATIC void bounce_and_slide_sphere(
//     const vec3& s0_p        //position
//    ,const vec3& s0_o        //position
//    ,const vec3& s0_v        //velocity
//    ,const vec3& s0_v_n        //normalized velocit
//    ,const vec3& s0_a        //acceleration (gravity)
//    ,const vec3& s0_a_n
//    ,const vec3& s0_w        //angular velocity
//    ,const vec3& s0_w_n        //angular velocity
//    ,const float& s0_e    //elasticity [0,1]
//    ,const float& s0_f    //friction [0,1]
//    ,const float& s0_r    //rotation multiplier
//    ,const float& s0_m  //mass
//    ,const vec3& c_n        //collision normal (PLANE normal or -sphere velocity normal for sphere-sphere)
//    ,const float& v_t    //time to collision. must be moved away from other volume with epsilon (volumes must not be touching)
//    ,const float& a_t    //accel collision time
//    ,vec3& __out_ s0_dv        //output velocity
//    ,vec3& __out_ s0_da        //output accel
//    ,vec3& __out_ s0_dw        //output angular velocity
//);

//STATIC void orderObjectsForEquation(PhysicsVolume*& A, PhysicsVolume*& B);
//STATIC CollisionResult collisionTest_Sphere_Mesh(
//    SphericalVolume* s1, 
//    TriangleMeshVolume* m1, 
//    __inout_ VolumeManifold*& outDep
//    );
//STATIC CollisionResult collisionTest_Sphere_Sphere(
//    SphericalVolume* s1, 
//    SphericalVolume* s2, 
//    __inout_ VolumeManifold*& outDep
//    );
//STATIC CollisionResult collisionTest_Sphere_Triangle(
//    SphericalVolume* s1,
//    PhysicsPlane3* t1,
//    __inout_ VolumeManifold*& dep
//    );

//STATIC CollisionResult pointCollide( 
//      const vec3& s0_p
//    , const vec3& s0_v
//    , const float s0_r
//    , const vec3& tp
//    , float& __out_ cur_t
//);
//STATIC CollisionResult edgeCollide( 
//      const vec3& p1
//    , const vec3& p2
//    , const vec3& s0_p
//    , const vec3& s0_v
//    , const float s0_r
//    , float __out_ &t 
//);
//STATIC CollisionResult CollisionEquations::quadraticFormula( 
//      float a
//    , float b
//    , float c
//    , float cur_t
//    , float& __out_ new_t
//);
//STATIC CollisionResult sphere_collide_sphere( 
//      const vec3& v1
//    , const vec3& p1
//    , const float r1
//    , const vec3& v2
//    , const vec3& p2
//    , const float r2
//    , float& t 
//    , float& root_1
//    , float& root_2
//);
//STATIC CollisionResult sphere_tri_collision_linear(
//      const Vector3& s_p // position of sphere
//    , const Vector3& s_v // velocity of sphere
//    , const float s_r // radius of sphere
//    , const PhysicsPlane3* pp3
//    , float& out_t //[out] collision time
//    , ConvexPart& out_type // type of hit - 0=plane 1=edge 2=vertex
//    );
//STATIC CollisionResult sphere_plane_collision_linear(
//    const Vector3& s_p, // position of sphere
//    const Vector3& s_v, // velocity of sphere
//    float s_r, // radius of sphere
//    const Vector3& p_n, // normal of plane
//    float p_d,     // d value of plane
//    float& out_t //[out] collision time
//    );


//FORCE_INLINE STATIC bool lineCol2D( const Vec2f& p1, const Vec2f& p2, const Vec2f& p3, const Vec2f& p4 ) 
//{
//    t_float d =  (p4.y-p3.y)*(p2.x-p1.x) - (p4.x-p3.x)*(p2.y-p1.y);//

//    t_float d1 = (p4.x-p3.x)*(p1.y-p3.y) - (p4.y-p3.y)*(p1.x-p3.x);
//    t_float d2 = (p2.x-p1.x)*(p1.y-p3.y) - (p2.y-p1.y)*(p1.x-p3.x);
//
//    // - Coincident
//    if( (d==0.0)&&(d1==0.0)&&(d2==0.0) ) 
//        return true;
//
//    t_float t0 = d1/d;
//    t_float t1 = d2/d;

//    // - Article said || but && works
//    if( (t0>=0.0&&t0<=1.0)&&(t1>=0.0&&t1<=1.0) )
//        return true;
//
//    return false;
//}
//FORCE_INLINE STATIC bool lineCol2D( const Vec2f& p1, const Vec2f& p2, const Vec2f& p3, const Vec2f& p4, Vec2f& out ) 
//{
//    t_float d =  (p4.y-p3.y)*(p2.x-p1.x) - (p4.x-p3.x)*(p2.y-p1.y);//

//    t_float d1 = (p4.x-p3.x)*(p1.y-p3.y) - (p4.y-p3.y)*(p1.x-p3.x);
//    t_float d2 = (p2.x-p1.x)*(p1.y-p3.y) - (p2.y-p1.y)*(p1.x-p3.x);
//
//    // - Coincident
//    if( (d==0.0)&&(d1==0.0)&&(d2==0.0) ) 
//        return true;
//
//    t_float t0 = d1/d;
//    t_float t1 = d2/d;

//    // - Article said || but && works
//    if( (t0>=0.0&&t0<=1.0)&&(t1>=0.0&&t1<=1.0) )
//    {
//        out = ( p2-p1 )*t0;
//        return true;
//    }        
//    return false;
//}


    //static CollisionResult::e CollisionEquations::sat_axis_t(
    //    const float& v1
    //    , const float& p1
    //    , const float r1
    //    , const float& v2
    //    , const float& p2
    //    , const float r2
    //    , float& __out_ t
    //    , float& __out_ root_1
    //    , float& __out_ root_2
    //);
    //static bool CollisionEquations::sat_axis_t2(const float& c0, const float& c1,
    //    const float& r0, const float& r1, const float& v0, const float& v1,
    //    float& __out_ t_out, float& __out_ t0_out, float& __out_ t1_out);



	//CollisionResult::e CollisionEquations::sat_axis_t(
//    const float& v1
//    , const float& p1
//    , const float r1
//    , const float& v2
//    , const float& p2
//    , const float r2
//    , float& __out_ t
//    , float& __out_ root_1
//    , float& __out_ root_2
//)
//{
//    // - Check first to see if we collide at all ( kindof an optimization )
//    float dp = p2 - p1;
//    float dv = v2 - v1;
//
//    float r = r1 + r2;
//    float pp = dp * dp;
//    float rr = r*r;
//    float c = pp - rr;
//
//    //spheres intersect eachother
// //   if (pp <= rr)
////    {
// //       t = fabsf(dp);    //Distance - for stuck
// //       return CollisionResult::e::Stuck;
////    }
//
//    float pv = dp * dv;
//
//    //spheres move away from eachother
//    //these do not apply tou our system.  they would work theoretically if the sphere vecotrs
//    // were not intersecting anything at presenta nd the spheres had a clear path, but they
//    //do not work if you have say a sphere that is not going to move along its vector because
//    //it already collides
//    //if(pv>=0) 
//    //    return CollisionResult::Avoided;
//    //
//    float vv = dv * dv;
//
//    //if ( (pv + vv) <= 0 && (vv + 2 * pv + c) >= 0 )
//    //    return CollisionResult::Avoided;
//
//    // - parameters for the quadratic formula
//    float a = vv;
//    float b = 2 * pv;
//
//    // b^2 -4ac  the quadratic formula discriminant ( we are solving for t )
//    float d = b*b - 4.0f*a*c;
//
//    if (d<0.0f)//imaginary
//        return CollisionResult::e::Avoided;
//
//    if (a == 0.0f)
//    {
//        if (pv == 0.0f)
//        {
//            //divisor is zero.  Return that we avoided the collision
//            //to avoid blowing up.
//            t = 1.0f;
//            return CollisionResult::e::Avoided;
//        }
//        //when a is zero we have a linear equation and can't do the quadratic equation.
//        // v^2t^2 + 2pv*t + p^2 - r^2 = 0
//        t = (rr - pp) / (2 * pv);
//        if (t >= 0.0f && t <= 1.0f)
//            return CollisionResult::e::Collided;
//        else
//            return CollisionResult::e::Avoided;
//    }
//
//    float sqrtD = MathUtils::broSqrt(d);
//
//    root_1 = (-b + sqrtD) / (2 * a);
//    root_2 = (-b - sqrtD) / (2 * a);
//
//    //make root1 smaller than root 2
//    if (root_1>root_2)
//    {
//        float temp = root_2;
//        root_2 = root_1;
//        root_1 = temp;
//    }
//
//    if (root_1 >= 0.0f && root_1 <= 1.0f)
//    {
//        t = root_1;
//        return CollisionResult::e::Collided;
//    }
//    if (root_2 >= 0.0f && root_2 <= 1.0f)
//    {
//        t = root_2;
//        return CollisionResult::e::Collided;
//    }
//
//    return CollisionResult::e::Avoided;
//}
//bool CollisionEquations::sat_axis_t2(
//    const float& v0, const float& c0, const float& r0, 
//    const float& v1, const float& c1, const float& r1,
//    float& __out_ t_out, float& __out_ t0_out, float& __out_ t1_out) {
//    
//    //Original thing
//    //float t = (c2 - c1 + r1 + r2) / (v1 - v2);
//   // float checkme = (c1 - c0 + r0 + r1) / (v0 - v1);
//
//    float a = v0 * v0 + 2 * v0 * v1 + v1 * v1;
//    float b = 2 * c0 * v0 + 2 * c0 * v1 - 2 * c1 * v1 - 2 * c1 * v0;
//    float c = c0 * c0 + c1 * c1 - 2 * c1* c0 - r0 - r1;
//
//    float a2 = 2 * a;
//    if(a2==0) {
//        return false;
//    }
//
//    float b24ac = sqrtf( b*b - 4*a*c );
//    
//    t0_out = (-b + b24ac) / a2;
//    t1_out = (-b - b24ac) / a2;
//
//    if(t1_out < t0_out) {
//        float tmp = t1_out;
//        t1_out = t0_out;
//        t0_out = tmp;
//    }
//
//    return true;
//    //1-d interval collision at time t.  t is in range [0,1] if there was a collision.
//  //  
//}\
\
    /*
    if (f > 0) {
        //Empty blocks don't get topology
        geom = W25GEOM_EMPTY;
    }
    else {
        //Construct a kernel of the 26 surrounding blocks
        //In retrospect if the corners work we only need 4 values here...
        //So it woudl be an easy optimization to remove the kernel.
        float kernel[27];
        int kInd = 0;
        int kx, ky, kz;

        for (int zz = -1; zz <= 1; zz++) {
        for (int yy = -1; yy <= 1; yy++) {
        for (int xx = -1; xx <= 1; xx++) {
            kx = c_ix + xx;
            ky = c_iy + yy;
            kz = c_iz + zz;
            kernel[kInd++] = getOrGenPoint(g_ix, g_iy, g_iz, kx, ky, kz);
        }
        }
        }

        // if neighbors surrounding block vertex are presennt, then that vertex is "on" (solid) otherwise it's "off"
        //The C8 minor vertex seems  to work correctly.
        // Cubes are in the C27 with LHS coordinates
        // Verts are in the V8 with LHS coordinates.
        //https://www.evl.uic.edu/ralph/508S98/coordinates.html
        //3 cubes surrounding the edge ANDed, then ORed
        W25Geom wg[8];
        //2,3,6,7 should be off if there is no block above
        //NOTE: this is correct.  In the MeshMaker is where we add top/bottom quads.  a 255, or 0 for a full or no
        //block is correct.  Make sure it has a base tile.
        wg[0] = W25MeshMaker::confBit3(0, 12,  3,  4, kernel);  //v0
        wg[1] = W25MeshMaker::confBit3(1, 14,  5,  4, kernel);  //v1
        wg[2] = W25MeshMaker::confBit3(2, 12,  3,  4, kernel);  //v2
        wg[3] = W25MeshMaker::confBit3(3, 14,  5,  4, kernel);  //v3
        wg[4] = W25MeshMaker::confBit3(4, 22, 21, 12, kernel);  //v4
        wg[5] = W25MeshMaker::confBit3(5, 22, 23, 14, kernel);  //v5
        wg[6] = W25MeshMaker::confBit3(6, 22, 21, 12, kernel);  //v6
        wg[7] = W25MeshMaker::confBit3(7, 22, 23, 14, kernel);  //v7

        // wg[0] = W25MeshMaker::confBit9(0,     9,  0,  1,    12,  3,  4,    15,  6,  7, kernel);  //v0
        // wg[2] = W25MeshMaker::confBit9(2,     9,  0,  1,    12,  3,  4,    15,  6,  7, kernel);  //v2
        //                                                                   
        // wg[1] = W25MeshMaker::confBit9(1,    11,  2,  1,    14,  5,  4,    17,  8,  7, kernel);  //v1
        // wg[3] = W25MeshMaker::confBit9(3,    11,  2,  1,    14,  5,  4,    17,  8,  7, kernel);  //v3
        //                                                                   
        // wg[4] = W25MeshMaker::confBit9(4,     9, 18, 19,    12, 21, 22,    15, 24, 25, kernel);  //v4
        // wg[6] = W25MeshMaker::confBit9(6,     9, 18, 19,    12, 21, 22,    15, 24, 25, kernel);  //v6
        //                                                                   
        // wg[5] = W25MeshMaker::confBit9(5,    11, 20, 19,    14, 23, 22,    17, 26, 25, kernel);  //v5
        // wg[7] = W25MeshMaker::confBit9(7,    11, 20, 19,    14, 23, 22,    17, 26, 25, kernel);  //v7


        //  wg[0] = W25MeshMaker::confBit6m(0,     9,  0,  1,    12,  3,  4,     kernel);  //v0
        //  wg[2] = W25MeshMaker::confBit6m(2,     12,  3,  4,    15,  6,  7, kernel);  //v2
        //
        //  wg[1] = W25MeshMaker::confBit6m(1,    11,  2,  1,    14,  5,  4,     kernel);  //v1
        //  wg[3] = W25MeshMaker::confBit6m(3,     14,  5,  4,    17,  8,  7, kernel);  //v3
        //
        //  wg[4] = W25MeshMaker::confBit6m(4,     9, 18, 19,    12, 21, 22,    kernel);  //v4
        //  wg[6] = W25MeshMaker::confBit6m(6,        12, 21, 22,    15, 24, 25, kernel);  //v6
        //
        //  wg[5] = W25MeshMaker::confBit6m(5,    11, 20, 19,    14, 23, 22,    kernel);  //v5
        //  wg[7] = W25MeshMaker::confBit6m(7,        14, 23, 22,    17, 26, 25, kernel);  //v7

        geom=0;
        for (int i = 0; i < 8; ++i) { geom |= wg[i]; }

        if (geom != W25GEOM_EMPTY) {
            if (geom != W25GEOM_SOLID) {
                int n = 0;
                n++;
            }
        }
    }*/
    //}


	//World25Grid* World25::getFirstVisibleNode() {
// **THIS IS TOO SLOW
//    //Gets the first non-null visible node in the awareness box.
//  //  Box3f c;
//    ivec3 p0, p1;
//    std::shared_ptr<FrustumBase> frust = _pContext->getCamera()->getFrustum();
//  //  getAwarenessBox(*);
//    getNodeRangeForBox(frust->getBoundBoxObject(), &p0, &p1);
//
//    int yi = CongaUtils::getNodesYMin();
//    int ya = CongaUtils::getNodesYMax();
//
//    std::vector<World25Grid*> vecGen;
//    int dbgn = 0;
//    int dbgp = 0;
//    int dbg_nGrids = abs(p1.x - p0.x + 1) * abs(p1.z - p0.z + 1);
//    for (t_int32 k = p0.z; k <= p1.z; ++k) {
//    for (t_int32 j = yi; j <= ya; ++j) {
//    for (t_int32 i = p0.x; i <= p1.x; ++i) {
//        ivec3 cv(i, j, k);
//        World25Grid* pg = getNodeAtPos(cv);
//        if(pg!=nullptr && frust->hasAABB(pg->getBoundBox())) {
//            return pg;
//        }
//    }
//    }
//    }
//
//    return nullptr;
//}


//void World25Grid::setNeighbor(WorldCell* curQuad, int iCellx, int iCelly, int iCellz, World25Side::e eNeighbor, bool bUnlink) {
//    int xx, yy, zz;
//    WorldCell* neighbor;
//    ivec3 vpNeighbor;
//    World25Side::e opp;
//
//    if (eNeighbor == World25Side::e::gL)      { xx = -1; yy =  0; zz =  0; }
//    else if (eNeighbor == World25Side::e::gR) { xx =  1; yy =  0; zz =  0; }
//    else if (eNeighbor == World25Side::e::gB) { xx =  0; yy = -1; zz =  0; }
//    else if (eNeighbor == World25Side::e::gT) { xx =  0; yy =  1; zz =  0; }
//    else if (eNeighbor == World25Side::e::gA) { xx =  0; yy =  0; zz = -1; }
//    else if (eNeighbor == World25Side::e::gF) { xx =  0; yy =  0; zz =  1; }
//
//    opp = CongaUtils::getOppNeighborIndex(eNeighbor);
//
//    vpNeighbor.construct(iCellx + xx, iCelly + yy, iCellz + zz);
//
//    //This should be uncommented for optimization but for debug we're testing to see if all the neighbors match up
//    //if (curQuad->getNeighbor(eNeighbor) == nullptr) {
//    if (vpNeighbor.x < 0 || vpNeighbor.x >= CongaUtils::getNumCellsWidth() ||
//        vpNeighbor.y < 0 || vpNeighbor.y >= CongaUtils::getNumCellsHeight() ||
//        vpNeighbor.z < 0 || vpNeighbor.z >= CongaUtils::getNumCellsWidth()
//        ) {
//        //Neighbor grid.
//
//        //I'm not confident with this.
//        vec3 off = vec3(
//              (float)xx * CongaUtils::getCellWidth() * 0.5f
//            , (float)yy * CongaUtils::getCellHeight() * 0.5f
//            , (float)zz * CongaUtils::getCellWidth() * 0.5f
//        );
//        vec3 vp = curQuad->getPosR3() + off;
//
//        neighbor = _pWorld25->getGlobalCellForPoint(vp);
//    }
//    else {
//        neighbor = getCellForIndex(vpNeighbor);
//    }
//
//    //DEBUG
//    if (curQuad->getNeighbor(eNeighbor) != nullptr) {
//        if (curQuad->getNeighbor(eNeighbor) != neighbor) {
//            //Different results for neighbor linkage.
//            Gu::debugBreak();
//        }
//    }
//
//    //Dually link/unlink neighbors
//    if (bUnlink == false) {
//        //Link them
//        curQuad->setNeighbor(eNeighbor, neighbor);
//        if (neighbor != nullptr) {
//            neighbor->setNeighbor(opp, curQuad);
//        }
//    }
//    else {
//        //Unlink
//        if (neighbor != nullptr) {
//            neighbor->setNeighbor(opp, nullptr);
//        }
//    }
//    //}
//}

/*
//New link information.
void World25Grid::linkChildren()
{
    // - Linking 12 blocks with just Top, Right, Front will
    // inversely link all 12 Bottom, Left, Back.
    // **This is the same as VolumeLinkPhase1() but with Blocks instead of vols.
    linkBlocks(_pChildren[0], _pChildren[2], CELL_NRP3_TOP);
    linkBlocks(_pChildren[0], _pChildren[1], CELL_NRP3_LEFT);
    linkBlocks(_pChildren[0], _pChildren[4], CELL_NRP3_FRONT);
    linkBlocks(_pChildren[1], _pChildren[5], CELL_NRP3_FRONT);
    linkBlocks(_pChildren[1], _pChildren[3], CELL_NRP3_TOP);
    linkBlocks(_pChildren[2], _pChildren[3], CELL_NRP3_LEFT);
    linkBlocks(_pChildren[2], _pChildren[6], CELL_NRP3_FRONT);
    linkBlocks(_pChildren[3], _pChildren[7], CELL_NRP3_FRONT);
    linkBlocks(_pChildren[4], _pChildren[5], CELL_NRP3_LEFT);
    linkBlocks(_pChildren[4], _pChildren[6], CELL_NRP3_TOP);
    linkBlocks(_pChildren[5], _pChildren[7], CELL_NRP3_TOP);
    linkBlocks(_pChildren[6], _pChildren[7], CELL_NRP3_LEFT);
}
*/
//void World25Grid::expandV(Gn2* parent) {
//    if (parent->getBox()->getHeight() <= CongaUtils::getCellHeight() + 0.00000005f) {
//        expandH(parent);
//    }
//    else {
//        float h2 = parent->getBox()->_min.y + (parent->getBox()->_max.y - parent->getBox()->_min.y) * 0.5f;
//        Gn2* c1, *c2;
//
//        if(parent->getChildren() == nullptr) {
//            parent->makeChildrenV();
//        }
//
//        _pRoot->setNodeType(NodeType::e::Vertical);
//
//        if(parent->getChildren()->at(0) == nullptr) {
//            c1 = new Gn2();
//            c1->getBox()->construct(*parent->getBox());
//            c1->getBox()->_max.y = h2;
//            _nNodes++;
//            parent->getChildren()->at(0) = c1;
//            expandV(c1);
//        }
//
//        if (parent->getChildren()->at(1) == nullptr) {
//            c2 = new Gn2();
//            c2->getBox()->construct(*parent->getBox());
//            c2->getBox()->_min.y = h2;
//            _nNodes++;
//            parent->getChildren()->at(1) = c2;
//            expandV(c2);
//        }
//    }
//}
//void World25Grid::expandOctree(BlockNode* parent) {
//    //Split a horizontal sefction
//    if (parent->getBox()->getWidth() <= CongaUtils::getCellWidth()) {
//        parent->setIsLeaf();
//    }
//    else {
//        vec3 pc = parent->getBox()->_min + (parent->getBox()->_max - parent->getBox()->_min) * 0.5f;
//        //float wz2 = parent->getBox()->_min.z + (parent->getBox()->_max.z - parent->getBox()->_min.z) * 0.5f;
//        /* 6   7
//           4   5
//        2  3  y
//        0  1  ^  z
//              | / 
//               -->x  
//        */
//        //20170502 Conditionally make the children now when we "expand" the grid.
//        if(parent->getChildren() == nullptr) {
//            parent->makeChildren();
//        }
//
//        _nNodes += 8;
//
//        for (int z = 0; z<2; ++z) {
//        for (int y = 0; y<2; ++y) {
//        for (int x = 0; x<2; ++x) {
//            // - Offset in the C8
//            unsigned int off = (unsigned int)((unsigned char)(x << 0) | (unsigned char)(y << 1) | (unsigned char)(z << 2));
//            if (_pChildren[off] != NULL)
//                _pChildren[off]->divide(startTime, _pMyGlob, treeLevel + 1, pGenerator, ptPointToDivideTo, ptFoundNode);
//        }
//        }
//        }
//
//    }
//}


//void ShaderMaker::destroyShader(std::shared_ptr<ShaderBase> shader)
//{
//    if (shader == NULL)
//        return;
//    _vecShaders.remove(shader);
//    //delete shader;
//}

//IGpuDevice* ShaderMaker::getGpu()
//{
//    return _pHardwareManager->getPrimaryGpuDevice();
//}
//IGpuDevice* ShaderMaker::getGpuDevice()
//{
//    return _pHardwareManager->getPrimaryGpuDevice();
//}
//void ShaderMaker::deleteProgram(ShaderProgram* prog)
//{
//    removeProgram(prog);
//    delete prog;
//}
//std::shared_ptr<ShaderBase> ShaderMaker::getDefaultVertexOnlyShader()
//{
//    if (_pDefaultVertexOnlyShader == NULL)
//    {
//        BroLogInfo("Compiling Vertex Only Shader.");
//        AssertOrThrow2(_pRenderSystem != NULL);
//
//        std::vector<t_string> files;
//
//        files.add("d_v3_vertexonlyshader_01.vs");
//        files.add("d_v3_vertexonlyshader_01.ps");
//
//        _pDefaultVertexOnlyShader =
//            createShader(&files,
//                VertexFormatType::V_V3C4);
//    }
//    return _pDefaultVertexOnlyShader;
//}
//std::shared_ptr<ShaderBase> ShaderMaker::getDefaultFlatShader()
//{
//    if (_pDefaultFlatShader == NULL)
//    {
//        BroLogInfo("Compiling Flat Shader.");
//        AssertOrThrow2(_pRenderSystem != NULL);
//
//        std::vector<t_string> files;
//
//        files.add("d_v3c4_flatshader_01.vs");
//        files.add("d_v3c4_flatshader_01.ps");
//
//        _pDefaultFlatShader =
//            createShader(&files,
//                VertexFormatType::V_V3C4);
//    }
//    return _pDefaultFlatShader;
//}
//TRef(ShaderSpec) ShaderMaker::getDefaultModelBumpShader()
//{
//    if (_pDefaultModelBumpShader == NULL)
//    {
//        BroLogInfo("Compiling Bump Shader.");
//        std::vector<t_string> files;
//
//        files.add("d_v3c4n3x2_modelshr_bump_01.vs");
//        files.add("d_v3c4n3x2_modelshr_bump_01.ps");
//
//        _pDefaultModelBumpShader = createShader(
//            &files,
//            VertexFormatType::V_V3C4N3X2
//        );
//
//    }
//    return _pDefaultModelBumpShader.safeCast<ShaderSpec>();
//}
//TRef(ShaderSpec) ShaderMaker::getDefaultModelDiffuseShader()
//{
//    if (_pDefaultModelDiffuseShader == NULL)
//    {
//        BroLogInfo("Compiling Nobump Shader.");
//        std::vector<t_string> files;
//
//        files.add("d_v3c4n3x2_modelshr_nobump_01.vs");
//        files.add("d_v3c4n3x2_modelshr_nobump_01.ps");
//
//        _pDefaultModelDiffuseShader = createShader(
//            &files,
//            VertexFormatType::V_V3C4N3X2
//        );
//
//    }
//    return _pDefaultModelDiffuseShader.safeCast<ShaderSpec>();
//}
//TRef(ShaderSpec) ShaderMaker::getDefaultAnimationComputeShader()
//{
//    if (_pDefaultAnimationComputeShader == NULL)
//    {
//        BroLogInfo("Compiling Animation Shader.");
//        _pDefaultAnimationComputeShader = new GlslAnimationComputeShader01(this, _pGlRenderSystem);
//        _pDefaultAnimationComputeShader->suppressUniformParsing();
//        _pDefaultAnimationComputeShader->init();
//    }
//    return _pDefaultAnimationComputeShader.safeCast<ShaderSpec>();
//}
//TRef(ShaderSpec) ShaderMaker::getDefaultPickShader()
//{
//    if (_pDefaultPickShader == NULL)
//    {
//        BroLogInfo("Compiling Pick Shader.");
//        AssertOrThrow2(_pRenderSystem != NULL);
//
//        std::vector<t_string> files;
//        files.add("v3x2_pickshader_01.vs");
//        files.add("v3x2_pickshader_01.ps");
//
//        _pDefaultPickShader =
//            createShader(&files,
//                VertexFormatType::V_V3C4X2);
//    }
//    return _pDefaultPickShader.safeCast<ShaderSpec>();
//}
//std::shared_ptr<ShaderBase> ShaderMaker::getDefaultShadowShader()
//{
//    if (_pDefaultShadowShader == NULL)
//    {
//        BroLogInfo("Compiling Shadow Shader.");
//        AssertOrThrow2(_pRenderSystem != NULL);
//
//        std::vector<t_string> files;
//        files.add("v3_shadow_cube.vs");
//        files.add("v3_shadow_cube.ps");
//
//        _pDefaultShadowShader =
//            createShader(&files,
//                VertexFormatType::V_V3C4X2);
//    }
//    return _pDefaultShadowShader;
//}
//std::shared_ptr<ShaderBase> ShaderMaker::getDefaultShadowBlendShader()
//{
//    //We create this manually   
//    return NULL;
//}
//std::shared_ptr<ShaderBase> ShaderMaker::getDefaultBloomBlurShader()
//{
//    if (_pDefaultBloomBlurShader == NULL)
//    {
//        BroLogInfo("Compiling Bloom Blur.");
//        AssertOrThrow2(_pRenderSystem != NULL);
//
//        std::vector<t_string> files;
//        files.add("v2x2_bloom_blur.vs");
//        files.add("v2x2_bloom_blur.ps");
//
//        _pDefaultBloomBlurShader =
//            createShader(&files,
//                VertexFormatType::V_V3X2);
//    }
//    return _pDefaultBloomBlurShader;
//}
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
/**
*    @param type [optional] The type of shader which will default to the extension of the file (vs for vertex shader) (ps or fs for fragment shader)
*/
//std::shared_ptr<ShaderSubProgram> ShaderMaker::createShaderSubProgram(DiskLoc loc, ShaderType::e type) {
//    std::shared_ptr<ShaderSubProgram> pShaderSub = NULL;
//    GLuint iShaderId;
//    GLenum eShaderType;
//    ShaderType::e shaderType;
//    pShaderSub = new ShaderSubProgram(shaderType);
//
//    //_pContext->chkErrRt();
//
//    ////Parse shader by file ext
//    //if (type == ShaderType::e::st_use_extension) {
//    //    shaderType = getShaderTypeByFileLocation(loc);
//    //}
//    //else {
//    //    shaderType = type;
//    //}
//    //eShaderType = getGLShaderEnum(shaderType);
//
//    ////Create shader.
//    //iShaderId = _pContext->glCreateShader(eShaderType);
//    //GLenum er = glGetError();
//    //if (er != GL_NO_ERROR)
//    //{
//    //    BroThrowException("Failed to create shader of type ",
//    //        StringUtil::toHex((int)eShaderType, true), ". GL error: ", StringUtil::toHex(er, true));
//
//    //    if (pShaderSub){
//    //        pShaderSub->setLoadStatus(ShaderLoadStatus::e::shader_create_failed);
//    //    }
//    //}
//    //pShaderSub->setSourceLocation(loc);
//    //pShaderSub->setLoadStatus(ShaderLoadStatus::e::shader_create_complete);
//
//
//    //Store subprograms in order to cache the fact that we've loaded them before
//   // _mapSubPrograms.insert(KeyVal(sprog, sprog));
//
//    return (std::shared_ptr<ShaderSubProgram>)pShaderSub;
//}

//   BroLogInfo("Compiling main shaders...");
//Initially get all defaults so we can isolate shader errors.
//    getDefaultFlatShader();
//getDefaultModelShader();
//getDefaultAnimationComputeShader();
//getDefaultVertexOnlyShader();
//getDefaultPickShader();
//getDefaultModelBumpShader();
//getDefaultModelDiffuseShader();
//getDefaultShadowBlendShader();
//getDefaultBloomBlurShader();
//   BroLogInfo("...done");
//std::shared_ptr<ShaderBase> ShaderMaker::createShader(std::vector<t_string>& sourceFileList)
//{
//    //_pShaderManager->createShaderSubProgram(
//    std::shared_ptr<ShaderBase> shader;
//
//  //  AssertOrThrow2(_pGlRenderSystem != NULL);
//
//    //    this,
//    //    _pGlRenderSystem,
//    //    vertexFormat
//    //);
//
//
//    //for (size_t iAttr = 0; iAttr < attribList->count(); ++iAttr)
//    //    shader->addAttr(attribList->at(iAttr));
//
//    //just v and t are used to render a screen quad.
//
//
//  //  _vecShaders.add(shader);
//
//    return shader;
//}


/**
*    @fn
*    @brief After pulling out the uniform from the shader parse it to match it up with the system
*    named types. and get the index, etc from the name.
*/
//void ShaderBase::parseUniform(GLShaderProgram* pShaderProgram, GlslUniformVariable* pUniformVariable)
//{
//    parseSystemUniformName(pUniformVariable->_name, pUniformVariable->_iSystemIndex);
//
//    // - Now parse and check the system type.
//    pUniformVariable->_sSystemName = ShaderSystemStaticData::getSystemVariableTypeForName(pUniformVariable->_name);
//    pUniformVariable->_type = openglTypeToSystemType(pUniformVariable->_glType);
//
//    createAndAddUniformBySystemType(pUniformVariable);
//
//    pUniformVariable->validate();
//}
//void ShaderBase::load(std::string vtx, std::string frag) {
//    _uiGlId = loadShaders(vtx.c_str(), frag.c_str());
//    bind();
//    loadUniforms();
//}
//void ShaderBase::loadAndCheckUniform(const char* uniformName, GLint& __out_ glUniformId) {
//    glUniformId = _pContext->glGetUniformLocation(_uiGlId, uniformName);
//    if (glUniformId == -1) {
//        BroLogWarn("Shader: Could not find uniform ", uniformName);
//        Gu::debugBreak();
//    }
//    _pContext->chkErrDbg();
//}
//GLuint ShaderBase::loadShaders(const char * vertex_file_path, const char * fragment_file_path) {
//    std::shared_ptr<GLContext> ctx = _pContext;//lazy
//    _pContext->chkErrRt();
//
//    //http://www.opengl-tutorial.org/beginners-tutorials/tutorial-2-the-first-triangle/
//
//    // Create the shaders
//    GLuint VertexShaderID = ctx->glCreateShader(GL_VERTEX_SHADER);
//    GLuint FragmentShaderID = ctx->glCreateShader(GL_FRAGMENT_SHADER);
//    uint32_t out_size;
//    char* vertex;
//    char* fragment;
//    if(!Gu::SDLFileExists(vertex_file_path)) {
//        BroLogError("Vertex file ", vertex_file_path, " did not exist.");
//        Gu::debugBreak();
//        return 0;
//    }
//    if (!Gu::SDLFileExists(fragment_file_path)) {
//        BroLogError("Frag file ", fragment_file_path, " did not exist.");
//        Gu::debugBreak();
//        return 0;
//    }
//
//    Gu::SDLFileRead(vertex_file_path, vertex, out_size);
//    Gu::SDLFileRead(fragment_file_path, fragment, out_size);
//
//    if (vertex == nullptr || fragment == nullptr) {
//        //        Game::Utils::debugBreak();
//        return 0;
//    }
//    std::string VertexShaderCode = std::string((char*)vertex);
//    std::string FragmentShaderCode = std::string((char*)fragment);
//
//    Gu::SDLFileFree(vertex);
//    Gu::SDLFileFree(fragment);
//
//    GLint iVsResult, iPsResult, iLinkResult;
//    int InfoLogLength;
//    bool error = false;
//
//    // Compile Vertex Shader
//    BroLogInfo("Compiling VS ", vertex_file_path);
//    char const * VertexSourcePointer = VertexShaderCode.c_str();
//    ctx->glShaderSource(VertexShaderID, 1, &VertexSourcePointer, NULL);
//    ctx->glCompileShader(VertexShaderID);
//    _pContext->chkErrRt();
//
//    // Check Vertex Shader
//    ctx->glGetShaderiv(VertexShaderID, GL_COMPILE_STATUS, &iVsResult);
//    ctx->glGetShaderiv(VertexShaderID, GL_INFO_LOG_LENGTH, &InfoLogLength);
//    if (InfoLogLength > 0) {
//        std::vector<char> VertexShaderErrorMessage(InfoLogLength + 1);
//        ctx->glGetShaderInfoLog(VertexShaderID, InfoLogLength, NULL, &VertexShaderErrorMessage[0]);
//        BroLogInfo(&VertexShaderErrorMessage[0]);
//    }
//
//    // Compile Fragment Shader
//    BroLogInfo("Compiling PS ", fragment_file_path);
//    char const * FragmentSourcePointer = FragmentShaderCode.c_str();
//    ctx->glShaderSource(FragmentShaderID, 1, &FragmentSourcePointer, NULL);
//    ctx->glCompileShader(FragmentShaderID);
//    _pContext->chkErrRt();
//
//    // Check Fragment Shader
//    ctx->glGetShaderiv(FragmentShaderID, GL_COMPILE_STATUS, &iPsResult);
//    ctx->glGetShaderiv(FragmentShaderID, GL_INFO_LOG_LENGTH, &InfoLogLength);
//    if (InfoLogLength > 0) {
//        std::vector<char> FragmentShaderErrorMessage(InfoLogLength + 1);
//        ctx->glGetShaderInfoLog(FragmentShaderID, InfoLogLength, NULL, &FragmentShaderErrorMessage[0]);
//        BroLogInfo(&FragmentShaderErrorMessage[0]);
//    }
//
//    // Link the program
//    BroLogInfo("Linking program..");
//    GLuint ProgramID = ctx->glCreateProgram();
//    ctx->glAttachShader(ProgramID, VertexShaderID);
//    ctx->glAttachShader(ProgramID, FragmentShaderID);
//    ctx->glLinkProgram(ProgramID);
//
//    // Check the program
//    ctx->glGetProgramiv(ProgramID, GL_LINK_STATUS, &iLinkResult);
//    ctx->glGetProgramiv(ProgramID, GL_INFO_LOG_LENGTH, &InfoLogLength);
//    if (InfoLogLength > 0) {
//        std::vector<char> ProgramErrorMessage(InfoLogLength + 1);
//        ctx->glGetProgramInfoLog(ProgramID, InfoLogLength, NULL, &ProgramErrorMessage[0]);
//        BroLogInfo(&ProgramErrorMessage[0]);
//    }
//
//
//    _pContext->chkErrRt();
//
//
//    ctx->glDetachShader(ProgramID, VertexShaderID);
//    ctx->glDetachShader(ProgramID, FragmentShaderID);
//
//    //For some reason it doesn't like that we're calling delete shader
//    //ctx->glDeleteShader(VertexShaderID);
//    //ctx->glDeleteShader(FragmentShaderID);
//
//    if (iVsResult == GL_FALSE || iPsResult == GL_FALSE || iLinkResult == GL_FALSE) {
//        Gu::debugBreak();
//        // return 0;
//    }
//
//    return ProgramID;
//}

//void ShaderBase::setLightUf(std::vector<GpuLight*>& lights) {
//    if (ufLightCount == -2) {
//        loadAndCheckUniform("_ufLightCount", ufLightCount);
//    }
//   
//    _iLightCount = 0;
//    for (size_t iLight = 0; iLight<lights.size() && iLight < c_iMaxLights; ++iLight, ++_iLightCount) {
//        _lights[iLight] = *lights[iLight];
//    }
//    _pContext->glUniform1iv(ufLightCount, 1, (GLint*)&_iLightCount);
//
//    int binding_index = 1;
//    if(_iLightUboId == -2){
//        _pContext->glGenBuffers(1, (GLuint*)&_iLightUboId);
//        _ufLightDataIndex = _pContext->glGetUniformBlockIndex(getGLId(), "LightSources");
//        _pContext->glBindBufferBase(GL_UNIFORM_BUFFER, binding_index, _iLightUboId);
//        _pContext->glUniformBlockBinding(getGLId(), _ufLightDataIndex, binding_index);
//    }
//    _pContext->glBindBuffer(GL_UNIFORM_BUFFER, _iLightUboId);
//    _pContext->glBufferData(GL_UNIFORM_BUFFER, _iLightCount * sizeof(GpuLight), (void*)_lights, GL_STATIC_DRAW);
//    _pContext->glBindBuffer(GL_UNIFORM_BUFFER, 0);
//
//    _pContext->glBindBufferBase(GL_UNIFORM_BUFFER, binding_index, _iLightUboId);
//    if(_ufLightDataIndex == -1) {
//        Gu::debugBreak();
//        return;
//    }
//
//
//    _pContext->chkErrDbg();
//}





#pragma region Debug Output
t_string RenderUtils::debugGetRenderState(t_bool bForceRun, t_bool bPrintToStdout)
{
    //This method is called in frames to drag down the debug arrow
    // and we skip it unless we force it to run.
    //Do not uncomment
    if(!bForceRun)
        return "";//Do not uncomment
    //Do not uncomment
    t_string strState = "";

    Gd::verifyRenderThread();//We must be in render thread

    strState.appendLine("===================================================================");
    strState.appendLine("  RENDERING SYSTEM STATE                                            ");
    strState.appendLine("===================================================================");

    GLint iBlend;
    glGetIntegerv(GL_BLEND, (GLint*)&iBlend);
    strState.appendLine(TStr(" Blending:", (iBlend?"ENABLED":"DISABLED")));

    GLint iCullFace;
    glGetIntegerv(GL_CULL_FACE, (GLint*)&iCullFace);
    strState.appendLine(TStr(" Culling:",(iCullFace?"ENABLED":"DISABLED")));

    GLint iDepthTest;
    glGetIntegerv(GL_DEPTH_TEST, (GLint*)&iDepthTest);
    strState.appendLine(TStr(" Depth Test:",(iDepthTest?"ENABLED":"DISABLED")));


        CheckGpuErrorsRtNoThrow();
    RenderUtils::debugGetLegacyViewAndMatrixStack(strState);
        CheckGpuErrorsRtNoThrow();
    RenderUtils::debugGetBufferState(strState);
        CheckGpuErrorsRtNoThrow();
    //RenderUtils::debugGetAttribState(); // This is redundant with vertexarraystate
    //    CheckGpuErrorsDbg();
    RenderUtils::debugGetTextureState(strState);
        CheckGpuErrorsRtNoThrow();
    RenderUtils::debugGetVertexArrayState(strState);
        CheckGpuErrorsRtNoThrow();
    RenderUtils::debugGetFramebufferAttachmentState(strState);
        CheckGpuErrorsRtNoThrow();

    if(bPrintToStdout)
        strState.printToConsole();

    return strState;
}
void RenderUtils::debugGetLegacyViewAndMatrixStack(t_string& strState)
{
    GLint iScissorBox[4];
    GLint iViewportBox[4];
    strState.appendLine("**Scissor and Legcay info**");
    //View Bounds (Legacy)
    glGetIntegerv(GL_SCISSOR_BOX, (GLint*)iScissorBox);
    glGetIntegerv(GL_VIEWPORT, (GLint*)iViewportBox);
    strState.appendLine(TStr("Scissor: " , iScissorBox[0] , ",", iScissorBox[1] , ",", iScissorBox[2] , ",", iScissorBox[3] ));
    strState.appendLine(TStr("Viewport: ", iViewportBox[0], ",", iViewportBox[1], ",", iViewportBox[2], ",", iViewportBox[3]));
    //TODO: legacy matrix array state.
        CheckGpuErrorsRtNoThrow();
}
void RenderUtils::debugGetBufferState(t_string& strState)
{
    strState.appendLine("**SHADER STATE**");

    GLint iBoundBuffer;
    GLint iCurrentProgram;
    GLint iElementArrayBufferBinding;
    GLint iSsboBinding;    //shader storage
    GLint iUniformBufferBinding;
    GLint iVertexArrayBinding;

    glGetIntegerv(GL_ARRAY_BUFFER_BINDING,&iBoundBuffer);
    glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING,&iElementArrayBufferBinding);
    glGetIntegerv(GL_SHADER_STORAGE_BUFFER_BINDING,&iSsboBinding);    
    glGetIntegerv(GL_UNIFORM_BUFFER_BINDING,&iUniformBufferBinding);
    glGetIntegerv(GL_VERTEX_ARRAY_BINDING,&iVertexArrayBinding);
    glGetIntegerv(GL_CURRENT_PROGRAM,&iCurrentProgram);
    CheckGpuErrorsRtNoThrow();

    strState.appendLine(TStr("Bound Vertex Array Buffer Id (VBO):" , iBoundBuffer));
    strState.appendLine(TStr("Bound Element Array Buffer Id (IBO):" , iElementArrayBufferBinding));
    strState.appendLine(TStr("Bound Shader Storage Buffer Id (SSBO):", iSsboBinding));
    strState.appendLine(TStr("Bound Uniform Buffer Object Id:" , iUniformBufferBinding));
    strState.appendLine(TStr("Bound Vertex Array Object Id:" , iVertexArrayBinding));
    strState.appendLine(TStr("Bound Shader Program Id:", iCurrentProgram));
    CheckGpuErrorsRtNoThrow();

    if(Gu::GetShaderManager() && SafeCast(Gu::GetShaderManager(), GLShaderManager*)->getShaderByGlProgramId(iCurrentProgram).isNotNull())
    {
        strState.appendLine(TStr("Bound Shader Program Name:" ,
            SafeCast(Gu::GetShaderManager(), GLShaderManager*)->getShaderByGlProgramId(iCurrentProgram)->getProgramName()));

        RenderUtils::debugPrintActiveUniforms(iCurrentProgram, strState);

    }
    else
    {
        strState.appendLine(TStr("**Failed to get active program."));
        strState.appendLine(TStr("** No Uniforms."));
    }
    

}
void RenderUtils::debugPrintActiveUniforms(int iGlProgramId, t_string& strState)
{
    GLint nUniforms;
    t_string uniformName;
    t_char name[256];
    GLint name_len = -1;
    GLint iArraySize = -1;
    GLenum uniformType = GL_ZERO;
    GLint nActiveUniformBlocks;
    GLint nMaxUniformLocations;
    GLint nMaxComponentsVert;
    GLint nMaxComponentsFrag;
    GLint nMaxComponentsComp;

    // - Get the number of uniforms
    glGetProgramiv(iGlProgramId, GL_ACTIVE_UNIFORMS, &nUniforms); 
    glGetProgramiv(iGlProgramId, GL_ACTIVE_UNIFORM_BLOCKS, (GLint*)&nActiveUniformBlocks);
    glGetIntegerv(GL_MAX_UNIFORM_LOCATIONS, (GLint*)&nMaxUniformLocations);
    glGetIntegerv(GL_MAX_VERTEX_UNIFORM_COMPONENTS, (GLint*)&nMaxComponentsVert);
    glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS, (GLint*)&nMaxComponentsFrag);
    glGetIntegerv(GL_MAX_COMPUTE_UNIFORM_COMPONENTS, (GLint*)&nMaxComponentsComp);
        CheckGpuErrorsDbg();

    strState.appendLine(TStr("Active Uniforms: ",nUniforms));
    strState.appendLine(TStr("Active Uniform Blocks: ",nActiveUniformBlocks));
    strState.appendLine(TStr("Max Uniform Locations: ",nMaxUniformLocations));
    strState.appendLine(TStr("Max Uniform Components Vertex: ",nMaxComponentsVert));
    strState.appendLine(TStr("Max Uniform Components Fragment: ",nMaxComponentsFrag));
    strState.appendLine(TStr("Max Uniform Components Compute: ",nMaxComponentsComp));
    
    strState.appendLine(TStr("*Active Uniform Data: "));

    //Get all uniform names and types into a list.
    for(t_int32 i=0; i<nUniforms; ++i)
    {
        //Get name an d type
        glGetActiveUniform(iGlProgramId, (GLuint)i, 256, &name_len, &iArraySize, &uniformType, (char*)name);
        name[name_len] = 0;
        uniformName = t_string(name);

        //get location
        GLint glLocation = glGetUniformLocation( (GLuint)iGlProgramId,  (GLchar*)uniformName.c_str() );

        strState.appendLine(TStr("--Name: ",uniformName));
        strState.appendLine(TStr("  Type: ",RenderUtils::openGlTypeToString(uniformType)));
        strState.appendLine(TStr("  Location: ",glLocation ));
        strState.appendLine(TStr("  Array Size: ", iArraySize));

        // Uniform Block Data.
        CheckGpuErrorsDbg();
                
        GLuint iCurrentBlockIdx;
        iCurrentBlockIdx=glGetUniformBlockIndex(iGlProgramId, uniformName.c_str());
        
        if(iCurrentBlockIdx!=GL_INVALID_INDEX)
        {
            int iBlockBinding;
            int iBlockDataSize;
            int iBlockNameLength;
            int iBlockActiveUniforms;
            int iBlockActiveUniformIndices;
        
            CheckGpuErrorsDbg();
            glGetActiveUniformBlockiv(iGlProgramId, iCurrentBlockIdx, GL_UNIFORM_BLOCK_BINDING                ,(GLint*)&iBlockBinding              );
            CheckGpuErrorsDbg();
            glGetActiveUniformBlockiv(iGlProgramId, iCurrentBlockIdx, GL_UNIFORM_BLOCK_DATA_SIZE              ,(GLint*)&iBlockDataSize             );
            CheckGpuErrorsDbg();
            glGetActiveUniformBlockiv(iGlProgramId, iCurrentBlockIdx, GL_UNIFORM_BLOCK_NAME_LENGTH            ,(GLint*)&iBlockNameLength            );
            CheckGpuErrorsDbg();
            glGetActiveUniformBlockiv(iGlProgramId, iCurrentBlockIdx, GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS        ,(GLint*)&iBlockActiveUniforms        );
            CheckGpuErrorsDbg();
            glGetActiveUniformBlockiv(iGlProgramId, iCurrentBlockIdx, GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES ,(GLint*)&iBlockActiveUniformIndices );
            CheckGpuErrorsDbg();

            strState.appendLine(TStr("  Block Index:",iCurrentBlockIdx));
            strState.appendLine(TStr("  Block Binding:",iBlockBinding));
            strState.appendLine(TStr("  Block Data Size:",iBlockDataSize));
            strState.appendLine(TStr("  Block Name Length:",iBlockNameLength));
            strState.appendLine(TStr("  Block Active Uniforms:",iBlockActiveUniforms));
            strState.appendLine(TStr("  Block Active Uniform Indices:",iBlockActiveUniformIndices));
        }
    }
}
t_string RenderUtils::openGlTypeToString(GLenum type)
{
    switch(type) {
        case GL_UNSIGNED_INT         : return TStr("GL_UNSIGNED_INT        "); break;
        case GL_UNSIGNED_INT_VEC2    : return TStr("GL_UNSIGNED_INT_VEC2 "); break;
        case GL_UNSIGNED_INT_VEC3    : return TStr("GL_UNSIGNED_INT_VEC3 "); break;
        case GL_UNSIGNED_INT_VEC4    : return TStr("GL_UNSIGNED_INT_VEC4 "); break;
        case GL_FLOAT                 : return TStr("GL_FLOAT                "); break;
        case GL_FLOAT_VEC2              : return TStr("GL_FLOAT_VEC2         "); break;
        case GL_FLOAT_VEC3              : return TStr("GL_FLOAT_VEC3         "); break;
        case GL_FLOAT_VEC4              : return TStr("GL_FLOAT_VEC4         "); break;
        case GL_INT                     : return TStr("GL_INT                "); break;
        case GL_INT_VEC2              : return TStr("GL_INT_VEC2             "); break;
        case GL_INT_VEC3              : return TStr("GL_INT_VEC3             "); break;
        case GL_INT_VEC4              : return TStr("GL_INT_VEC4             "); break;
        case GL_BOOL                  : return TStr("GL_BOOL                 "); break;
        case GL_BOOL_VEC2              : return TStr("GL_BOOL_VEC2         "); break;
        case GL_BOOL_VEC3              : return TStr("GL_BOOL_VEC3         "); break;
        case GL_BOOL_VEC4              : return TStr("GL_BOOL_VEC4         "); break;
        case GL_FLOAT_MAT2              : return TStr("GL_FLOAT_MAT2         "); break;
        case GL_FLOAT_MAT3              : return TStr("GL_FLOAT_MAT3         "); break;
        case GL_FLOAT_MAT4              : return TStr("GL_FLOAT_MAT4         "); break;
        case GL_SAMPLER_1D              : return TStr("GL_SAMPLER_1D         "); break;
        case GL_SAMPLER_2D              : return TStr("GL_SAMPLER_2D         "); break;
        case GL_SAMPLER_3D              : return TStr("GL_SAMPLER_3D         "); break;
        case GL_SAMPLER_CUBE          : return TStr("GL_SAMPLER_CUBE         "); break;
        case GL_SAMPLER_1D_SHADOW    : return TStr("GL_SAMPLER_1D_SHADOW "); break;
        case GL_SAMPLER_2D_SHADOW   : return TStr("GL_SAMPLER_2D_SHADOW "); break;
        case GL_2_BYTES                : return TStr("GL_2_BYTES            "); break;
        case GL_3_BYTES                : return TStr("GL_3_BYTES            "); break;
        case GL_4_BYTES                : return TStr("GL_4_BYTES            "); break;
        case GL_UNSIGNED_SHORT      : return TStr("GL_UNSIGNED_SHORT    "); break;
        case GL_SHORT                : return TStr("GL_SHORT                "); break;
        case GL_DOUBLE                : return TStr("GL_DOUBLE            "); break;
    }
    return TStr("Undefined ", (int)type);
}
void RenderUtils::debugGetAttribState(t_string& strState)
{
    //// - print bound attributes
    //int iMaxAttribs;
    //int iBoundAttrib;
    //glGetIntegerv(GL_MAX_VERTEX_ATTRIBS,&iMaxAttribs);
    //std::cout<<"Attribs: max count = "<<iMaxAttribs<<std::endl;
    //for(int xx=0; xx<iMaxAttribs; ++xx)
    //{
    //    glGetIntegerv(GL_VERTEX_ATTRIB_ARRAY0_NV+xx,&iBoundAttrib);
    //    std::cout<<"attrib "<<xx<<": "<<iBoundAttrib<<std::endl;
    //}
}
void RenderUtils::debugGetTextureState(t_string& strState)
{
    strState.appendLine(TStr("**TEXTURE STATE**"));
    GLint iActiveTexture;
    GLint iTextureBindingBuffer;
    GLint iTextureBinding;    //Texture ID
    GLint iMaxVertexTextureUnits;
    GLint iMaxTextureUnits;
    GLint iMaxCombinedTextureUnits;

    glGetIntegerv(GL_ACTIVE_TEXTURE,&iActiveTexture);//Texture ID    0x84C0 is TEXTURE0
    glGetIntegerv(GL_TEXTURE_BINDING_2D,&iTextureBinding);//Texture ID    
    glGetIntegerv(GL_TEXTURE_BINDING_BUFFER,&iTextureBindingBuffer);
    glGetIntegerv(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, &iMaxVertexTextureUnits);
    glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &iMaxTextureUnits);
    glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &iMaxCombinedTextureUnits);

    
    strState.appendLine(TStr("Active Texture ID: ", iTextureBinding));
    strState.appendLine(TStr("Active Texture Buffer ID: ", iTextureBindingBuffer));
    strState.appendLine(TStr("Current active texture = ",StringUtil::toHex(iActiveTexture, true)));
    strState.appendLine(TStr("Max Texture Units: = ",iMaxTextureUnits));
    strState.appendLine(TStr("Max Vertex Texture Units: = ",iMaxVertexTextureUnits));
    strState.appendLine(TStr("Max Combined Texture Units: = ",iMaxCombinedTextureUnits));
    strState.appendLine(TStr("Below are the bound textures Per Texture Channel:"));
    // - Get bound texture units.
    for(int i=0 ;i<iMaxVertexTextureUnits; ++i)
    {
        Gd::activeTexture(i);
        strState.appendLine(TStr("  Channel ",i));
        glGetIntegerv(GL_TEXTURE_BINDING_1D                    ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     1D: ",(int)iTextureBinding));
        glGetIntegerv(GL_TEXTURE_BINDING_1D_ARRAY              ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     1D_ARRAY: ",(int)iTextureBinding));
        glGetIntegerv(GL_TEXTURE_BINDING_2D                    ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     2D: ",(int)iTextureBinding));
        glGetIntegerv(GL_TEXTURE_BINDING_2D_ARRAY              ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     2D_ARRAY: ",(int)iTextureBinding));
        glGetIntegerv(GL_TEXTURE_BINDING_2D_MULTISAMPLE        ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     2D_MULTISAMPLE: ",(int)iTextureBinding));
        glGetIntegerv(GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY  ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     2D_MULTISAMPLE_ARRAY: ",(int)iTextureBinding));
        glGetIntegerv(GL_TEXTURE_BINDING_3D                    ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     3D: ",(int)iTextureBinding));
        glGetIntegerv(GL_TEXTURE_BINDING_BUFFER                ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     BUFFER: ",(int)iTextureBinding));
        glGetIntegerv(GL_TEXTURE_BINDING_CUBE_MAP              ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     CUBE_MAP: ",(int)iTextureBinding));
        glGetIntegerv(GL_TEXTURE_BINDING_RECTANGLE             ,&iTextureBinding);if(iTextureBinding>0) strState.appendLine(TStr("     RECTANGLE: ",(int)iTextureBinding));
    }
}
void RenderUtils::debugGetFramebufferAttachmentState(t_string& strState)
{
    strState.appendLine(TStr("**FRAMEBUFFERS**"));
    GLenum eDrawBuffer;
    GLint iDrawFramebufferBinding;//name of fb beijmg drawn to
    GLint iReadFramebufferBinding;//name of fb beijmg drawn to
    GLint iRenderbufferBinding;
    GLenum eReadBuffer;
    GLint iSamplerBinding;    //!Texture sampler (should be 2d??)
    GLint maxColorAttachments=0;
    GLint boundFramebuffer;
//Reference enums
//#define GL_FRONT 0x0404
//#define GL_BACK 0x0405

    // Framebuffers
    glGetIntegerv(GL_DRAW_BUFFER,(GLint*)&eDrawBuffer);//0x08CE0 is the COLOR ATTACHMENT 1, 0x0405 is the default BACK buffer.
    glGetIntegerv(GL_READ_BUFFER,(GLint*)&eReadBuffer);//Default: GL_BACK
    glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING,&iDrawFramebufferBinding);
    glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING,&iReadFramebufferBinding);
    glGetIntegerv(GL_RENDERBUFFER_BINDING, &iRenderbufferBinding);
    glGetIntegerv(GL_SAMPLER_BINDING,&iSamplerBinding);    
    glGetIntegerv(GL_MAX_COLOR_ATTACHMENTS, &maxColorAttachments);
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, &boundFramebuffer);
    
    CheckGpuErrorsRtNoThrow();

    strState.appendLine(TStr(" Max Color Attachments: ",maxColorAttachments));
    strState.appendLine(TStr(" Current Bound Framebuffer: ",boundFramebuffer));
    strState.appendLine(TStr(" Current Draw Framebuffer (glDrawBuffer): ",iDrawFramebufferBinding));
    strState.appendLine(TStr(" Current Read Framebuffer (glReadBuffer): ",iReadFramebufferBinding));
    if(iDrawFramebufferBinding != iReadFramebufferBinding) 
        strState.appendLine(TStr("   NOTE: Draw and Read framebuffers are bound different!"));
    strState.appendLine(TStr(" Current RenderBuffer Binding: ",iRenderbufferBinding));
    strState.appendLine(TStr(" Read Buffer Enum: ",eReadBuffer));
    strState.appendLine(TStr(" Current Sampler Binding: ",iSamplerBinding));

    if(boundFramebuffer==0)
        return;

    // Print details about hte bound buffer.
    strState.appendLine(TStr("Attachments Bound To the current framebuffer: "));
    for(int i=0; i< maxColorAttachments; ++i)
    {
        GLint attachmentName=0;
        GLint attachmentType=0;
        GLint mipmapLevel =0;
        strState.appendLine(TStr("----Attachment: ",i));    

        glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0+i, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &attachmentType);
            CheckGpuErrorsRtNoThrow();
        if(attachmentType == GL_NONE)
        {
            strState.appendLine(TStr("    Type: ","GL_NONE"));    

        }
        if(attachmentType == GL_RENDERBUFFER)
        {
            glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0+i, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &attachmentName);
                CheckGpuErrorsRtNoThrow();
            strState.appendLine(TStr("    Type: ","GL_RENDERBUFFER"));    
            strState.appendLine(TStr("    Name: ",attachmentName));    
            
        }
        else if(attachmentType == GL_TEXTURE)
        {
            glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0+i, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &attachmentName);
                CheckGpuErrorsRtNoThrow();
            glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0+i, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, &mipmapLevel);
                CheckGpuErrorsRtNoThrow();
            strState.appendLine(TStr("    Type: ","GL_TEXTURE"));    
            strState.appendLine(TStr("    Name: ",attachmentName));    
            strState.appendLine(TStr("    Mipmap Level: ",mipmapLevel));    
        }
    }

}
void RenderUtils::debugGetVertexArrayState(t_string& strState)
{
    strState.appendLine(TStr("**VERTEX ARRAY STATE**"));
    int nMaxAttribs;
    GLint iVertexArrayBinding;
    glGetIntegerv(GL_MAX_VERTEX_ATTRIBS,&nMaxAttribs);
    glGetIntegerv(GL_VERTEX_ARRAY_BINDING,&iVertexArrayBinding);
    
    strState.appendLine(TStr("Bound Vertex Array Id (VAO):",iVertexArrayBinding));
    strState.appendLine(TStr("(Max Allowed Atribs:",nMaxAttribs,")"));
    
    CheckGpuErrorsRtNoThrow();

    // - Disable all arrays by default.
    for(int iAttrib=0; iAttrib<nMaxAttribs; ++iAttrib)
    {
        //TODO:
        size_t iArrayBufferBinding=0;
        GLint iArrayEnabled=0;
        GLint iAttribArraySize=0;
        GLenum iAttribArrayType=0;
        GLint iAttribArrayStride=0;
        GLint iAttribArrayInteger=0;
        GLfloat fCurAttrib[4];
        GLint iCurAttrib[4];
        GLuint uiCurAttrib[4];
        GLint iAttribArrayNormalized;
        //GLint iAttribArrayDivisor;
        memset(fCurAttrib, 0, sizeof(GLfloat)*4);
        memset(iCurAttrib, 0, sizeof(GLint)*4);
        memset(uiCurAttrib, 0, sizeof(GLuint)*4);

        glGetVertexAttribiv(iAttrib, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, (GLint*)&iArrayBufferBinding);
        CheckGpuErrorsRtNoThrow();
        glGetVertexAttribiv(iAttrib, GL_VERTEX_ATTRIB_ARRAY_ENABLED, (GLint*)&iArrayEnabled);
        CheckGpuErrorsRtNoThrow();
        glGetVertexAttribiv(iAttrib, GL_VERTEX_ATTRIB_ARRAY_SIZE, (GLint*)&iAttribArraySize);
        CheckGpuErrorsRtNoThrow();
        glGetVertexAttribiv(iAttrib, GL_VERTEX_ATTRIB_ARRAY_TYPE, (GLint*)&iAttribArrayType);
        CheckGpuErrorsRtNoThrow();
        glGetVertexAttribiv(iAttrib, GL_VERTEX_ATTRIB_ARRAY_STRIDE, (GLint*)&iAttribArrayStride);
        CheckGpuErrorsRtNoThrow();
        glGetVertexAttribiv(iAttrib, GL_VERTEX_ATTRIB_ARRAY_INTEGER, (GLint*)&iAttribArrayInteger);
        CheckGpuErrorsRtNoThrow();
        
        glGetVertexAttribiv(iAttrib, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, (GLint*)&iAttribArrayNormalized);
        CheckGpuErrorsRtNoThrow();
        //glGetVertexAttribiv(iAttrib, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, (GLint*)&iAttribArrayDivisor);
        //CheckGpuErrorsDbg();

        strState.appendLine(TStr("Attrib ",iAttrib,"  Enabled:",(iArrayEnabled?"Y":"N")));
        
        if(!iArrayEnabled)
            continue;

        strState.appendLine(TStr("  ArrayBufferBinding:",iArrayBufferBinding));
        strState.appendLine(TStr("  Size:",iAttribArraySize));
        strState.appendLine(TStr("  Stride:",iAttribArrayStride));
        strState.appendLine(TStr("  Is Integer:",(iAttribArrayInteger?"Y":"N")));
        strState.appendLine(TStr("  Normalized:",(iAttribArrayNormalized?"Y":"N")));
        strState.appendLine(TStr("  Type:",RenderUtils::openGlTypeToString(iAttribArrayType)));

        switch(iAttribArrayType)
        {
            case GL_INT: 
                glGetVertexAttribIiv(iAttrib, GL_CURRENT_VERTEX_ATTRIB, (GLint*)&iCurAttrib);
                    CheckGpuErrorsRtNoThrow();
                    strState.appendLine(TStr("  Cur Value: ",iCurAttrib[0],",",iCurAttrib[1],",",iCurAttrib[2],",",iCurAttrib[3]));
                break; 
            case GL_UNSIGNED_INT: 
                glGetVertexAttribIuiv(iAttrib, GL_CURRENT_VERTEX_ATTRIB, (GLuint*)&uiCurAttrib);
                    CheckGpuErrorsRtNoThrow();
                    strState.appendLine(TStr("  Cur Value: ",uiCurAttrib[0],",",uiCurAttrib[1],",",uiCurAttrib[2],",",uiCurAttrib[3]));
                break; 
            case GL_FLOAT: 
                glGetVertexAttribfv(iAttrib, GL_CURRENT_VERTEX_ATTRIB, (GLfloat*)&iCurAttrib);
                    CheckGpuErrorsRtNoThrow();
                    strState.appendLine(TStr("  Cur Value: ",fCurAttrib[0],",",fCurAttrib[1],",",fCurAttrib[2],",",fCurAttrib[3]));
                break; 
            default: 
                strState.appendLine(TStr("  TODO:Cur Value: "));
                break; 
        };
        //This reads the attrib values such as float, int etc.
        //GLint iCurrentVertexAttrib;
        //glGetVertexAttribiv(iAttrib, GL_CURRENT_VERTEX_ATTRIB, (GLint*)&iCurrentVertexAttrib);
    }
    strState.appendLine(TStr("--"));
}
#pragma endregion
//void RenderUtils::drawObjFile(ObjFileData* od)
//{
//
//    //glBegin(GL_TRIANGLES);
//    //for(int ng=0; ng<od->_geoms.size(); ++ng)
//    //{
//    //    ObjFileDataGroup* pg = od->_geoms[ng];
//    //    for(int ix=0; ix<pg->_indices[pg->index_component_vertex].count(); ++ix)
//    //    {
//    //        if(pg->index_component_tcoord!=-1)
//    //        //for(int iii=0; iii<pg->_indices[pg->index_component_tcoord].count(); ++iii)
//    //        {
//    //            int ind3 = pg->_indices[pg->index_component_tcoord][ix];
//    //            //ind1+=od->_verts.count()+1;
//    //            glTexCoord2fv( (GLfloat*)&(od->_tcoords[ ind3 ]) );
//    //        }
//    //        if(pg->index_component_normal!=-1)
//    //        //for(int iii=0; iii<pg->_indices[pg->index_component_normal].count(); ++iii)
//    //        {
//    //            int ind2 = pg->_indices[pg->index_component_normal][ix];
//    //            //ind2+=od->_normals.count()+1;
//    //            glNormal3fv( (GLfloat*)&(od->_normals[ ind2 ]) );
//    //        }
//    //        if(pg->index_component_vertex!=-1)
//    //        //for(int iii=0; iii<pg->_indices[pg->index_component_vertex].count(); ++iii)
//    //        {
//    //            int ind1 = pg->_indices[pg->index_component_vertex][ix];
//    //            //ind1+=od->_verts.count()+1;
//    //            glVertex3fv( (GLfloat*)&(od->_verts[ ind1 ]) );
//    //        }
//    //    }
//    //}
//    //glEnd();
//}

    //size_t intStride = VertexUtils::getVertexStride(_eVertexType);

    //glGenVertexArrays(1, (GLuint*)&vaoIndexes);
    //glBindVertexArray(vaoIndexes);

    //glGenBuffers(1, (GLuint*)&bdVerts);
    //glGenBuffers(1, (GLuint*)&bdIndexes);

    //glBindBuffer(GL_ARRAY_BUFFER, bdVerts);
    //glBufferData(GL_ARRAY_BUFFER,
    //       intStride * _verts->getCount(),
    //       _verts->ptr(),
    //       GL_STATIC_DRAW);

    //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bdIndexes);
    //glBufferData(GL_ELEMENT_ARRAY_BUFFER,
    //       sizeof(t_index32) * _indexes->getCount(),
    //       _indexes->ptr(),
    //       GL_STATIC_DRAW);

    ////Attribute indexes in the shader.
    //std::shared_ptr<ShaderBase> pShader = getShader();
    // AssertOrThrow2(pShader != NULL);
    //signed int attr_v = pShader->getAttribLocation(_eVertexComponent );
    //signed int attr_c = pShader->getAttribLocation(_eColorComponent  );
    //signed int attr_x = pShader->getAttribLocation(_eTextureComponent);
    //
    ////Vertex Byte Offsets
    //size_t intVertexOff   = VertexUtils::getComponentByteOffset(_eVertexType, _eVertexComponent );
    //size_t intColorOff    = VertexUtils::getComponentByteOffset(_eVertexType, _eColorComponent  );
    //size_t intTextureOff  = VertexUtils::getComponentByteOffset(_eVertexType, _eTextureComponent);

    //if (attr_v != GlslShaderAttribute::NoAttribLocationFound)
    //{
    //    glEnableVertexAttribArray(attr_v);
    //    glBindBuffer(GL_ARRAY_BUFFER, bdVerts);
    //    glVertexAttribPointer(attr_v,
    //                        3,
    //                        GL_FLOAT,
    //                        GL_FALSE,
    //                        (GLsizei)intStride,
    //                        (GLvoid*)(0 + intVertexOff)
    //                    );
    //}
    //if (attr_c != GlslShaderAttribute::NoAttribLocationFound)
    //{
    //    glEnableVertexAttribArray(attr_c);
    //    glBindBuffer(GL_ARRAY_BUFFER, bdVerts);
    //    glVertexAttribPointer(attr_c,
    //                        4,
    //                        GL_FLOAT,
    //                        GL_FALSE,
    //                        (GLsizei)intStride,
    //                        (GLvoid*)(0 + intColorOff)
    //                    );
    //}
    //if (attr_x != GlslShaderAttribute::NoAttribLocationFound)
    //{
    //    glEnableVertexAttribArray(attr_x);
    //    glBindBuffer(GL_ARRAY_BUFFER, bdVerts);
    //    glVertexAttribPointer(attr_x,
    //                        2,
    //                        GL_FLOAT,
    //                        GL_FALSE,
    //                        (GLsizei)intStride,
    //                        (GLvoid*)(0 + intTextureOff)
    //                    );
    //}

    //_bInitialized = true;

    ////Draw 
    //CheckAllErrorsDbg();





	//void World25::doCharAwarenessFast(PixObj* pChar, Box3f* pAwarenessBox, std::vector<WorldCell*>& visSet, float fAwarenessRadius) {
//    //TODO: this might be faster if we use the phy / manifolds.
//    WorldCell* pc = getGlobalCellForPoint(pAwarenessBox->center());
//
//    if (pc != nullptr) {
//        std::vector<WorldCell*> toMarch;
//        std::vector<WorldCell*> toAdd;
//        float fAwareDivR2 = 1.0f / (fAwarenessRadius* fAwarenessRadius);
//        float fAwareDivR = 1.0f / (fAwarenessRadius);
//        static t_timeval s_iMarchStamp = 0;
//        s_iMarchStamp++;
//
//        //Put the seed cell in.
//        toMarch.push_back(pc);
//        visSet.push_back(pc);
//
//        int32_t nIter = 0;
//
//        vec3 p0; // For the occlusion test
//        p0 = pAwarenessBox->center();
//        p0.y = 0;
//        float charMinY = pChar->getBoundBoxObject()->_min.y;
//        float charMaxY = pChar->getBoundBoxObject()->_max.y;
//
//        vec3 diff ;
//        ProjectedRay pr;
//        std::vector<Box3f*> vecOccluders; //Should be faster than std:;set
//        while (toMarch.size()) {
//            WorldCell* pCell = toMarch[0];
//            if ((pCell != nullptr) && (pCell->_iLightMarchStamp != s_iMarchStamp))
//            {
//                pCell->_iLightMarchStamp = s_iMarchStamp;
//
//                for (int iNeighbor = 0; iNeighbor < WorldCell::c_nNeighbors; ++iNeighbor) 
//                {
//                    WorldCell* pNeighbor = pCell->getNeighbor((World25Side::e)iNeighbor);
//                    if ((pNeighbor != nullptr) && (pNeighbor->_iLightMarchStamp != s_iMarchStamp))
//                    {
//                        if (pAwarenessBox->cubeIntersect_EasyOut_Inclusive(pNeighbor->getBoundBoxBvh()))
//                        {
//                            if (pNeighbor == nullptr) 
//                            {
//                                vecOccluders.push_back(pNeighbor->getBoundBoxBvh());
//                                //setOccluders.insert(pNeighbor->getBoundBoxBvh());
//                            }
//                            else 
//                            {
//                                //First check visible
//
//                                nIter++;
//                                bool bVisible = occludeNeighborCell(pNeighbor, vecOccluders, fAwareDivR, p0, charMinY, charMaxY);
//
//                                if (bVisible == true) {
//                                    toMarch.push_back(pNeighbor);
//                                    visSet.push_back(pNeighbor);
//                                }
//                            }
//                        }
//                    }
//                }
//            }
//
//            toMarch.erase(toMarch.begin());
//
//        }
//
//        toMarch.clear();
//        toAdd.clear();
//        vecOccluders.clear();
//
//    }
//    else {
//        //RutRo
//        int nnn=0;
//        nnn++;
//    }
//}
//bool World25::occludeNeighborCell(WorldCell* pNeighbor, std::vector<Box3f*>& vecOccluders, 
//    float fAwareDivR, vec3& p0, float charMinY, float charMaxY) {
//    //Don't include tiles that have no sprite on them.
//
//    //SUMMARY
//    //Here we treat occluders as spheres and cast a ray through all of them
//    // to the tile's 4 vertexes, and then treat these values as shadows. 
//    //This makes occlusion smoother than doing boxes only.
//
//    //This value controls how far past cells we can see - it controls how
//    //much shadow is past the cells.  >1.0 will mean you can see past a full cell
//    //and behind a wall.
//    float fIntMaxDepth = CongaUtils::getCellWidth() * 0.7f; //**More accurate would be the sphere diameter.
//
//    vec3 bnc = pNeighbor->getBoundBoxBvh()->center();
//    bnc.y = 0;
//
//    vec3 bn0(pNeighbor->getBoundBoxBvh()->_min.x, 0, pNeighbor->getBoundBoxBvh()->_min.z);
//    vec3 bn1(pNeighbor->getBoundBoxBvh()->_max.x, 0, pNeighbor->getBoundBoxBvh()->_min.z);
//    vec3 bn2(pNeighbor->getBoundBoxBvh()->_min.x, 0, pNeighbor->getBoundBoxBvh()->_max.z);
//    vec3 bn3(pNeighbor->getBoundBoxBvh()->_max.x, 0, pNeighbor->getBoundBoxBvh()->_max.z);
//
//    float fInt_d0 = 0, fInt_d1 = 0, fInt_d2 = 0, fInt_d3 = 0, fInt_dc = 0;
//
//    bool bVisible = true;
//    //for(std::set<Box3f*>::iterator itOccluder = setOccluders.begin(); 
//    //    itOccluder!= setOccluders.end(); itOccluder++) {
//    //    Box3f* bOccluder = *itOccluder;
//    for (Box3f* bOccluder : vecOccluders) {
//        //Get occluder radius ^2 -- this can be cached.
//        float ra = (bOccluder->_max.x - bOccluder->_min.x) * 0.5f;
//        float rb = (bOccluder->_max.z - bOccluder->_min.z) * 0.5f;
//        float oc_r2 = ra*ra + rb*rb + 0.02f;//We add a small amount in order to avoid excluding corner verts
//
//        vec3 oc = bOccluder->center();
//        oc.y = 0;
//
//        fInt_d0 += radialOccludeDepth(p0, bn0, oc, oc_r2);
//        fInt_d1 += radialOccludeDepth(p0, bn1, oc, oc_r2);
//        fInt_d2 += radialOccludeDepth(p0, bn2, oc, oc_r2);
//        fInt_d3 += radialOccludeDepth(p0, bn3, oc, oc_r2);
//        fInt_dc += radialOccludeDepth(p0, bnc, oc, oc_r2);
//
//        if (fInt_d0 >= fIntMaxDepth && fInt_d1 >= fIntMaxDepth &&
//            fInt_d2 >= fIntMaxDepth && fInt_d3 >= fIntMaxDepth) {
//            //Fully Occluded, totally invisible.
//            bVisible = false;
//            break;
//        }
//    }
//
//    //Occlusion color.
//    //This little value prevents us from seeing past a specific number of cells.
//    if (fInt_dc>fIntMaxDepth) { fInt_dc = fIntMaxDepth; }
//    fInt_dc = 1.0f - fInt_dc / fIntMaxDepth;
//
//    if (fInt_d0>fIntMaxDepth) { fInt_d0 = fIntMaxDepth; }
//    fInt_d0 = 1.0f - fInt_d0 / fIntMaxDepth;
//
//    if (fInt_d1>fIntMaxDepth) { fInt_d1 = fIntMaxDepth; }
//    fInt_d1 = 1.0f - fInt_d1 / fIntMaxDepth;
//
//    if (fInt_d2>fIntMaxDepth) { fInt_d2 = fIntMaxDepth; }
//    fInt_d2 = 1.0f - fInt_d2 / fIntMaxDepth;
//
//    if (fInt_d3>fIntMaxDepth) { fInt_d3 = fIntMaxDepth; }
//    fInt_d3 = 1.0f - fInt_d3 / fIntMaxDepth;
//
//    //This makes the shadow "thicker"
//    //fInt_dc = powf(fInt_dc, 2.0);
//
//    fInt_d0 *= fInt_dc; // Multiply by the center occlusion - this prevents "behind" tiles from being seen completely.
//    fInt_d1 *= fInt_dc;
//    fInt_d2 *= fInt_dc;
//    fInt_d3 *= fInt_dc;
//
//    //y is the color of the hidden "shade" tile verts
//   // pNeighbor->getColor(0).y = fInt_d0;
//   // pNeighbor->getColor(1).y = fInt_d1;
//   // pNeighbor->getColor(2).y = fInt_d2;
//   // pNeighbor->getColor(3).y = fInt_d3;
//
//    //Awareness Penumbra Color
//    //Sort of like "fogging".  We have a falloff to make it not look like a square.
//    //x = 1/(awareness^2), y = same as x, but for distance.
//    float len2, f0, f1, f2, f3;
//    vec3 fd0(pNeighbor->getBoundBoxBvh()->_min.x, 0, pNeighbor->getBoundBoxBvh()->_min.z);
//    vec3 fd1(pNeighbor->getBoundBoxBvh()->_min.x, 0, pNeighbor->getBoundBoxBvh()->_max.z);
//    vec3 fd2(pNeighbor->getBoundBoxBvh()->_max.x, 0, pNeighbor->getBoundBoxBvh()->_min.z);
//    vec3 fd3(pNeighbor->getBoundBoxBvh()->_max.x, 0, pNeighbor->getBoundBoxBvh()->_max.z);
//    //I was using Length^2 here but length is accurate
//    len2 = (fd0 - p0).length();
//    f0 = 1.0f - clamp(len2 * fAwareDivR, 0.0f, 1.0f);
//    len2 = (fd1 - p0).length();
//    f1 = 1.0f - clamp(len2 * fAwareDivR, 0.0f, 1.0f);
//    len2 = (fd2 - p0).length();
//    f2 = 1.0f - clamp(len2 * fAwareDivR, 0.0f, 1.0f);
//    len2 = (fd3 - p0).length();
//    f3 = 1.0f - clamp(len2 * fAwareDivR, 0.0f, 1.0f);
//
//   // pNeighbor->getColor(0).x = f0;
//   // pNeighbor->getColor(1).x = f1;
//   // pNeighbor->getColor(2).x = f2;
//   // pNeighbor->getColor(3).x = f3;
//
// //   pNeighbor->setFrameVisible(bVisible);
//
//    if (isOccluder(pNeighbor, charMinY, charMaxY)) {
//        vecOccluders.push_back(pNeighbor->getBoundBoxBvh());
//        //setOccluders.insert(pNeighbor->getBoundBoxBvh());
//    }
//
//    return bVisible;
//}
//float World25::radialOccludeDepth(vec3 p0, vec3 p1, vec3 b0, float boxr2) {
//    //get the percentage of penetration of a point in a sphere [0,1]
//    //boxr2 - the radius^2 of the occluder
//    //p0,p1 the line from the char to one corner of the neighbor box
//    //b0 the center of the given occluder.
//
//    float ft = pointOnLine_t(p0, p1, b0);
//    if (ft >= 0.0f && ft <= 1.0f) {
//        float ftlen2 = ((p0 + (p1 - p0)*ft) - b0).length2();
//        if (ftlen2 <= boxr2) {
//            //Compute intersect depth of ray
//            float boxr = sqrtf(boxr2);
//            float ftlen = sqrtf(ftlen2);
//            return boxr - ftlen;
//        }
//    }
//
//    return 0;
//}
//bool World25::isOccluder(WorldCell* pNeighbor, float ciz, float caz){
//    //Short out for now - we'll do object occluders later
//  //  if (pNeighbor->getTile(MatterMode::e::Solid) != nullptr) {
//  //      //*20170503 removed cell manifolds
//  //      //if(pNeighbor->getCellManifold()->getObjects()->size() >0) {
//  //      //    std::multimap<float, PixObj*>::iterator itOb = pNeighbor->getCellManifold()->getObjects()->begin();
//  //      //    PixObj* ob2 = itOb->second;
//  //
//  //      //    float fiz = ob2->getBoundBoxObject()->_min.y;
//  //      //    float faz = ob2->getBoundBoxObject()->_max.y;
//  //      //    //Only count objects that are on the same Z level as the char.
//  //      //    if((fiz > caz) || (ciz > faz)) {
//  //      //        //We are a doorway object.  Or we have a hole where the player can see through
//  //      //    }
//  //      //    else {
//  //      //        if (ob2->getSpec()->getTransparency() == 0.0f) {
//  //      //            return true;
//  //      //        }
//  //      //    }
//  //      //}
//  //  }
//  //  else {
//        return true;
// //   }
//    return false;
//}
//bool World25::cellOcclusionQuery(Box3f* pAwarenessBox, Box3f* pCellBox, 
//    std::set<Box3f*>& setOccluders, CellVisibility& __out_ vis) {
//    ProjectedRay ray[4];
//    bool blocked[4];
//    RaycastHit rh;
//   // Box3f cellBExtended;
//    vec3 v[4], light[4];
//    vec3 bc = pAwarenessBox->center();
//
//   // bc.z = 0; //make everything just on the plane.
//
//    //Create 4 rays for each corner of the cell tile.
//    // Each ray counts for 25% of the cell's visibility
//    float box_zc = pCellBox->_min.z + (pCellBox->_max.z - pCellBox->_min.z)*0.5f;
//
//    v[0].construct(pCellBox->_min.x, pCellBox->_min.y, box_zc);
//    v[1].construct(pCellBox->_max.x, pCellBox->_min.y, box_zc);
//    v[2].construct(pCellBox->_min.x, pCellBox->_max.y, box_zc);
//    v[3].construct(pCellBox->_max.x, pCellBox->_max.y, box_zc);
//
//    //A hypothetical aperature radius - we could add this later to fine tune the lighting calculations but
//    //for now just consider it to be the actual cell box.  Don't use the tile center as the point light "source" - that makes it look weird.
//    float cw2 = CongaUtils::getCellWidth() * 0.48f; // Don't use 0.5f because it will miss adjacent tiles
//    light[0] = bc + vec3(-cw2, -cw2, 0);
//    light[1] = bc + vec3(-cw2,  cw2, 0);
//    light[2] = bc + vec3( cw2, -cw2, 0);
//    light[3] = bc + vec3( cw2,  cw2, 0);
//
//    for(int i=0; i<4; ++i) {
//        blocked[i] = false;
//        ray[i].Origin = light[i];
//        ray[i].Dir = v[i] - light[i];
//        ray[i].opt();
//    }
//
//    for (Box3f* pBox : setOccluders) {
//        //Extend the Z range of the bound box to be a huge value thus making
//        //the cell a 100% occluder.
//        //cellBExtended._min = pCell->getBoundBox()->_min;
//        //cellBExtended._max = pCell->getBoundBox()->_max;
//        //
//        //cellBExtended._min.z = -FLT_MAX;
//        //cellBExtended._max.z = FLT_MAX;
//
//        for(int i=0; i<4; ++i){
//            if (blocked[i]==false && pBox->LineOrRayIntersectInclusive_EasyOut(&ray[i])) {
//                blocked[i] = true;
//            }
//        }
//        
//        if (blocked[0] && blocked[1] && blocked[2] && blocked[3]) {
//            return false;
//        }
//    }
//
//    vis._fVisCount = (float)((int)!blocked[0] + (int) !blocked[1] + (int)! blocked[2] + (int)!blocked[3]);
//
//    return true;
//}
//void World25::addOccluders(WorldCell* pCell, std::set<Box3f*>& setOccluders) { 
//    //Add occlusion boxes to the visibility query.
//
//    if(pCell->getBaseTile() == nullptr){
//        //Add the "huge" blocking bvh box from the cell - we shouldn't see past non-tiles.
//        setOccluders.insert(pCell->getBoundBoxBvh());
//    }
//    else {
//        //Add all objects as occluders
//        std::multimap<float, PixObj*>::iterator it = pCell->getCellManifold()->getObjects()->begin();
//        for(;it!= pCell->getCellManifold()->getObjects()->end(); it++){
//            PixObj* pOb = it->second;
//            if (pOb->getSpec()->getTransparency() < 0.5f) {
//                setOccluders.insert(pOb->getBoundBoxObject());
//            }
//        }
//    }
//
//}

//void DeferredFramebuffer::deleteDeferredMrt() 
//{
//    _pContext->glBindFramebuffer(GL_FRAMEBUFFER, NULL);
//
//    _pContext->glDeleteFramebuffers(1,&_uiGlFramebufferId);
//
//    for(size_t i=0; i<_vecTargets.size(); ++i) {
//        GLuint texId = _vecTargets[i]->getTexId();
//        glDeleteTextures(1, &texId);
//
//        delete _vecTargets[i];
//    }
//    _vecTargets.resize(0);
//}

//void DeferredFramebuffer::getColorAttachmentArray(GLenum (&arr)[32], bool bColors, bool bAlpha, bool bBloom)
//{
//    //These are not for the dpeth buffer, color only
//    int iArr =0 ;
//    for(size_t i=0; i<32; ++i) {
//        arr[i] = 0;
//        if(_vecTargets.size() > i) {
//            if(_vecTargets[i]->getTargetType() == RenderTargetType::e::Color && bColors) {
//                arr[iArr++] = _vecTargets[i]->getAttachment();
//            }
//            if (_vecTargets[i]->getTargetType() == RenderTargetType::e::Alpha && bAlpha) {
//                arr[iArr++] = _vecTargets[i]->getAttachment();
//            }
//            if (_vecTargets[i]->getTargetType() == RenderTargetType::e::Bloom && bBloom) {
//                arr[iArr++] = _vecTargets[i]->getAttachment();
//            }
//        }
//    }
//}




    //static int32_t ci_idle;
    //static t_string cs_idle;
    //static int32_t ci_walk;
    //static t_string cs_walk;
    //static int32_t ci_climb;
    //static t_string cs_climb;
    //static int32_t ci_hang;
    //static t_string cs_hang;
    //static int32_t ci_work;
    //static t_string cs_work;
    //static t_string cs_pickup;
    //static t_string cs_walk_item;
    //static int32_t ci_pickup;
    //static int32_t ci_walk_item;

    //static int32_t ci_idle_item;
    //static t_string cs_idle_item;


	//int32_t Animator::ci_idle;
//int32_t Animator::ci_walk;
//int32_t Animator::ci_climb;
//int32_t Animator::ci_hang;
//int32_t Animator::ci_work;
//t_string Animator::cs_idle;
//t_string Animator::cs_walk;
//t_string Animator::cs_climb;
//t_string Animator::cs_hang;
//t_string Animator::cs_work;
// t_string Animator::cs_pickup;
// t_string Animator::cs_walk_item;
// int32_t Animator::ci_pickup;
// int32_t Animator::ci_walk_item;
// int32_t Animator::ci_idle_item;
// t_string Animator::cs_idle_item;
void Animator::initStaticData() {
    //cs_idle = "idle";
    //ci_idle = Hash::computeStringHash32bit(cs_idle);
   
    //cs_walk = "walk";
    //ci_walk = Hash::computeStringHash32bit(cs_walk);
    //
    //cs_climb = "climb";
    //ci_climb = Hash::computeStringHash32bit(cs_climb);
    //
    //cs_hang = "hang";
    //ci_hang = Hash::computeStringHash32bit(cs_hang);
    //
    //cs_work = "work";
    //ci_work = Hash::computeStringHash32bit(cs_work);

    //cs_pickup = "pickup";
    //ci_pickup = Hash::computeStringHash32bit(cs_pickup);

    //cs_walk_item = "walk_item";
    //ci_walk_item = Hash::computeStringHash32bit(cs_walk_item);
    //
    //cs_idle_item = "idle_item";
    //ci_idle_item = Hash::computeStringHash32bit(cs_idle_item);



	
//ModelLoadInfo* MobFile::parse(char* buf)
//{
//
//    int nKd=0;
//    char c;
//    ptr = buf;
//    std::vector<t_string> tokens;
//    t_string token;
//    while(ptr)
//    {
//        c=*ptr;
//        if(c=='#')
//        { 
//            if(tokens.size() >=2)
//                pkp(tokens[0],tokens[1],nKd);// - Parse the given token buffer
//            
//            tokens.clear();
//            eatLine();
//        }
//        else if(c=='\n')
//        {
//            if(tokens.size() >=2)
//                pkp(tokens[0],tokens[1],nKd);// - Parse the given token buffer
//            
//            tokens.clear();
//            eatLine();
//        }
//        else if(IOFile::isWs(c))
//        {
//            if(token.length())
//                tokens.push_back( t_string(token) );
//            token="";
//
//            inc();
//        }
//        else
//        {
//            if(b_eof)
//            {
//                if(tokens.size() >=2)
//                    pkp(tokens[0],tokens[1],nKd);// - Parse the given token buffer
//            
//                break;
//            }
//            token+=c;
//            inc();
//        }
//        
//    }
//
//}
//void MobFile::addPart()
//{
//    if (_pCurPart)
//    {
//        _pModelLoadInfo->_vecParts.push_back(_pCurPart);
//        _pCurPart = NULL;
//    }
//}

    //else if (lcmp(tokens[0], "tmd", 2))//TODO: replace all the crap with lcmp
    //{
    //    if (!_pCurPart)
    //        throw new Exception(" [MOD Loader] No current model part defined.", __LINE__, __FILE__);
    //    _pCurPart->_texDiffuse = tok1;
    //    return true;
    //}
    //else if (lcmp(tokens[0], "tmn", 2))//TODO: replace all the crap with lcmp
    //{
    //    if (!_pCurPart)
    //        throw new Exception(" [MOD Loader] No current model part defined.", __LINE__, __FILE__);
    //    _pCurPart->_texNormal = tok1;
    //    return true;
    //}


	    //else if (StringUtil::lowercase(tok0) == "skn")//TODO: replace all the crap with lcmp
    //{
    //    if (_pModelLoadInfo->_sknFileName.length() > 0)
    //        BroThrowException(" [MOD LOADER] Skin file already specified.");
    //    _pModelLoadInfo->_sknFileName = tok1;
    //}
    //else if (StringUtil::lowercase(tok0) == "mpt_beg")//TODO: replace all the crap with lcmp
    //{
    //    addPart();

    //    _pCurPart = new ModelLoadInfoPart();
    //    _pCurPart->_partName = tok1;
    //}

    //else
    //{
    //    BroLogDebug(" [Mod loader] Warning: invalid token encountered: ", tok0);
    //}

	//class BoneNode : public VirtualMemory {
//public:
//
//    //std::shared_ptr<BoneSpec> _pBone = nullptr;
//    BoneNode() {  }
//    virtual ~BoneNode() override;
//};
//class Action : public VirtualMemory{
//public:
//    std::
//    Action(){}
//    virtual Action(){}
//};
//class BoneAnimationDef : public VirtualMemory {
//public:
//    int _iBeginKf; //These are they keyframes loaded from the skn file
//    int _iEndKf;
//    t_string _strAnimName;
//    float scaleFrame(int frame) {
//        float divisor = (float)(_iEndKf - _iBeginKf);
//        if (divisor == 0.0f) {
//            divisor = 1.0f;
//        }
//        float dividend = (float)(frame - _iBeginKf);
//        return  dividend / divisor;
//    }
//    BoneAnimationDef(t_string sn, int ib, int ie) : _strAnimName(sn), _iBeginKf(ib), _iEndKf(ie) {
//    }
//};

//
//std::shared_ptr<BoneSpec> ArmFileData::parseHString(t_string st) {
//    std::shared_ptr<BoneSpec> root = nullptr;
//    std::shared_ptr<BoneSpec> parent = nullptr;
//    std::shared_ptr<BoneSpec> cur = nullptr;
//    t_string tok = "";
//    int bpi = -1;
//
//    for (size_t ic = 0; ic < st.length(); ++ic) {
//        char cc = st[ic];
//
//        if (cc == '(') {
//            //Start bone
//            cur = new BoneNode();
//            if (parent != nullptr) {
//                parent->_vecChildren.push_back(cur);
//                cur->_pParent = parent;
//            }
//            if (root == nullptr) {
//                root = cur;
//            }
//            bpi = 0;
//            tok = "";
//        }
//        else if (cc == ')') {
//            //methodisze this int he future.
//            if (bpi == 0) {
//                cur->_sBoneName = tok;
//                cur->_iBoneName = Hash::computeStringHash32bit(tok);
//            }
//            else if (bpi == 1) {
//                cur->_iBoneId = TypeConv::strToInt(tok);
//            }
//            else if (bpi == 2) { cur->_vBegin.x = TypeConv::strToFloat(tok); }
//            else if (bpi == 3) { cur->_vBegin.y = TypeConv::strToFloat(tok); }
//            else if (bpi == 4) { cur->_vBegin.z = TypeConv::strToFloat(tok); }
//            else if (bpi == 5) { cur->_vEnd.x = TypeConv::strToFloat(tok); }
//            else if (bpi == 6) { cur->_vEnd.y = TypeConv::strToFloat(tok); }
//            else if (bpi == 7) { cur->_vEnd.z = TypeConv::strToFloat(tok); }
//
//            bpi = 0;
//            //End Bone
//            tok = "";
//        }
//        else if (cc == '[') {
//            //Push bone
//            parent = cur;
//            cur = nullptr;
//        }
//        else if (cc == ']') {
//            //Pop bone
//            cur = parent;
//            if (parent != nullptr) {
//                parent = parent->_pParent;
//            }
//            tok = "";
//        }
//        else if (cc == ',') {
//            //Bone info
//            if (bpi == 0) {
//                cur->_sBoneName = tok;
//                cur->_iBoneName = Hash::computeStringHash32bit(tok);
//            }
//            else if (bpi == 1) {
//                cur->_iBoneId = TypeConv::strToInt(tok);
//            }
//            else if (bpi == 2) { cur->_vBegin.x = TypeConv::strToFloat(tok); }
//            else if (bpi == 3) { cur->_vBegin.y = TypeConv::strToFloat(tok); }
//            else if (bpi == 4) { cur->_vBegin.z = TypeConv::strToFloat(tok); }
//            else if (bpi == 5) { cur->_vEnd.x = TypeConv::strToFloat(tok); }
//            else if (bpi == 6) { cur->_vEnd.y = TypeConv::strToFloat(tok); }
//            else if (bpi == 7) { cur->_vEnd.z = TypeConv::strToFloat(tok); }
//
//            bpi++;
//            tok = "";
//        }
//        else {
//            tok += cc;
//        }
//    }
//
//    return root;
//}

//#include "../bottle/SnakeMaker.h"
//#include "../bottle/World25.h"
//#include "../bottle/World25Grid.h"
//#include "../bottle/W25MeshMaker.h"
//#include "../bottle/WorldCell.h"
//#include "../bottle/Motion25Bucket.h"
//#include "../bottle/CongaUtils.h"
//#include "../bottle/Tile25Spec.h"
//
//
//namespace Game {
/////////////////////////////////////////////////////////////////////
//SnakeMaker::SnakeMaker(std::shared_ptr<World25> pw, vec3& vBasePos, float cw, float ch) : _pWorld25(pw) {
//    _vBasePos = vBasePos;
//    _fCellHeight = ch; _fCellWidth = ch;
//}
//SnakeMaker::~SnakeMaker()  { 
//}
/////////////////////////////////////////////////////////////////////
//void SnakeMaker::setTile(t_string name) {
//    _pCurTile = _pWorld25->getMotionBucket()->getTileByName(name);
//}
//Tile25Spec* SnakeMaker::getTile() { return _pCurTile; }
//WorldCell* SnakeMaker::getCellForPt(ivec3& pt) {
//    QuadLut::iterator it = _quadLut.find(&pt);
//    if (it != _quadLut.end()) {
//        return it->second;
//    }
//    return nullptr;
//}
////set all geoms based on getting the TOP RIGHT vt cell for the dv
//void SnakeMaker::makeCellsForDv(ivec3& dv) {
//    ivec3 d[8];
//    d[0] = dv + ivec3(0, 0, 0);
//    d[1] = dv + ivec3(1, 0, 0);
//    d[2] = dv + ivec3(0, 1, 0);
//    d[3] = dv + ivec3(1, 1, 0);
//    d[4] = dv + ivec3(0, 0, 1);
//    d[5] = dv + ivec3(1, 0, 1);
//    d[6] = dv + ivec3(0, 1, 1);
//    d[7] = dv + ivec3(1, 1, 1);
//
//    WorldCell* cell[8];
//
//    //Create Cells with the tile pen.
//    for (int ci = 0; ci < 8; ++ci) {
//        WorldCell* pc = getCellForPt(d[ci]);
//
//        if (pc == nullptr) {
//            //W25Geom wg = computeGeomForCell();
//            pc = new WorldCell(d[ci].x, d[ci].y, d[ci].z, nullptr, W25GEOM_EMPTY, W25GEOM_EMPTY);
//        //    pc->_v3CustomBase = _vBasePos;
//        //    pc->_v3CustomBase.x += (float)d[ci].x * _fCellWidth;
//        //    pc->_v3CustomBase.y += (float)d[ci].y * _fCellHeight;
//        //    pc->_v3CustomBase.z += (float)d[ci].z * _fCellWidth;
//
//            pc->setTile(getTile()->getMatterMode(), _pCurTile->getTileIndex());
//            ivec3* pNew = new ivec3(d[ci]);
//            _quadLut.insert(std::make_pair(pNew, pc));
//        }
//        cell[ci] = pc;
//    }
//
//    //**Link everything.
//#define setN(ca, cb, ca_r) (ca->setNeighbor(ca_r, cb)), (cb->setNeighbor(CongaUtils::getOppNeighborIndex(ca_r), ca))
//    setN(cell[0], cell[1], World25Side::e::gR);
//    setN(cell[0], cell[2], World25Side::e::gT);
//    setN(cell[0], cell[4], World25Side::e::gF);
//
//    // setN(cell[1], cell[0], World25Side::e::gL);
//    setN(cell[1], cell[3], World25Side::e::gT);
//    setN(cell[1], cell[5], World25Side::e::gF);
//
//    setN(cell[2], cell[3], World25Side::e::gR);
//    // setN(cell[2], cell[0], World25Side::e::gB);
//    setN(cell[2], cell[6], World25Side::e::gF);
//
//    //   setN(cell[3], cell[2], World25Side::e::gL);
//    // setN(cell[3], cell[1], World25Side::e::gB);
//    setN(cell[3], cell[7], World25Side::e::gF);
//
//    setN(cell[4], cell[5], World25Side::e::gR);
//    setN(cell[4], cell[6], World25Side::e::gT);
//    //  setN(cell[4], cell[0], World25Side::e::gA);
//
//    //  setN(cell[5], cell[4], World25Side::e::gL);
//    setN(cell[5], cell[7], World25Side::e::gT);
//    //  setN(cell[5], cell[1], World25Side::e::gA);
//
//    setN(cell[6], cell[7], World25Side::e::gR);
//    //  setN(cell[6], cell[4], World25Side::e::gB);
//    //  setN(cell[6], cell[2], World25Side::e::gA);
//
//    // setN(cell[7], cell[6], World25Side::e::gL);
//    //  setN(cell[7], cell[5], World25Side::e::gB);
//    //  setN(cell[7], cell[3], World25Side::e::gA);
//
//
//    //Set Geoms
//    for (int ci = 0; ci<8; ++ci) {
//        W25Geom wg = cell[ci]->getGeom(getTile()->getMatterMode());
//
//        int bit = 7 - ci; //This may be, no it's probably wrong.
//        wg |= (1 << bit);
//
//        cell[ci]->setGeom(getTile()->getMatterMode(), wg);
//    }
//
//
//}
//void SnakeMaker::pumpSome(const ivec3& relPos) {
//    int iPenA = (int)floorf((float)_iPenSize / 2);
//    int iPenB = (int)ceilf((float)_iPenSize / 2);
//    ivec3 dv_pen;
//    for (int x = -iPenA; x < iPenB; ++x) {
//        for (int y = -iPenA; y < iPenB; ++y) {
//            for (int z = -iPenA; z < iPenB; ++z) {
//                dv_pen = relPos + ivec3(x, y, z);
//                if ((_bPenRandom == false) || (_bPenRandom == true && (rand() % 2) > 0)) {
//                    makeCellsForDv(dv_pen);
//                }
//            }
//        }
//    }
//
//}
//void SnakeMaker::vadd(ivec3& relPos, int x, int y, int z) {
//    ivec3 dv;
//    //We need this for first pt
//    //if (x != 0 && y != 0 && z != 0) {
//    dv = relPos + ivec3(x, y, z);
//
//    pumpSome(dv);
//    //}
//}
//void SnakeMaker::vrel(ivec3& relPos, int x, int y, int z) {
//    if (x != 0 || y != 0 || z != 0) {
//        relPos += ivec3(x, y, z);
//        pumpSome(relPos);
//    }
//}
//void SnakeMaker::makeDumbTree() {
//    setTile("bt-lava");
//    ivec3 c(0, 0, 0);
//    _iPenSize = 1;
//
//    //stump
//    vadd(c, 0, 0, 0);
//    //vadd(c, -1,  0,  0);
//    //vadd(c, -2,  0,  0);
//    //vadd(c,  1,  0,  0);
//    //vadd(c,  2,  0,  0);
//    //vadd(c,  0, -1,  0);
//    //vadd(c,  0, -2,  0);
//    //vadd(c,  0,  1,  0);
//    //vadd(c,  0,  2,  0);
//    //vadd(c,  0,  0, -1);
//    //vadd(c,  0,  0, -2); 
//    //vadd(c,  0,  0,  1);
//    //vadd(c,  0,  0,  2);
//
//
//    //trunk
//    _iPenSize = 1;
//    int iMaxTrunkCount = 12, iMinTrunkCount = 4;
//    int iTrunkCount = Random::nextInt32(iMinTrunkCount, iMaxTrunkCount);//iMinTrunkCount + (rand() % (iMaxTrunkCount - iMinTrunkCount + 1));
//    for (int i = 0; i<iTrunkCount; ++i) {
//        // float pctDone = (float)i / (float)iTrunkCount;
//
//        //Set pen thickness
//        //   if (pctDone > .6) _iPenSize = 1;
//        //  else if (pctDone > .2) _iPenSize = 2;
//        //  else  _iPenSize = 3;
//
//        vrel(c, 0, 1, 0);
//        //int dx=0, dz=0;
//        //if( Gu::frand() > .2 ) { 
//        //    int amt = 1 + (rand()%3);
//        //    for(int i=0; i<amt; ++i){
//        //        dx = -1 + (rand() % 3);
//        //        dz = -1 + (rand() % 3);
//        //        if (dx != 0 && dz != 0) {
//        //            vrel(c, dx, 0, dz);
//        //        }
//        //    }
//        //}
//
//    }
//    //Determines branch size compared to trun.
//    int fTrunkPct = ((float)iTrunkCount / (float)iMaxTrunkCount);
//
//    setTile("bt-water");
//    _iPenSize = 1;
//    _bPenRandom = false;
//    ivec3 cSaved = c;
//    int iLeafXZCountMax = (int)(25.0 * iTrunkCount);
//    int iLeafYCountMax = (int)(0.6 * iTrunkCount);
//
//    for (int iLeafY = 0; iLeafY < iLeafYCountMax; ++iLeafY) {
//        float leaf_make_smaller = 1.0 - ((float)iLeafY / (float)(iLeafYCountMax + 1));
//        int iCurLeafXzCount = (int)(leaf_make_smaller * (float)iLeafXZCountMax);
//
//        for (int iQuad = 0; iQuad<4; ++iQuad) {
//            c = cSaved;
//            int qxb, qzb;//Add biases.
//                         //Grow the leaves in quadrants to ensure they look 'normal'
//                         //Biases
//            if (iQuad == 0) { qxb = -1; qzb = -1; }
//            if (iQuad == 1) { qxb = 1; qzb = -1; }
//            if (iQuad == 2) { qxb = -1; qzb = 1; }
//            if (iQuad == 3) { qxb = 1; qzb = 1; }
//
//            int qx = 0, qz = 0;
//            for (int iLeaf = 0; iLeaf < iCurLeafXzCount; ++iLeaf) {
//                int dx = (Random::nextFloat(0.0, 1.0) > 0.62) ? qxb : -qxb;
//                int dz = (Random::nextFloat(0.0, 1.0) > 0.62) ? qzb : -qzb;
//
//                qx += dx;
//                qz += dz;
//
//                //Stay within quadrant.
//                if (iQuad == 0) { if (qx>0) qx = 0; if (qz>0) qz = 0; }
//                if (iQuad == 1) { if (qx<0) qx = 0; if (qz>0) qz = 0; }
//                if (iQuad == 2) { if (qx>0) qx = 0; if (qz<0) qz = 0; }
//                if (iQuad == 3) { if (qx<0) qx = 0; if (qz<0) qz = 0; }
//
//                vadd(c, qx, iLeafY, qz);
//            }
//        }
//    }
//
//
//    //
//    //  //Top
//    //  int iLeafCount = rand() % 10;
//    //  setTile("bt-grass3");
//
//}
//void SnakeMaker::makeMesh() {
//    std::vector<W25MeshVert> _vSolid;
//    std::vector<v_index32 > _iSolid;
//    std::vector<W25MeshVert> _vLiquid;
//    std::vector<v_index32 > _iLiquid;
//
//    for (QuadLut::iterator ite = _quadLut.begin(); ite != _quadLut.end(); ite++) {
//        WorldCell* gc = ite->second;
//        _pWorld25->getMeshMaker()->fillMeshByConfig(
//            _vSolid,
//            _iSolid,
//            _pWorld25->getMotionBucket(),
//            _pWorld25->getWorldAtlas(), gc, MatterMode::e::Solid,
//            _fCellWidth, _fCellHeight,
//            _pWorld25->getConfig(),
//            &_vBasePos
//        );
//        _pWorld25->getMeshMaker()->fillMeshByConfig(
//            _vLiquid,
//            _iLiquid,
//            _pWorld25->getMotionBucket(),
//            _pWorld25->getWorldAtlas(), gc, MatterMode::e::Liquid,
//            _fCellWidth, _fCellHeight,
//            _pWorld25->getConfig(),
//            &_vBasePos
//
//        );
//    }
//
//
//    CongaUtils::makeWorldMesh(_pWorld25->getContext(), _pSolidMesh, &_vSolid, &_iSolid);
//    CongaUtils::makeWorldMesh(_pWorld25->getContext(), _pLiquidMesh, &_vLiquid, &_iLiquid);
//}
//
//
//
//
//
//
//}//ns Game
///**
//*
//*    @file SnakeMaker.h
//*    @date May 1, 2017
//*    @author Derek Page
//*
//*     2017 
//*
//*
//*/
//#pragma once
//#ifndef __SNAKEMAKER_14936934721344005199_H__
//#define __SNAKEMAKER_14936934721344005199_H__
//
//#include "../bottle/CongaHeader.h"
//
//namespace Game {
///**
//*    @class SnakeMaker
//*    @brief Makes Individual Blanket Meshes of any size
//*   This will probably be replaced by the "half grid" system later.
//*
//*/
//class SnakeMaker : public VirtualMemory {
//public:
//    typedef std::map<ivec3*, WorldCell*, ivec3::Vec3xCompLess> QuadLut;
//private:
//    QuadLut _quadLut;
//    Tile25Spec* _pCurTile = nullptr;
//    std::shared_ptr<Motion25Bucket> _pMotionBucket = nullptr;
//    std::shared_ptr<World25> _pWorld25 = nullptr;
//    vec3 _vBasePos;
//    float _fCellWidth, _fCellHeight;
//    int _iPenSize = 1;
//    int _bPenRandom = false;
//
//    void setTile(t_string name);
//    Tile25Spec* getTile();
//    WorldCell* getCellForPt(ivec3& pt);
//public:
//    SnakeMaker(std::shared_ptr<World25> pw, vec3& vBasePos, float cw, float ch);
//    virtual ~SnakeMaker() override;
//
//    //TEST
//    MeshGeneric* _pSolidMesh = nullptr;
//    MeshGeneric* _pLiquidMesh = nullptr;
//
//    //set all geoms based on getting the TOP RIGHT vt cell for the dv
//    void makeCellsForDv(ivec3& dv);
//    void pumpSome(const ivec3& relPos);
//    void vadd(ivec3& relPos, int x, int y, int z) ;
//    void vrel(ivec3& relPos, int x, int y, int z) ;
//    void makeDumbTree() ;
//    void makeMesh();
//};
//
//}//ns Game
//
//
//
//#endif


//void World25::collectVisibleNodes(World25Grid* gg, std::set<World25Grid*>& collected, t_timeval stamp, bool bRoot) {
//    //*So there's a problem with this func
//    //If we haven't generated all the nodes in the frutum we end up with
//    //discontinuities and the terrain will disappear.
//    //HOWEVER iterating through the std::map of nodes is freaking slow.
//    // We could change the std::map to be a vector<vector<vector>>> of nodes.  Changing the data structure
//    // would be quicker.
//    // Alternatively we could generate *ALL* nodes in the frustum (up to a point)
//    if (gg == nullptr) {
//        return;
//    }
//
//    if (gg->getCollectStamp() != stamp) {
//        gg->setCollectStamp(stamp);
//        g_test_GatherIter++;
//
//        std::shared_ptr<FrustumBase> frust = getContext()->getCamera()->getFrustum();
//        Box3f* box = gg->getBoundBox();
//
//        //By default add the root. t his was causing some visibility problems I'm not sure why!
//        if (frust->hasAABB(box) || bRoot) {
//            collected.insert(gg);
//            for (int ig = 0; ig < World25Grid::c_nNeighbors; ++ig) {
//                World25Grid* pn = gg->getNeighbor(ig);
//                if (pn != nullptr) {
//                    //   if(pn->getGenState() == GridGenState::e::GenComplete) {
//                    collectVisibleNodes(pn, collected, stamp, false);
//                    //   }
//                }
//            }
//        }
//
//    }
//}

//void World25::deleteFarGrids() {
//    vec3 vp = getAwarenessPos();
//    ivec3 dp0, dp1;
//    Box3f c;
//    getAwarenessBox(c, CongaUtils::getBvhAwarenessDeleteRadiusXZ(), CongaUtils::getBvhAwarenessDeleteRadiusY());
//    getNodeRangeForBox(&c, &dp0, &dp1);
//
//    std::vector<ivec3*> toDelete;
//    for (GridMap::iterator it = _gridMap.begin(); it != _gridMap.end(); it++) {
//        std::shared_ptr<WorldGrid> gg = it->second;
//        if (gg->getIsGenerating() == false) {
//            if (gg->getGridPos().x < dp0.x ||
//                gg->getGridPos().y < dp0.y ||
//                gg->getGridPos().z < dp0.z ||
//                gg->getGridPos().x > dp1.x ||
//                gg->getGridPos().y > dp1.y ||
//                gg->getGridPos().z > dp1.z) {
//
//                if (gg->canDelete()) {
//                    //Delete the cell
//                    toDelete.push_back(it->first);
//                }
//            }
//        }
//    }
//
//    for (size_t i = 0; i < toDelete.size(); ++i) {
//        deleteGrid(std::move(*toDelete[i]));
//    }
//
//    if (toDelete.size() > 0) {
//        // updateLights();
//        _pSmasher->refreshCache();
//
//        BroLogDebug("Deleted ", toDelete.size(), " grids.");
//    }
//
//    toDelete.resize(0);
//}


//void World25::deleteGrid(ivec3&& gi) {
//    GridMap::iterator it = _gridMap.find(&gi);
//    if (it != _gridMap.end()) {
//        ivec3* pv = it->first;
//        std::shared_ptr<WorldGrid> pg = it->second;
//
//        //Remove from addl. sets.
//        //**THIS IS AN ERROR.
//        //Nodes may be presently generating while this is run.
//        Gu::debugBreak();
//        std::set<std::shared_ptr<WorldGrid>>::iterator it2 = _setGenStage1.find(pg);
//        if (it2 != _setGenStage1.end()) {
//            _setGenStage1.erase(it2);
//        }
//        std::set<std::shared_ptr<WorldGrid>>::iterator it3 = _setGenStage2.find(pg);
//        if (it3 != _setGenStage2.end()) {
//            _setGenStage2.erase(it3);
//        }
//
//        //Note: so the grid isn't in the grid map anymore.
//        //Imperative this comes BEFORE you remove objects or link, because we refresh their caches.
//        _gridMap.erase(it);
//        //std::map<World25GridId, World25Grid*>::iterator it = _gridsById.find(pg->getId());
//        //_gridsById.erase(it);
//
//        pg->unloadObjects();
//        pg->unlinkCellsAndGridsSync();
//
//        DEL_MEM(pv);//Delete the pointer to the vec3
//        DEL_MEM(pg);
//    }
//}

//void World25::makeOrCollectGridForPos(ivec3& cv, std::vector<std::shared_ptr<WorldGrid>>& vecGenerated) {
//    std::shared_ptr<WorldGrid> pGrid;
//
//    pGrid = dynamic_cast<std::shared_ptr<WorldGrid>>(Gu::getContext()->getPhysics()->getNodeAtPos(cv));
//
//    //Separate grid generation into 2 phases.  First always create so that we have the "grid".
//    //Second, if the grid isn't
//    //generated/ing, then put it in the generation queue.
//    if (pGrid == nullptr) {
//
//        //find grid.  if we can't find then add to "empty" set of ivec3
//        if (_setEmpty.find(&cv) == _setEmpty.end()) {
//
//            pGrid = _pWorldMaker->loadGrid(cv);
//            addGrid(pGrid, cv);
//        }
//    }
//    else {
//        std::shared_ptr<FrustumBase> frust = getContext()->getCamera()->getFrustum();
//        Box3f* box = pGrid->getBoundBox();
//        if (frust->hasAABB(box)) {
//            _setVisibleGrids.insert(pGrid);
//        }
//    }
//
//    if (pGrid != nullptr) {
//        if (pGrid->getGenState() == GridGenState::e::PreGen) {
//            if ((_setGenStage1.size() + vecGenerated.size()) < _pConfig->getMaxGridsGenAsync()) {
//                pGrid->setQueued();
//                vecGenerated.push_back(pGrid);
//            }
//        }
//    }
//}
//void World25::addGrid(std::shared_ptr<WorldGrid> pGrid, ivec3& cv){
//    ivec3* idx = new ivec3(cv);
//    if (pGrid != nullptr) {
//        debugMakeSureNoDupes(pGrid->getGridPos());
//        _gridMap.insert(std::make_pair(idx, pGrid));
//    }
//    else {
//        _setEmpty.insert(idx);
//    }
//}
//World25Grid* World25::makeGridForPos2(ivec3& cv) {
//    World25Grid* pGrid;
//
//    pGrid = getNodeAtPos(cv);
//
//    //Separate grid generation into 2 phases.  First always create so that we have the "grid".
//    //Second, if the grid isn't
//    //generated/ing, then put it in the generation queue.
//    if (pGrid == nullptr) {
//        //Create the grid.
//        pGrid = createNode(cv);
//    }
//
//    return pGrid;
//}



//void World25::debugMakeSureNoDupes(ivec3& vv)
//{
//
//    for (GridMap::iterator it = _gridMap.begin(); it != _gridMap.end(); it++) {
//        ivec3* v = it->first;
//        if (v->x == vv.x && v->y == vv.y && v->z == vv.z) {
//            BroThrowException("Duplicate node found.");
//        }
//    }
//
//}
//World25Grid* World25::createGrid(ivec3& pos) {
//    World25Grid* pg = new World25Grid(this, pos, _pContext, _pSmasher);
//    pg->initSync();
//    ivec3* idx = new ivec3(pg->getGridPos().x, pg->getGridPos().y, pg->getGridPos().z);
//    debugMakeSureNoDupes(pg->getGridPos());
//    _gridMap.insert(std::make_pair(idx, pg));
//    //  _gridsById.insert(std::make_pair(pg->getId(), pg));
//
//    return pg;
//}

//WorldObj* World25::createObj(WorldObjSpec* ps, vec3& vStartPos, bool bActivate, bool bRefreshCache) {
//    WorldObj* ob;
//
//    ob = new WorldObj(this, ps, vStartPos, _pSmasher);
//
//    //get all objs for cell
//    //v3 stack pos
//    //for each.. in set
//    // stack pos += x,y
//    //stack them
//
//    ob->setPos(std::move(vStartPos));
//    if (ps->getDrawType() == DrawType::e::Model) {
//        //std::shared_ptr<ModelSpec> ms = Gu::getContext()->getModelCache()->getModelByName(ps->_strMobName);
//        //if (ms == nullptr) {
//        //    BroThrowException("Failed to find model '", ps->_strMobName, "'");
//        //}
//
//        //ModelNode* mod = ms->createNode();
//        //ob->setModelNode(mod);
//        //ob->update(0); // ** MUST CALL BEFORE ADDING IN ORDER TO UPDATE BOUND BOX.
//
//    }
//    else if (ps->getDrawType() == DrawType::e::Sprite || ps->getDrawType() == DrawType::e::Box5) {
//        ob->setMotion(ps->_pBaseMotion->getName(),
//            ps->_pBaseMotion->getDefaultDuration(),
//            ps->_pBaseMotion->getDefaultLoop());
//        ob->update(0); // ** MUST CALL BEFORE ADDING IN ORDER TO UPDATE BOUND BOX.
//
//        //*not adding models to smasher (just yet)
//        _pSmasher->addObj(ob, bActivate, bRefreshCache);
//    }
//
//    //It needs to be in smasher to have visibility.
//
//    //if (StringUtil::equals(ps->getName(), "TreeGen")) {
//    //    //TEST
//    //    //TEST
//    //    //TEST
//    //    //TEST
//    //    float fWidth = (float)CongaUtils::getCellWidth() * 1.0f / 2.0f;
//    //    float fHeight = (float)CongaUtils::getCellHeight() * 1.0f / 2.0f;
//    //    SnakeMaker sm(this, vStartPos, fWidth, fHeight);
//    //    sm.makeDumbTree();
//    //    sm.makeMesh();
//    //    ob->setMesh(MatterMode::e::Solid, sm._pSolidMesh);
//    //    if (ob->getMesh(MatterMode::e::Solid) != nullptr) {
//    //        ob->getBoundBoxObject()->genExpandByBox(ob->getMesh(MatterMode::e::Solid)->getBox());
//    //    }
//    //    ob->setMesh(MatterMode::e::Liquid, sm._pLiquidMesh);
//    //    if (ob->getMesh(MatterMode::e::Liquid) != nullptr) {
//    //        ob->getBoundBoxObject()->genExpandByBox(ob->getMesh(MatterMode::e::Liquid)->getBox());
//    //    }
//    //    //TEST
//    //    //TEST
//
//    //}
//
//    return ob;
//}
//void World25::delObj(PixObjId obid) {
//    WorldObj* ob = _pSmasher->getObj(obid);
//    if (ob == nullptr) {
//        Gu::debugBreak();
//    }
//    else {
//        _pSmasher->delObj(ob, true);
//    }
//
//
//}
//WorldObj* World25::getObj(PixObjId obid) {
//    return _pSmasher->getObj(obid);
//}

//void World25::getRaycastGrids(Ray_t* pr, std::multimap<float, World25Grid*>& grids) {
//  //Don't even call this dumb crap
//#ifdef _DEBUG
//    float rayLen = pr->getDir().length();
//    if(rayLen > 1200) {
//        int nnn=0;
//        nnn++;
//    }
//#endif
//    //make a boxizzle
//    Box3f c;
//    c._min = vec3::minv(pr->getBegin(), pr->getEnd());
//    c._max = vec3::maxv(pr->getBegin(), pr->getEnd());
//
//    int yi = CongaUtils::getNodesYMin();
//    int ya = CongaUtils::getNodesYMax();
//
//    ivec3 p0, p1;
//    getNodeRangeForBox(&c, &p0, &p1);
//
//    int dbgnCount=0;
//    RaycastHit rh;
//    for (t_int32 k = p0.z; k <= p1.z; ++k) {
//    for (t_int32 j =   yi; j <=   ya; ++j) {
//    for (t_int32 i = p0.x; i <= p1.x; ++i) {
//        ivec3 cv(i, j, k);
//        World25Grid* pg = getNodeAtPos(cv);
//        dbgnCount++;
//        if (pg != nullptr) {
//            if(pg->getBoundBox()->RayIntersect_EasyOut(pr)){
//                grids.insert(std::make_pair(rh._t, pg));
//            }
//        }
//    }
//    }
//    }
//    int nnn=0;
//    nnn++;
//}

//WorldObjSpec* World25::getObjSpecForType(PixObjType iType)
//{
//    //TODO: map, or set
//    for (std::pair<Hash32, WorldObjSpec*> p : _mapSpecs) {
//        if (p.second->_iType == iType) {
//            return p.second;
//        }
//    }
//    return nullptr;
//}
//WorldObjSpec* World25::getObjSpecByName(t_string name) {
//    Hash32 h = STRHASH(name);
//    std::map<Hash32, WorldObjSpec*>::iterator it = _mapSpecs.find(h);
//    if (it != _mapSpecs.end()) {
//        return it->second;
//    }
//    return nullptr;
//}
//bool World25::cellIsMovable(WorldCell* pCell) {
//    PixObj* pixObj = pCell->getBottomObj();
//    if(pixObj !=nullptr){
//        return pixObj->getSpec()->getHollow();
//    }
//    return true;
//}
//void World25::tryMoveObject(PixObjId obid, vec3& dir, float dt) {
//    WorldObj* charOb = _pSmasher->getObj(obid);
//
//    if (charOb != nullptr) {
//        if (charOb->getSpec()->isPlayerChar()) {
//            //vec3 moveDir = vec3((float)vp.x,0 , (float)vp.y);
//
//            vec3 cv = charOb->getPhy()->getVelocity();
//            float fSpd;
//            if (getContext()->getFingers()->shiftHeld()) {
//                fSpd = charOb->getSpec()->getMoveSpeedRun();
//            }
//            else {
//                fSpd = charOb->getSpec()->getMoveSpeedCreep();
//            }
//            cv += dir * fSpd * dt;
//
//            CongaUtils::limitVelocity(cv);
//
//            charOb->getPhy()->setVelocity(cv);
//            //Notify the physics system that an object wants to move.
//            _pSmasher->activate(charOb->getPhy());
//
//        }
//    }
//}
//void World25::tryJumpObject(PixObjId obid, float dt) {
//    WorldObj* charOb = _pSmasher->getObj(obid);
//
//    if (charOb != nullptr) {
//        if (charOb->getSpec()->isPlayerChar()) {
//            if (charOb->getPhy()->getVelocity().y == 0) {
//                vec3 jumpDir = vec3(0, 1, 0);
//
//                vec3 cv = charOb->getPhy()->getVelocity();
//
//                cv += jumpDir * 10.0 * dt;
//
//                CongaUtils::limitVelocity(cv);
//
//                charOb->getPhy()->setVelocity(cv);
//                //Notify the physics system that an object wants to move.
//                _pSmasher->activate(charOb->getPhy());
//            }
//        }
//    }
//}
//WorldCell* World25::getObjQuad(PixObj* ob) {
//    //Update for Phy25 
//    return getGlobalCellForPoint2d(ob->getCenter());
//}

//void World25::reparentObjectByCustomBox(WorldObj* ob, Box3f* pBox) {
//    bool bSet = false;
//    bool bSet2 = false;
//    //clear
//    clearObjectManifoldAndRemoveFromGrid(ob);
//
//    //Gather nodes
//    Box3f c;
//    c._min.x = pBox->_min.x;
//    c._min.y = pBox->_min.y;
//    c._min.z = pBox->_min.z;
//    c._max.x = pBox->_max.x;
//    c._max.y = pBox->_max.y;
//    c._max.z = pBox->_max.z;
//
//    ivec3 p0, p1;
//    getNodeRangeForBox(&c, &p0, &p1);
//
//    for (t_int32 node_z = p0.z; node_z <= p1.z; ++node_z) {
//        for (t_int32 node_y = p0.y; node_y <= p1.y; ++node_y) {
//            for (t_int32 node_x = p0.x; node_x <= p1.x; ++node_x) {
//                ivec3 nodePos(node_x, node_y, node_z);
//                std::shared_ptr<WorldGrid> pGrid;
//                std::vector<std::shared_ptr<WorldGrid>> gen;
//                pGrid = getNodeAtPos(nodePos);
//                if (pGrid == nullptr) {
//                    makeOrCollectGridForPos(nodePos, gen);
//                }
//                pGrid = getNodeAtPos(nodePos);
//                if (pGrid != nullptr) {
//                    //Now get cells
//
//                    ivec3 cell_p0, cell_p1;
//                    pGrid->getLocalCellRangeForBox(c, cell_p0, cell_p1);
//                    pGrid->getManifold()->add(ob);
//                    ob->getPhy()->getManifold()->addGrid(pGrid);
//
//                    //Invalid ranges here we'll simply ignore them, because they're going to happen.
//                    for (t_int32 cell_z = cell_p0.z; cell_z <= cell_p1.z; ++cell_z) {
//                        for (t_int32 cell_y = cell_p0.y; cell_y <= cell_p1.y; ++cell_y) {
//                            for (t_int32 cell_x = cell_p0.x; cell_x <= cell_p1.x; ++cell_x) {
//                                ivec3 cellPos(cell_x, cell_y, cell_z);
//                                WorldCell* pCell = pGrid->getCellForIndex(cellPos);
//
//                                if (pCell != nullptr) {
//                                    //Cell cannot ever be null.
//
//                                    //Add to Grid, Cell, and Cell to OB
//                                    //*20170503 removed cell manifolds
//                                    //   pCell->getCellManifold()->add(ob);
//                                    ob->getPhy()->getManifold()->addCell(pCell);
//                                }
//                                else {
//                                    //Object is outside of the grid.
//                                    //We should allow this because this will happen with physics anomolies.
//                                    if (_pContext->getFpsMeter()->frameMod(30) && bSet == false) {
//                                        BroLogInfo("OBject outside Cells!");
//                                        bSet = true;
//                                    }
//                                    //AssertOrThrow2(pCell != nullptr);
//                                    // Gu::debugBreak();
//                                }
//
//
//                            }
//                        }
//                    }
//
//                }
//                else {
//                    if (_pContext->getFpsMeter()->frameMod(30)) {
//                        //   BroLogInfo("OBject outside grid!");
//                    }
//                    //**Object is approaching outside grid bounds.
//                    //Gu::debugBreak();
//                }
//            }
//        }
//    }
//
//
//}
//void World25::getRaySelectData(Ray_t* pr, W25SelectData* __out_ pSelectData) {
//    AssertOrThrow2(pSelectData != nullptr);
//    AssertOrThrow2(pr != nullptr);
//
//    //TODO: Fix all this
//    //we need a tri normal AND a block normal.
//    //we need to also add colliding with the ground plane and point/normal on that.
//    // we need to remove colliding with arbitrary empty blocks (or no material)
//    //we need to set material = null when geom = empty and geom = empty wehn material == null
//
//
//    //out_hit = nullptr;
//    //out_hover = nullptr;
//
//    //out_n.construct(0, 0, 0);
//    //out_pt.construct(0, 0, 0);
//
//    //Get the hit point where we hit the block
//    //Then get the side that point is on.
//    pSelectData->_pTriCell = hitCellGroundUnderRay(pr, true);
//
//    if (pSelectData->_pTriCell != nullptr) {
//        pSelectData->_vTriNormal = pr->getNormal();
//        pSelectData->_vTriPoint = pr->getHitPoint();
//
//        vec3 tpt = pSelectData->_vTriPoint;
//        vec3 bn;
//        //Compute the block surface
//        Box3f bb;
//        tpt = pr->getHitPoint();
//        vec3 bc = pSelectData->_pTriCell->getBoundBoxBvh()->center();
//        Ceq::aa_point_contact_plane(tpt, bc, bn);
//        vec3 dp = tpt + (bn * CongaUtils::getCellHeight() * 0.5);
//        pSelectData->_pBlockCell = getGlobalCellForPoint(dp);
//
//        pSelectData->_vBlockNormal = bn;
//        pSelectData->_vBlockPoint = dp;
//        
//    }
//    else {
//        pSelectData->_vTriNormal.construct(0, 0, 0);
//        pSelectData->_vTriPoint.construct(0, 0, 0);
//        pSelectData->_vBlockNormal.construct(0, 0, 0);
//        pSelectData->_vBlockPoint.construct(0, 0, 0);
//    }
//
//
//}

//void World25::getRaySelectNode(Ray_t* pr, World25Grid*& __out_ grid) {
//    //This is unused, but useful
//    grid = nullptr;
//    if (getWorld25Plane()->intersectRay(pr)) {
//        vec3 pt = pr->getHitPoint();
//        pt.y += 0.0001f;    // this removes ambiguity and cell "snaps"
//        grid = getGlobalNodeForPoint(pt);
//    }
//}

//void World25::setTileUf(std::shared_ptr<ShaderBase> ps) { 
// //   BroThrowNotImplementedException();
//    ////It seems we can't get out of copying the whole buffer because we hard code the indexes.
//    //int bufferByteSize = W25_MAX_GPU_SPRITES * sizeof(GpuTile);
//    //
//    //int binding_index = 2;
//    //if (_iTileUboId == -2) {
//    //    _pContext->glGenBuffers(1, (GLuint*)&_iTileUboId);
//    //    _pContext->glBindBuffer(GL_UNIFORM_BUFFER, _iTileUboId);
//    //    _pContext->glBufferData(GL_UNIFORM_BUFFER, bufferByteSize, 0, GL_DYNAMIC_DRAW);
//    //    _pContext->glBindBuffer(GL_UNIFORM_BUFFER, 0);
//    //
//    //    //_pContext->glBindBufferBase(GL_UNIFORM_BUFFER, binding_index, _iTileUboId);
//    //    _ufTileDataBufferIndex = _pContext->glGetUniformBlockIndex(getGLId(), "GpuSprites");
//    //    _pContext->glUniformBlockBinding(getGLId(), _ufTileDataBufferIndex, binding_index);
//    //    // _pContext->glBindBufferBase(GL_UNIFORM_BUFFER, binding_index, _iTileUboId);
//    //}
//    //if (_ufTileDataBufferIndex == -1) {
//    //    Gu::debugBreak();
//    //    return;
//    //}
//    //// memcpy(_gpuTiles, gpuTiles, W25_MAX_GPU_SPRITES * sizeof(GpuTile));
//    ////_pContext->glBindBuffer(GL_UNIFORM_BUFFER, _iTileUboId);
//    //_pContext->glBindBuffer(GL_UNIFORM_BUFFER, _iTileUboId);
//    //_pContext->glBufferData(GL_UNIFORM_BUFFER, bufferByteSize, (void*)gpuTiles, GL_DYNAMIC_DRAW);
//    //_pContext->glBindBuffer(GL_UNIFORM_BUFFER, 0);
//    //
//    //_pContext->glBindBufferBase(GL_UNIFORM_BUFFER, binding_index, _iTileUboId);
//    //
//    //// void* vp = _pContext->glMapBuffer(GL_UNIFORM_BUFFER, GL_READ_ONLY);
//    //// if(vp != nullptr){
//    ////     memcpy(_gpuTiles, vp, W25_MAX_GPU_SPRITES * sizeof(GpuTile));
//    //// }
//    //// _pContext->glUnmapBuffer(GL_UNIFORM_BUFFER);
//    //
//    //    // memcpy(_gpuTiles, gpuTiles, W25_MAX_GPU_SPRITES * sizeof(GpuTile));
//    //    // //_gpuTiles[30]._iOff = 5;
//    //    // for (int i = 0; i<W25_MAX_GPU_SPRITES; ++i) {
//    //    //     _gpuTiles[i]._iOff = 6;
//    //    // }
//    //
//    //
//    //
//    //
//    //_pContext->chkErrDbg();
//}

//void World25::updateAwarenessOld() {
//    //todo: CACHE THE PLAYER'S cell pos here. and udpate only if player cell pos is greater.
//
//    //COMMENTED OUT
//    //COMMENTED OUT
//    //COMMENTED OUT
//    //COMMENTED OUT
//    //COMMENTED OUT
//    //COMMENTED OUT
//    //COMMENTED OUT
//   // if(Gu::getContext()->getFpsMeter()->frameMod(4)){
//        //we should remove entirely and just generate the whole thing, but we can do
//        //it async, just generate 
//  //  makeGridAndCollectVisible();
//
//    // }
//
//     //SYNC system 2017 12 21
//    //if (_bAsyncGen) {
//    //    generateStage2();
//    //    postGenerateNodes();
//    //}
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //COMMENTED OUT DELTE
//    //deleteFarGrids(); ** Why was this commented out?
//
//
//
//}

//void World25::makeGridAndCollectVisible() {
//    //This is the main grid thing.
//    //We may be able to limit the Y axis here.
//    _setVisibleGrids.clear();
//
//    Box3f c;
//    getAwarenessBox(c);
//    ivec3 p0, p1;
//    getNodeRangeForBox(&c, &p0, &p1);
//
//    int yi = CongaUtils::getNodesYMin();
//    int ya = CongaUtils::getNodesYMax();
//    AssertOrThrow2(yi <= ya);
//
//    std::vector<std::shared_ptr<WorldGrid>> vecGen;
//    int dbg_nGrids = abs(p1.x - p0.x + 1) * abs(p1.z - p0.z + 1);
//    for (t_int32 k = p0.z; k <= p1.z; ++k) {
//    for (t_int32 j = yi; j <= ya; ++j) {//p0.y; j <= p1.y; ++j) {
//    for (t_int32 i = p0.x; i <= p1.x; ++i) {
//        ivec3 cv(i, j, k);
//        if (getGrids().size() < _pConfig->getGridCountLimit()) {
//            makeOrCollectGridForPos(cv, vecGen);
//        }
//    }
//    }
//    }
//
//    if(_bAsyncGen) {
//        generateStage1(vecGen, false);
//    }
//
//
//    vecGen.resize(0);
//

//void World25::gatherVisibleCells(std::vector<WorldCell*>& visibleCells,
//    std::multimap<float, WorldObj*>& visibleLights) {
//    ///This is going to be the new light/gather routine.
//    //Ok - so the thing is we don't want to draw tiles
//    //that are not visible by the player or else they're necessarily going to get light values.
//    //, so we have to do this quad update
//    //way.
//
//    vec3 charCenter;
//    ivec2 p0, p1;
//    Quad2f quad;
//
//    Box3f* pLightBox, *pCharBox;
//
//    for (WorldObj* pChar : _pSmasher->getPlayerChars()) {
//        pCharBox = pChar->getAwarenessBox();
//
//        AssertOrThrow2(pCharBox != nullptr);
//
//        //Collect all intersecting lights.
//        //for (PixObj* pLight : _pSmasher->getLights()) {
//        //    //AssertOrThrow2(pLight->getGpuLight() != nullptr);
//        //    pLightBox = pLight->getLightBox();
//
//        //    if (pCharBox->cubeIntersect_EasyOut_Inclusive(pLightBox)) {
//        //        float fDist2 = (pChar->getPos() - pLight->getPos()).length2();
//        //        visibleLights.insert(std::make_pair(fDist2, pLight));
//        //    }
//        //}
//      //  doCharAwarenessFast(pChar, pCharBox, visibleCells, pChar->getAwarenessRadius());
//    }
//}
//

//void World25::makeSpecs(ObFile* obFile) {
//    //New - the specs are now in the SPR file.
//    for (WorldObjSpec* ps : obFile->getPixObjSpecs()) {
//        Hash32 h = STRHASH(ps->getName());
//        if (h == 0) {
//            int nnn = 0;
//            nnn++;
//        }
//        _mapSpecs.insert(std::make_pair(h, ps));
//    }
//}
//void World25::collectVisibleNodesIntoSet(std::set<World25Grid*>& nodeSet) {
//    vec3 v = getAwarenessPos();
//    ivec3 iv = CongaUtils::v3Toi3Node(v);//glob
//    World25Grid* gg = getNodeAtPos(iv);
//
//    if (gg == nullptr) {
//        //When we debug we sometimes hit a nullptr node since we only generate  a fewof them, 
//        // so brute force find a node.  Keep the above method because it's much faster since
//        //we don't have to perform a std::set lookup as many times.
//
//        //**So we are having performance issues with this and I can't think of a solution.
//        //**SO instead we will **Always** generate all grids, but if the gird is outside the Y range we won't generate
//        // a mesh or anything.
//        //gg = getFirstVisibleNode();
//
//        //**SO THIS MAY BE NULL.
//        //If we generate asynchronlusly the grid will be null.
//
//        //*Update: shouldn't be null now, because we generate the first grid for the player's pos
//   //     Gu::debugBreak();
//    }
//
//    t_timeval stamp = Gu::getMicroSeconds();
//    g_test_GatherIter = 0;
//    nodeSet.clear();
//
//    collectVisibleNodes(gg, nodeSet, stamp, false);
//}

//}
    //////////////////////////////////////////////////////////////////////////
    //ms = Guc::getContext()->getModelCache()->getOrLoadModel("chartest_noa");
    //if (ms == nullptr) {
    //    BroThrowException("Failed to find model '", ms->getName(), "'");
    //}
    //else {
    //    _pCharTestModel = ms->createNode();
    //    _pCharTestModel->update(0.0);
    //}
    ////////////////////////////////////////////////////////////////////////////
    //ms = Gu::getContext()->getModelCache()->getOrLoadModel("axis_test");
    //if (ms == nullptr) {
    //    BroThrowException("Failed to find model '", ms->getName(), "'");
    //}
    //else {
    //    _pAxisTestModel = ms->createNode();
    //    _pAxisTestModel->update(0.0);
    //}
    //////////////////////////////////////////////////////////////////////////
   // ms = Gu::getContext()->getModelCache()->getOrLoadModel("hand_curs_01");
   // if (ms == nullptr) {
   //     BroThrowException("Failed to find model '", ms->getName(), "'");
   // }
   // else {
   //     _pHandCursor = new ModelNode(ms);//ms->createNode();
   //     _pHandCursor->update(0.0);
   // }
    //////////////////////////////////////////////////////////////////////////
    //ms = Gu::getContext()->getModelCache()->getOrLoadModel("simple_arm_test");
    //if (ms == nullptr) {
    //    BroThrowException("Failed to find model '", ms->getName(), "'");
    //}
    //else {
    //    _pSimpleArmTest = ms->createNode();
    //    _pSimpleArmTest->update(0.0);
    //}
    ////////////////////////////////////////////////////////////////////////////
    //ms = Gu::getContext()->getModelCache()->getOrLoadModel("multi_arm_test");
    //if (ms == nullptr) {
    //    BroThrowException("Failed to find model '", ms->getName(), "'");
    //}
    //else {
    //    _pMultiArmTest = ms->createNode();
    //    _pMultiArmTest->update(0.0);
    //}
    ////////////////////////////////////////////////////////////////////////////
    if (false) {
        std::cout<< Gu::getContext()->getModelCache()->debugPrintAllModelNames();
    }
    //////////////////////////////////////////////////////////////////////////
    //ms = Gu::getContext()->getModelCache()->getOrLoadModel("cuddles_01b");
    //if (ms == nullptr) {
    //    BroThrowException("Failed to find model '", ms->getName(), "'");
    //}
    //else {
    //    _pCuddlesTest = ms->createNode();
    //    _pCuddlesTest->update(0.0);
    //}
    ////////////////////////////////////////////////////////////////////////////////
    //ms = Gu::getContext()->getModelCache()->getOrLoadModel("house_2");
    //if (ms == nullptr) {
    //    BroThrowException("Failed to find model '", ms->getName(), "'");
    //}
    //else {
    //    _pHouseTest = ms->createNode();
    //    _pHouseTest->update(0.0);
    //}
    //////////////////////////////////////////////////////////////////////////////
    //ms = Gu::getContext()->getModelCache()->getOrLoadModel("parent_test");
    //if (ms == nullptr) {
    //    BroThrowException("Failed to find model '", ms->getName(), "'");
    //}
    //else {
    //    _pParentTest = ms->createNode();
    //    _pParentTest->update(0.0);
    //}





	        //if dock runs out of room, it just gets pushed left
        //if (pEle->getDockMode() == DockMode::Fill) {
        //    pEle->rect()->left(dock.left());
        //    pEle->rect()->right(dock.right());
        //    pEle->rect()->bottom(dock.bottom());
        //    pEle->rect()->top(dock.top());
        //    dock = orig;//reset to entire area (mimicking visual studio's dock functino)
        //}
        //else if (pEle->getDockMode() == DockMode::Right) {
        //    pEle->rect()->top(dock.top());
        //    pEle->rect()->bottom(dock.bottom());
        //    pEle->rect()->right(dock.right());
        //}
        //else if (pEle->getDockMode() == DockMode::Left) {
        //    pEle->rect()->top(dock.top());
        //    pEle->rect()->bottom(dock.bottom());
        //    pEle->rect()->left(dock.left());
        //}
        //else if (pEle->getDockMode() == DockMode::Top) {
        //    pEle->rect()->left(dock.left());
        //    pEle->rect()->right(dock.right());
        //    pEle->rect()->top(dock.top());
        //}
        //else if (pEle->getDockMode() == DockMode::Bottom) {
        //    pEle->rect()->left(dock.left());
        //    pEle->rect()->right(dock.right());
        //    pEle->rect()->bottom(dock.bottom());
        //}
        //else if (pEle->getDockMode() == DockMode::TopRight) {
        //    pEle->rect()->top(dock.top());
        //    pEle->rect()->right( dock.right());
        //}
        //else if (pEle->getDockMode() == DockMode::TopLeft) {
        //    pEle->rect()->top(dock.top());
        //    pEle->rect()->left(dock.left());
        //}
        //else if (pEle->getDockMode() == DockMode::BottomRight) {
        //    pEle->rect()->bottom(dock.bottom());
        //    pEle->rect()->right(dock.right());
        //}
        //else if (pEle->getDockMode() == DockMode::BottomLeft) {
        //    pEle->rect()->bottom(dock.bottom());
        //    pEle->rect()->left(dock.left());
        //}








		
//////////////////////////////////////////////////////////////////////////
#pragma region UiVScrollbarThumb
std::shared_ptr<UiVScrollbarThumb> UiVScrollbarThumb::create(std::shared_ptr<UiSkin> pSkin, uDim widthPx) {
    std::shared_ptr<UiVScrollbarThumb> syb = std::make_shared<UiVScrollbarThumb>();

    syb->position() = UiPositionMode::e::Relative;
    syb->left() = "0px";
    syb->top() = "0px";
    //************************************************************************SKIN
    if (pSkin == nullptr || pSkin->_vecVScrollThumb_3P.size() != 3) {
        Gui2d::error("Invalid number of images for UI item.");
        return syb;
    }
    //**THUMB**
    uDim hR0Thumb = widthPx.autoHeight(pSkin->_vecVScrollThumb_3P[0]);
    uDim hR1Thumb = widthPx.autoHeight(pSkin->_vecVScrollThumb_3P[1]);
    uDim hR2Thumb = widthPx.autoHeight(pSkin->_vecVScrollThumb_3P[2]);

    //ROWS
    std::shared_ptr<UiGridRow> r0 = syb->addRow(1, 0, false, Gui2d::sortLayer(0));
    r0->setName("UiVScrollbarThumb-TOP_ROW");
    r0->width() = "100%";
    r0->height() = hR0Thumb;
    std::shared_ptr<UiGridRow> r1 = syb->addRow(1, 0, false, Gui2d::sortLayer(0));
    r1->setName("UiVScrollbarThumb-MID_ROW");
    r1->width() = "100%";
    r1->height() = "auto";
    std::shared_ptr<UiGridRow> r2 = syb->addRow(1, 0, false, Gui2d::sortLayer(0));
    r2->setName("UiVScrollbarThumb-BOT_ROW");
    r2->width() = "100%";
    r2->height() = hR1Thumb;
    //COLS
    std::shared_ptr<UiElement> c0 = r0->addCol(1, false, Gui2d::sortLayer(0));
    c0->setName("UiVScrollbarThumb-TOP_ROW_COL");
    c0->width() = "100%";
    c0->height() = hR0Thumb;
    std::shared_ptr<UiElement> c1 = r1->addCol(1, false, Gui2d::sortLayer(0));
    c1->setName("UiVScrollbarThumb-MID_ROW_COL");
    c1->width() = "100%";
    c1->height() = "auto";
    std::shared_ptr<UiElement> c2 = r2->addCol(1, false, Gui2d::sortLayer(0));
    c2->setName("UiVScrollbarThumb-BOT_ROW_COL");
    c2->width() = "100%";
    c2->height() = hR2Thumb;
    //IMAGSE
    std::shared_ptr<UiImage> imgTop = UiImage::create(pSkin->_vecVScrollThumb_3P[0], UiImageSizeMode::e::Expand, UiImageSizeMode::e::Expand, widthPx.px(), hR0Thumb.px());
    c0->addChild(imgTop, Gui2d::sortLayer(0));
    std::shared_ptr<UiImage> imgMid = UiImage::create(pSkin->_vecVScrollThumb_3P[1], UiImageSizeMode::e::Expand, UiImageSizeMode::e::Tile, widthPx.px(), hR1Thumb.px());
    c1->addChild(imgMid, Gui2d::sortLayer(0));
    std::shared_ptr<UiImage> imgBot = UiImage::create(pSkin->_vecVScrollThumb_3P[2], UiImageSizeMode::e::Expand, UiImageSizeMode::e::Expand, widthPx.px(), hR2Thumb.px());
    c2->addChild(imgBot, Gui2d::sortLayer(0));
    //************************************************************************SKIN

    std::weak_ptr<UiVScrollbarThumb> wp = syb;
    UiDragInfo::DragFunc scrubFunc = [wp](vec2& dxy) {
        if (std::shared_ptr<UiVScrollbarThumb> sb = wp.lock()) {
            sb->_fBarTopY += dxy.y;
            sb->setLayoutChanged();
        }
    };
    syb->enableDrag(scrubFunc);

    return syb;
}
void UiVScrollbarThumb::init() {
    UiGrid::init();
}
void UiVScrollbarThumb::update(std::shared_ptr<Fingers> pFingers) {
    UiGrid::update(pFingers);

    float fMaxHeight = 1.0f;
    float pt = 0.0f;
    float pb = 1.0f;
    if (getParent() != nullptr) {
        pb = getParent()->getComputedQuad().bottom();
        pt = getParent()->getComputedQuad().top();
    }
    fMaxHeight = pb - pt;
    float fBarHeight = fMaxHeight * _fBarSizePct;

    top() = uDim(_fBarTopY, UiDimUnit::e::Pixel);

    if (top().px() + fBarHeight > fMaxHeight) {
        //Scrolled past bottom
        top() = uDim(fMaxHeight - fBarHeight, UiDimUnit::e::Pixel);
    }
    if (top().px() < 0) {
        //Scrollbar is too big for container
        top() = "0px";

    }
    if (top().px() + fBarHeight > fMaxHeight) {
        //Scrollbar is too big for container
        fBarHeight = fMaxHeight;
    }

    //Set final height
    height() = uDim(fBarHeight, UiDimUnit::e::Pixel);

    //Send this value to the window'        
    float fTop = top().px();
    float diff = (fMaxHeight - fBarHeight);
    if (diff != 0) {
        _fScrollPct = fTop / diff;
    }
    else {
        _fScrollPct = 0.0f;
    }
}
void UiVScrollbarThumb::performLayout() {
    UiGrid::performLayout();
}
void UiVScrollbarThumb::setBarSizePct(float pos01) {
    if (pos01 < 0.0f || pos01 > 1.0f) {
        pos01 = MathUtils::broClamp(pos01, 0.0f, 1.0f);
        Gui2d::error("invalid scroll position sent to scrollbar, clamping");
    }
    _fBarSizePct = pos01;
}
float UiVScrollbarThumb::getScrollPct() {
    return _fScrollPct;
}
#pragma endregion
#pragma region UiVScrollbar
std::shared_ptr<UiVScrollbar> UiVScrollbar::create(std::shared_ptr<UiSkin> pSkin, uDim widthPx, std::shared_ptr<UiElement> containerObject) {
    std::shared_ptr<UiVScrollbar> sb = std::make_shared<UiVScrollbar>();

    if (pSkin == nullptr || pSkin->_vecVScrollBack_3P.size() != 3) {
        Gui2d::error("Scrollbar didn't have 3 images");
        return sb;
    }
    sb->setName("UiVScrollbar");

    sb->_pContainerObject = containerObject;

    sb->init();
    uDim hR0 = widthPx.autoHeight(pSkin->_vecVScrollBack_3P[0]);
    uDim hR1 = widthPx.autoHeight(pSkin->_vecVScrollBack_3P[1]);
    uDim hR2 = widthPx.autoHeight(pSkin->_vecVScrollBack_3P[2]);

    sb->width() = widthPx;
    sb->height() = "auto";

    uint32_t iBackSort = Gui2d::sortLayer(0);
    uint32_t iThumbSort = Gui2d::sortLayer(1);

    //ROWS
    std::shared_ptr<UiGridRow> r0 = sb->addRow(1, 0, false, iBackSort);
    r0->setName("UiVScrollbar-BACK-TOP_ROW");
    r0->width() = "100%";
    r0->height() = hR0;
    std::shared_ptr<UiGridRow> r1 = sb->addRow(1, 0, false, iBackSort);
    r1->setName("UiVScrollbar-BACK-MID_ROW");
    r1->width() = "100%";
    r1->height() = "auto";
    std::shared_ptr<UiGridRow> r2 = sb->addRow(1, 0, false, iBackSort);
    r2->setName("UiVScrollbar-BACK-BOT_ROW");
    r2->width() = "100%";
    r2->height() = hR2;
    //COLS
    std::shared_ptr<UiElement> c0 = r0->addCol(1, false, iBackSort);
    c0->setName("UiVScrollbar-BACK-TOP_ROW_COL");
    c0->width() = "100%";
    c0->height() = hR0;
    std::shared_ptr<UiElement> c1 = r1->addCol(1, false, iBackSort);
    c1->setName("UiVScrollbar-BACK-MID_ROW_COL");
    c1->width() = "100%";
    c1->height() = "auto";
    std::shared_ptr<UiElement> c2 = r2->addCol(1, false, iBackSort);
    c2->setName("UiVScrollbar-BACK-BOT_ROW_COL");
    c2->width() = "100%";
    c2->height() = hR2;
    //IMAGSE
    std::shared_ptr<UiImage> imgTop = UiImage::create(pSkin->_vecVScrollBack_3P[0], UiImageSizeMode::e::Expand, UiImageSizeMode::e::Expand, widthPx.px(), hR0.px());
    c0->addChild(imgTop, Gui2d::sortLayer(0));
    std::shared_ptr<UiImage> imgMid = UiImage::create(pSkin->_vecVScrollBack_3P[1], UiImageSizeMode::e::Expand, UiImageSizeMode::e::Tile, widthPx.px(), hR1.px());
    c1->addChild(imgMid, Gui2d::sortLayer(0));
    std::shared_ptr<UiImage> imgBot = UiImage::create(pSkin->_vecVScrollBack_3P[2], UiImageSizeMode::e::Expand, UiImageSizeMode::e::Expand, widthPx.px(), hR2.px());
    c2->addChild(imgBot, Gui2d::sortLayer(0));



    sb->_pThumb = UiVScrollbarThumb::create(pSkin, widthPx);
    sb->addChild(sb->_pThumb, iThumbSort);

    return sb;
}
void UiVScrollbar::init() {
    UiGrid::init();
}
void UiVScrollbar::performLayout() {
    UiGrid::performLayout();
}
void UiVScrollbar::update(std::shared_ptr<Fingers> pFingers) {
    UiGrid::update(pFingers);

    if (getContainerObject() == nullptr) {
        //For the Gen Scrollbar this won't e a problem, it's probably a trackbar
        Gui2d::error("Container object for scrollbar wasn't set.");
        return;
    }
    //#1 set bar size
    std::shared_ptr<UiElement> ccParent = getContainerObject()->getParent();
    Box2f b1 = ccParent->getComputedQuad();//9Grid column
    Box2f b2 = getContainerObject()->getContentQuad();
    if (b2.height() > 0) {
        float fBarSize = 0;
        fBarSize = b1.height() / (b2.height());

        fBarSize = MathUtils::broClamp(fBarSize, 0.0f, 1.0f);
        setBarSizePct(fBarSize);
    }

    //#2 Update window contents offset
    float pct = _pThumb->getScrollPct();
    float ccHeight = getContainerObject()->getContentQuad().height();

    if (getCanScrollPastEof() == false) {
        float ph = getContainerObject()->getParent()->getComputedQuad().height();
        ccHeight -= ph;
    }

    float ccHeightPct = ccHeight * pct;
    getContainerObject()->top() = -ccHeightPct;
    getContainerObject()->height() = uDim(getContainerObject()->getContentQuad().height(), UiDimUnit::e::Pixel);

}
void UiVScrollbar::setBarSizePct(float pos01) {
    _pThumb->setBarSizePct(pos01);
}

#pragma endregion


class UiVScrollbarThumb : public UiGrid {
    float _fBarTopY = 0;
    float _fBarSizePct = 0.0f;  //the ratio of width to height
    float _fScrollPct = 0.0f;  //the ratio of width to height
public:
    static std::shared_ptr<UiVScrollbarThumb> create(std::shared_ptr<UiSkin> pSkin, uDim widthPx);
    UiVScrollbarThumb() { }
    virtual ~UiVScrollbarThumb() override { }
    virtual void init() override;
    virtual void performLayout() override;
    void setBarSizePct(float pos01);
    float getScrollPct();
    virtual void update(std::shared_ptr<Fingers> pFingers) override;
};
class UiVScrollbar : public UiGrid {
    std::shared_ptr<UiVScrollbarThumb> _pThumb = nullptr;
    std::shared_ptr<UiElement> _pContainerObject = nullptr;

    bool _bCanScrollPastEof = false;
    std::shared_ptr<UiElement> getContainerObject() { return _pContainerObject; }
    void setBarSizePct(float pos01);


public:
    static std::shared_ptr<UiVScrollbar> create(std::shared_ptr<UiSkin> pSkin, uDim widthPx, std::shared_ptr<UiElement> controlObject);
    UiVScrollbar() { }
    virtual ~UiVScrollbar() override { }
    virtual void init() override;
    virtual void update(std::shared_ptr<Fingers> pFingers ) override;
    virtual void performLayout() override;
    bool getCanScrollPastEof() { return _bCanScrollPastEof; }
};



//#include "../base/Hash.h"
//#include "../base/GLContext.h"
//#include "../base/Fingers.h"
//#include "../display/TextBoss.h"
//#include "../display/Viewport.h"
//#include "../display/Atlas.h"
//#include "../display/Texture2DSpec.h"
//#include "../display/TexCache.h"
//#include "../model/MeshNode.h"
//#include "../bottle/WorldObject.h"
//#include "../bottle/CongaGui.h"
//#include "../bottle/Motion25Bucket.h"
//#include "../bottle/World25.h"
//#include "../bottle/WorldCell.h"
//#include "../bottle/WorldGrid.h"
//#include "../bottle/CongaRoom.h"
//#include "../bottle/CongaUtils.h"
//#include "../bottle/WorldObject.h"
//#include "../bottle/Tile25Spec.h"
//
//#define MA_P(x) cr->makeAssetPath("ui", x)
//
//namespace Game {
//#pragma region EditButton
//EditButton::EditButton(std::shared_ptr<Gui2d> g, std::shared_ptr<EditButtonGroup> pGroup, float wpct) : Widget(g), _pGroup(pGroup), _wpct(wpct) {
//}
//EditButton::~EditButton() {
//}
//std::shared_ptr<Texture2DSpec> EditButton::setTx(size_t i) {
//    AssertOrThrow2(i < _vecTextures.size());
//    setTexture(_vecTextures[i]);
//    return _vecTextures[i];
//}
//void EditButton::erect_self(float x, float y, float& outW, float& outH) {
//    float width, height;
//    width = _pGroup->getContext()->getViewport()->pctW(_wpct);
//    height = width * getTxWh();
//
//    setQuad(x, y, width, height);
//    setTexture(getUpTx());
//
//    setVisible(true);
//
//    outW = width;
//    outH = height;
//}
////void EditButton::updateState(ButtonState::e bs) {
////    _eState = bs;
////    if (getMode() == EditButtonMode::e::Press) {
////        if (_eState == ButtonState::Press || _eState == ButtonState::Down) {
////            getMesh()->setTexture(getDownTx());
////        }
////        else {
////            getMesh()->setTexture(getUpTx());
////        }
////    }
////    else if (getMode() == EditButtonMode::e::Toggle) {
////        AssertOrThrow2(0);
////
////    }
////}
//
//#pragma endregion
//
//#pragma region EditButtonGroup
//EditButtonGroup::EditButtonGroup(std::shared_ptr<CongaGui> pGui, std::shared_ptr<GLContext> pContext, t_string name) : _pContext(pContext), _strName(name), _pGui(pGui) {
//
//}
//EditButtonGroup::~EditButtonGroup(){
//
//}
//void EditButtonGroup::setVisible(bool b){
//    _bVisible = b;
//}
//
//void EditButtonGroup::initSel() {
//    //Initialize the selection of the GUI control
//    AssertOrThrow2(_vecButtons.size() > 0);
//    _pSelected = _vecButtons[0];
//    erect();
//    de_erect(_pSelected);
//
//    if(_vecButtons.size() > 0){
//        //Press the first edit button int he group to select it.
//        std::shared_ptr<EditButton> first = _vecButtons[0];
//        first->doPress(ButtonState::Press, nullptr);
//        first->doPress(ButtonState::Down, nullptr);
//        first->doRelease(ButtonState::Release, nullptr);
//        first->doRelease(ButtonState::Up, nullptr);
//    }
//
//}
//void EditButtonGroup::erect() {
//    //Splays all menu items out when a player clicks on the "selected" item.
//    float fx = getContext()->getViewport()->pctW(_xpct);
//    float fy = getContext()->getViewport()->pctH(_ypct);
//    float dfx = getContext()->getViewport()->pctW(0.5);
//
//    //For tiles we have a "dfy"
//    float dfy = getContext()->getViewport()->pctH(0.5);
//    
//    int tilesX = 0;
//    int tilesX_Max = 10;
//    float rowHeight = 0;
//    
//    _fMaxHeightPixels = _fMaxWidthPixels = -1;
//    float butW, butH;
//
//    float baseFx = 0;
//    if(getSelected()){
//        getSelected()->erect_self(fx, fy, butW, butH);
//        if (butW > _fMaxWidthPixels) { _fMaxWidthPixels = butW; }
//        if (butH > _fMaxHeightPixels) { _fMaxHeightPixels = butH; }
//        fx += butW;
//        fx += dfx;
//
//        baseFx = fx;
//    }
//
//    for(std::shared_ptr<EditButton> eb : _vecButtons) {
//        
//        if(eb == getSelected()) {
//            continue;
//        }
//
//        eb->erect_self(fx, fy, butW, butH);
//
//        //Store w/h of this "group" so that we can place other groups below.
//        if(butW > _fMaxWidthPixels) { _fMaxWidthPixels = butW; }
//        if(butH > _fMaxHeightPixels) { _fMaxHeightPixels = butH; }
//
//        fx += butW;
//        fx += dfx;
//
//        if(butH > rowHeight){
//            rowHeight = butH;
//        }
//
//        tilesX++;
//
//        if(tilesX >= tilesX_Max) {
//            fx = baseFx;
//            tilesX = 0;
//            fy += rowHeight;
//            fy += dfy;
//            rowHeight = 0;
//        }
//    }
//
//    _pGui->setInputCaptured(true);
//}
//void EditButtonGroup::de_erect(std::shared_ptr<EditButton> eb) {
//    for (std::shared_ptr<EditButton> eb : _vecButtons) {
//        eb->setVisible(false);
//    }
//    if (getVisible()) {
//        _pSelected = eb;
//        if(_pSelected != nullptr){
//            _pSelected->setVisible(true);
//            float fx = getContext()->getViewport()->pctW(_xpct);
//            float fy = getContext()->getViewport()->pctH(_ypct);
//            float outw, outh;
//            _pSelected->erect_self(fx, fy, outw, outh);
//        }
//    }
//    else {
//   /*     for (std::shared_ptr<EditButton> eb : _vecButtons) {
//            eb->setVisible(false);
//        }*/
//    }
//    _pGui->setInputCaptured(false);
//}
//void EditButtonGroup::calcMaxHeight(){
//    erect();
//    de_erect(getSelected());
//}
//void EditButtonGroup::show(){
//    setVisible(true);
//    de_erect(getSelected());
//}
//void EditButtonGroup::hide(){
//    setVisible(false);
//    for (std::shared_ptr<EditButton> eb : _vecButtons) {
//        eb->setVisible(false);
//    }
//
//}
//#pragma endregion
//
//#pragma region CongaGui
//CongaGui::CongaGui(std::shared_ptr<GLContext> pc, std::shared_ptr<Motion25Bucket> bucket, std::map<Hash32, WorldObjectSpec*>& specs, std::shared_ptr<World25> pw) :
//    Gui2d(pc), _pBucket(bucket), _pWorld25(pw) {
//
//}
//CongaGui::~CongaGui()
//{
//    //**Do not delete widgets - they're automatically detled.
//    //for (size_t iGroup = 0; iGroup < _vecEditButtonGroups.size(); ++iGroup) {
//    //    DEL_MEM(_vecEditButtonGroups[iGroup]);
//    //}
//    _vecEditButtonGroups.clear();
//}
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//void CongaGui::init(){
//    buildEditButtons();
//  //  buildTiles(specs);
//    Gui2d::init();
//
//    //Initially select all buttons
//    //for (std::shared_ptr<EditButtonGroup> ebg : _vecEditButtonGroups) {
//    //    ebg->initSel();
//    //}
//
//   // setEditMode(EditMode::e::Object);
//}
//void CongaGui::buildGameWidgets(){
//    std::shared_ptr<Widget> pw = std::make_shared<Widget>(getThis<Gui2d>());
//    std::shared_ptr<CongaRoom> cr = std::dynamic_pointer_cast<CongaRoom>(getContext()->getRoom());
//
//    float xpct = 1;
//    float ypct = 90;
//    float wpct = 9;
//    float hpct = 10;
//
//    float xi = getContext()->getViewport()->pctW(xpct);
//    float yi = getContext()->getViewport()->pctH(ypct);
//    float wi = getContext()->getViewport()->pctW(wpct);
//    float hi = getContext()->getViewport()->pctH(hpct);
//
//    pw->init();
//
//    pw->setQuad(xi, yi, wi, hi);
//    t_string imgPath = cr->makeAssetPath("ui-torch.png");
//    std::shared_ptr<Texture2DSpec> tex2d = getContext()->getTexCache()->getOrLoad(imgPath);
//    pw->setTexture(tex2d);
//    
//    std::shared_ptr<CongaGui> that = getThis<CongaGui>();
//    pw->setPress([that](ButtonState::e b, void* p) {
//    });
//    pw->setRelease([that](ButtonState::e b, void* p) {
//    });
//
//    addWidget(pw);
//    _vecGameWidgets.push_back(pw);
//}
//void CongaGui::buildEditButtons() {
//    std::shared_ptr<CongaRoom> cr = std::dynamic_pointer_cast<CongaRoom>(getContext()->getRoom());
//
//
//    float buttonWidth = 6;
//   // float dx = 2;
//   // float dy = 94;
//   // float tbw = 8;
//    std::shared_ptr<EditButton> eb;
//    std::shared_ptr<CongaGui> that = getThis<CongaGui>();
//    std::function<void(ButtonState::e, void*)> blank_fn = [](ButtonState::e, void*){};
//
//    //Create group
//    _pModeGroup = std::make_shared<EditButtonGroup>(getThis<CongaGui>(), getContext(), "Mode");
//    {
//        _vecEditButtonGroups.push_back(_pModeGroup);
//        eb = buildEditButtonDef(_pModeGroup, MA_P("ic-object-up.png"), MA_P("ic-object-dn.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditMode(EditMode::e::Object); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pModeGroup, MA_P("ic-tile-up.png"), MA_P("ic-tile-dn.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditMode(EditMode::e::Tile);  },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pModeGroup, MA_P("ic-block-up.png"), MA_P("ic-block-dn.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditMode(EditMode::e::Block); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pModeGroup, MA_P("ic-vertex.png"), MA_P("ic-vertex.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditMode(EditMode::e::Vertex); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pModeGroup, MA_P("ic-vertex-group.png"), MA_P("ic-vertex-group.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditMode(EditMode::e::VertexGroup); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pModeGroup, MA_P("ic-tile-edit.png"), MA_P("ic-tile-edit.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditMode(EditMode::e::VertexGroup);},
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pModeGroup, MA_P("ic-select-up.png"), MA_P("ic-select-dn.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditMode(EditMode::e::Select);  },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pModeGroup, MA_P("ui-delete-all-chars-up.png"), MA_P("ui-delete-all-chars-dn.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditMode(EditMode::e::DelChars); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pModeGroup, MA_P("ic-proc.png"), MA_P("ic-proc.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditMode(EditMode::e::Proc); },
//            std::move(blank_fn)
//        );
//    }
//
//    // Tools (modifier)
//    _pToolGroup = std::make_shared<EditButtonGroup>(getThis<CongaGui>(), getContext(), "Tool");
//    {
//        _vecEditButtonGroups.push_back(_pToolGroup);
//        eb = buildEditButtonDef(_pToolGroup, MA_P("ic-pencil.png"), MA_P("ic-pencil-sel.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditTool(EditTool::e::Pencil); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pToolGroup, MA_P("ic-eraser.png"), MA_P("ic-eraser-sel.png"), 
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setEditTool(EditTool::e::Eraser); },
//            std::move(blank_fn)
//        );
//
//    }
//
//    //Undo
//    _pUndoGroup = std::make_shared<EditButtonGroup>(getThis<CongaGui>(), getContext(), "Undo");
//    {
//        _vecEditButtonGroups.push_back(_pUndoGroup);
//        // Etc buttons
//        eb = buildEditButtonDef(_pUndoGroup, MA_P("ic-undo.png"), MA_P("ic-undo.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setUndoPressed(); },
//            std::move(blank_fn)
//        );
//    }
//
//    //Block Modifier
//    _pBlockModifierGroup = std::make_shared<EditButtonGroup>(getThis<CongaGui>(), getContext(), "Block");
//    {
//        _vecEditButtonGroups.push_back(_pBlockModifierGroup);
//
//        eb = buildEditButtonDef(_pBlockModifierGroup, MA_P("ic-single.png"), MA_P("ic-single.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setBlockMode(BlockMode::e::Single); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pBlockModifierGroup, MA_P("ic-paint.png"), MA_P("ic-paint.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setBlockMode(BlockMode::e::Paint); },
//            std::move(blank_fn)
//        );
//    }
//
//    //Region 
//    _pRegionGroup = std::make_shared<EditButtonGroup>(getThis<CongaGui>(), getContext(), "Region");
//    {
//        _vecEditButtonGroups.push_back(_pRegionGroup);
//
//        eb = buildEditButtonDef(_pRegionGroup, MA_P("ic-1x1.png"), MA_P("ic-1x1.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setRegionSize(RegionSize::e::Region_1x1); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pRegionGroup, MA_P("ic-2x2.png"), MA_P("ic-2x2.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setRegionSize(RegionSize::e::Region_2x2); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pRegionGroup, MA_P("ic-4x4.png"), MA_P("ic-4x4.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setRegionSize(RegionSize::e::Region_4x4); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pRegionGroup, MA_P("ic-8x8.png"), MA_P("ic-8x8.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setRegionSize(RegionSize::e::Region_8x8); },
//            std::move(blank_fn)
//        );
//    }
//    //Region 
//    _pProcModeGroup = std::make_shared<EditButtonGroup>(getThis<CongaGui>(), getContext(), "Proc");
//    {
//        _vecEditButtonGroups.push_back(_pProcModeGroup);
//        eb = buildEditButtonDef(_pProcModeGroup, MA_P("ic-block-g.png"), MA_P("ic-block-g.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setProcMode(ProcMode::e::Block); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pProcModeGroup, MA_P("ic-hills.png"), MA_P("ic-hills.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setProcMode(ProcMode::e::Hills); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pProcModeGroup, MA_P("ic-slab.png"), MA_P("ic-slab.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setProcMode(ProcMode::e::Slab); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pProcModeGroup, MA_P("ic-random-pt.png"), MA_P("ic-random-pt.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setProcMode(ProcMode::e::Random); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pProcModeGroup, MA_P("ic-clear.png"), MA_P("ic-clear.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setProcMode(ProcMode::e::Clear); },
//            std::move(blank_fn)
//        );
//    }
//
//
//    _pMatterGroup = std::make_shared<EditButtonGroup>(getThis<CongaGui>(), getContext(), "Matter");
//    {
//        _vecEditButtonGroups.push_back(_pMatterGroup);
//        eb = buildEditButtonDef(_pMatterGroup, MA_P("ic-solid.png"), MA_P("ic-solid.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setMatterMode(MatterMode::e::Solid); },
//            std::move(blank_fn)
//        );
//        eb = buildEditButtonDef(_pMatterGroup, MA_P("ic-liquid.png"), MA_P("ic-liquid.png"),
//            buttonWidth,
//            [eb, that](ButtonState::e b, void* p) { that->setMatterMode(MatterMode::e::Liquid); },
//            std::move(blank_fn)
//        );
//    }
//
//    //std::shared_ptr<Widget> test = new Widget(this);
//    //test->setTexture(getContext()->getTexCache()->getOrLoad(MA_P("ic-liquid.png")));
//    //test->setQuad(0, 0, 400, 225);
//    //test->setVisible(true);
//    //addWidget(test);
//
//}
//std::shared_ptr<EditButton> CongaGui::buildEditButtonDef(
//    std::shared_ptr<EditButtonGroup> ebg, t_string txUp, t_string txDown, float wpct, 
//    std::function<void(ButtonState::e, void*)>&& vdn, 
//    std::function<void(ButtonState::e, void*)>&& vup
//) {
//    std::shared_ptr<EditButton> eb;
//    std::vector<t_string> txs;
//    txs.push_back(txUp);
//    txs.push_back(txDown);
//
//    eb = buildEditButtonDef3(ebg, txs, wpct, std::move(vdn), std::move(vup), nullptr, nullptr);
//
//    return eb;
//}
//std::shared_ptr<EditButton> CongaGui::buildEditButtonDef3(
//    std::shared_ptr<EditButtonGroup> ebg, std::vector<t_string>& txs, float wpct,
//    std::function<void(ButtonState::e, void*)>&& vdn,
//    std::function<void(ButtonState::e, void*)>&& vup,
//    Motion25Spec* pTileSpec, WorldObjectSpec* pPixObjSpec
//) {
//
//    std::vector<std::shared_ptr<Texture2DSpec>> txsp;
//    for (size_t txi = 0; txi<txs.size(); ++txi) {
//        std::shared_ptr<Texture2DSpec> tx = getContext()->getTexCache()->getOrLoad(txs[txi]);
//        txsp.push_back(tx);
//    }
//
//    return buildEditButtonDef2(ebg, txsp, wpct, std::move(vdn), std::move(vup), pTileSpec, pPixObjSpec);
//}
//std::shared_ptr<EditButton> CongaGui::buildEditButtonDef2(
//    std::shared_ptr<EditButtonGroup> ebg, std::vector<std::shared_ptr<Texture2DSpec>>& txs, float wpct,
//    std::function<void(ButtonState::e, void*)>&& vdn,
//    std::function<void(ButtonState::e, void*)>&& vup,
//    Motion25Spec* pTileSpec, WorldObjectSpec* pPixObjSpec
//) {
//    std::shared_ptr<EditButton> eb;
//
//    eb = buildEditButton(ebg, txs, wpct, pTileSpec, pPixObjSpec);
//    eb->setMode(EditButtonMode::e::Press);
//
//    std::shared_ptr<CongaGui> that = getThis<CongaGui>();
//    std::function<void(ButtonState::e, void*)> vpress = [eb, that, vup, vdn](ButtonState::e b, void* p) {
//        eb->getGroup()->erect();
//    };
//    std::function<void(ButtonState::e, void*)> vrelease = [eb, that, vdn](ButtonState::e b, void* p) {
//        eb->getGroup()->de_erect(eb);
//        vdn(b, p);
//    };
//
//    eb->setPress(vpress);
//    eb->setRelease(vrelease);
//
//    return eb;
//}
//std::shared_ptr<EditButton> CongaGui::buildEditButton(std::shared_ptr<EditButtonGroup> ebg, std::vector<std::shared_ptr<Texture2DSpec>>& txs, float wpct,
//    Motion25Spec* pTileSpec, WorldObjectSpec* pPixObjSpec )
//{
//    std::shared_ptr<EditButton> eb = std::make_shared<EditButton>(getThis<Gui2d>(), ebg, wpct);
//    eb->init();
//
//    eb->setObjSpec(pPixObjSpec);
//    eb->setTileSpec(pTileSpec);
//
//    float txw = -1, txh = -1;
//    for(size_t txi=0; txi<txs.size(); ++txi) {
//        std::shared_ptr<Texture2DSpec> tx = txs[txi]; //
//        
//        //Make all textures linear.
//        tx->oglSetFilter(TexFilter::e::Linear);
//        tx->bind(TextureChannel::e::Channel0, nullptr);
//        eb->addTexture(tx);
//
//        if(txw != -1) { 
//            if(txw != (float)tx->getWidth()){
//                BroLogWarn("Gui: Warning button has different texture sizes.");
//            }
//        }
//        if (txh != -1) {
//            if (txh != (float)tx->getHeight()) {
//                BroLogWarn("Gui: Warning button has different texture sizes.");
//            }
//        }
//
//        txw = (float)tx->getWidth();
//        txh = (float)tx->getHeight();
//    }
//    
//    float wi = getContext()->getViewport()->pctW(wpct);
//    float hi = wi * (txw / txh);
//    eb->setTxWh(txw / txh);
//
//    eb->setQuad(0, 0, wi, hi);
//    eb->setTexture(eb->getUpTx());
//
//    eb->setVisible(false);
//    if(ebg!=nullptr){
//        ebg->addButton(eb);
//    }
//
//    addWidget(eb);
//
//    return eb;
//}
//void CongaGui::buildTiles(std::map<Hash32, WorldObjectSpec*>& specs) {    
//    float tileWPct = 6;
//    std::shared_ptr<EditButton> eb;
//    std::shared_ptr<CongaGui> that = getThis<CongaGui>();
//    std::function<void(ButtonState::e, void*)> blank_fn = [](ButtonState::e, void*) {};
//
//    //Solid dTiles
//    _pBaseTileGroup = std::make_shared<EditButtonGroup>(getThis<CongaGui>(), getContext(), "Solid Tile");
//    {
//        _vecEditButtonGroups.push_back(_pBaseTileGroup);
//
//        //for (std::pair<uint8_t, Tile25Spec*> p : _pBucket->getTileSpecs()){
//        //    Tile25Spec* pt = p.second;
//        //    if(pt->getMatterMode() == MatterMode::e::Solid){
//        //        Motion25Spec* ms = pt->getTop()->getSpec();
//        //        std::vector<t_string> txs;
//        //        txs.push_back(ms->getFirstFrameFileName());
//        //        eb = buildEditButtonDef3(_pBaseTileGroup, txs, tileWPct,
//        //            [eb, that, ms, pt](ButtonState::e b, void* p) { that->setSelectedBaseTile(pt->getTileIndex()); },
//        //            std::move(blank_fn),
//        //            ms, nullptr
//        //        );
//        //    }
//        //}
//    }
//    //Liquid tiles
//    _pLiquidTileGroup = std::make_shared<EditButtonGroup>(getThis<CongaGui>(), getContext(), "Liquid Tile");
//    {
//        _vecEditButtonGroups.push_back(_pLiquidTileGroup);
//
//        //for (std::pair<uint8_t, Tile25Spec*> p : _pBucket->getTileSpecs()) {
//        //    Tile25Spec* pt = p.second;
//        //    if (pt->getMatterMode() == MatterMode::e::Liquid) {
//        //        Motion25Spec* ms = pt->getTop()->getSpec();
//        //        AssertOrThrow2(ms->getFrames().size() > 0);
//        //        Motion25Frame* pFrame = ms->getFrames()[0];
//
//        //        if(pFrame->getGenerated() == nullptr){
//        //            std::vector<t_string> txs;
//        //            txs.push_back(pFrame->getImageName());
//        //            eb = buildEditButtonDef3(_pLiquidTileGroup, txs, tileWPct,
//        //                [eb, that, ms, pt](ButtonState::e b, void* p) { that->setSelectedLiquidTile(pt->getTileIndex()); },
//        //                std::move(blank_fn),
//        //                ms, nullptr
//        //            );
//        //        }
//        //        else {
//        //            std::vector<std::shared_ptr<Texture2DSpec>> txs;
//        //            std::shared_ptr<Texture2DSpec> ptex = getContext()->getTexCache()->addAsGeneratedImage(pFrame->getImageName(), pFrame->getGenerated());
//
//        //            txs.push_back(ptex);
//        //            eb = buildEditButtonDef2(_pLiquidTileGroup, txs, tileWPct,
//        //                [eb, that, ms, pt](ButtonState::e b, void* p) { that->setSelectedLiquidTile(pt->getTileIndex()); },
//        //                std::move(blank_fn),
//        //                ms, nullptr
//        //            );
//        //        }
//        //    }
//        //}
//    }
//    //Objs
//    //_pObjTileGroup = new EditButtonGroup(this, getContext(), "Object");
//    //{
//    //    _vecEditButtonGroups.push_back(_pObjTileGroup);
//
//    //    for (std::map<Hash32,WorldObjectSpec*>::iterator it = specs.begin(); it!=specs.end(); it++){
//    //        WorldObjectSpec* ps = it->second;;
//    //        
//    //        if(ps->getDrawType() == DrawType::e::Model){
//    //            //Rendering makes no sense sinc we're going to show it in 3d anyway
//    //        }
//    //        else {
//    //            //So here we have a few options
//    //            //1 - save the bpy render as an PNG image (automatically from the script) and load it as an icon!
//    //            AssertOrThrow2(ps->_pBaseMotion);
//    //            std::vector<t_string> txs;
//    //            txs.push_back(ps->_pBaseMotion->getFirstFrameFileName());
//
//    //            eb = buildEditButtonDef3(_pObjTileGroup, txs, tileWPct,
//    //                [eb, that, ps](ButtonState::e b, void* p) { that->setSelectedSpec(ps); },
//    //                std::move(blank_fn),
//    //                nullptr, ps
//    //            );
//    //        }
//    //    }
//    //}
//
//}
////TileButton* CongaGui::createTileButton(Motion25Spec* pTileSpec, PixObjSpec* pPixObjSpec, std::shared_ptr<EditButtonGroup> pGroup) {
////    TileButton* tb = new TileButton(this, pGroup);
////    Hash32 frame = 0;
////
////
////
////    tb->init();
////    //Initially set the quad here - we change this later.
////    tb->setQuad(0, 0, 32, 32);
////
////    CongaRoom* croom = static_cast<CongaRoom*>(getContext()->getRoom());
////
////    //Get tex coords
////    std::shared_ptr<Atlas> pa = croom->getWorld25()->getWorldAtlas();
////    vec2 bl, br, tl, tr;
////    pa->getTCoords(frame, &bl, &br, &tl, &tr);
////    tb->setTexQuad(bl, tr);
////    tb->getMesh()->setTexture(pa);
////
////    std::shared_ptr<CongaGui> that = this;
////
////    tb->setPress([tb, that](ButtonState::e b, void* p) {
////        that->setSelectedTile(tb);
////    });
////    tb->setRelease([tb, that](ButtonState::e b, void* p) {
////        //that->setSelectedTile(b);
////    });
////
////    tb->setVisible(false);
////
////    addWidget(tb);
////
////    return tb;
////}
//
//
//void CongaGui::draw(RenderParams&& rp) {
//    updateUi();
//
//    Gui2d::draw(std::move(rp));
//}
//void CongaGui::updateUi() {
//    if (_eGameMode == GameMode::e::Play) {
//    }
//    else if (_eGameMode == GameMode::e::Edit) {
//        drawEditText();
//    }
//}
//void CongaGui::gameModeChanged(GameMode::e eMode){
//    _eGameMode = eMode;
//
//    //Refresht he buttons and shit
//    editModeChanged();
//
//    if (eMode == GameMode::e::Play) {
//        for (size_t i = 0; i < _vecEditButtonGroups.size(); ++i) {
//            _vecEditButtonGroups[i]->hide();
//        }
//        for (size_t iw = 0; iw<_vecGameWidgets.size(); ++iw) {
//            _vecGameWidgets[iw]->setVisible(true);
//        }
//    }
//    else if (eMode == GameMode::e::Edit) {
//        for (size_t i = 0; i < _vecEditButtonGroups.size(); ++i) {
//            _vecEditButtonGroups[i]->show();
//        }
//        for (size_t iw = 0; iw<_vecGameWidgets.size(); ++iw) {
//            _vecGameWidgets[iw]->setVisible(false);
//        }
//        
//    }
//
//
//}
//
//W25Tile CongaGui::getSelectedTile() {
//    if(_eMatterMode == MatterMode::e::Solid){
//        return _pSelectedBaseTile;
//    }
//    else if (_eMatterMode == MatterMode::e::Liquid){
//        return _pSelectedLiquidTile;
//    }
//    else {
//        BroThrowNotImplementedException();
//    }
//
//}
//WorldObjectSpec* CongaGui::getSelectedSpec() {
//    return _pSelectedPixObj;
//}
////EditTool::e CongaGui::getEditTool() {
////    std::shared_ptr<EditButtonGroup> g = _pToolGroup;
////    for (size_t ibut = 0; ibut < g->_vecButtons.size(); ++ibut) {
////        if (g->_vecButtons[ibut]->_eState == ButtonState::Down) {
////            return (EditTool::e)g->_vecButtons[ibut]->_eToolId;
////        }
////    }
////
////    return EditTool::e::Invalid;
////}
////EditMode::e CongaGui::getEditMode() {
////    std::shared_ptr<EditButtonGroup> g = _pModeGroup;
////    for (size_t ibut = 0; ibut < g->_vecButtons.size(); ++ibut) {
////        if (g->_vecButtons[ibut]->_eState == ButtonState::Down) {
////            return (EditMode::e)g->_vecButtons[ibut]->_eToolId;
////        }
////    }
////
////    return EditMode::e::Invalid;
////}
//NodeId CongaGui::getSelectedObject() {
//    return _pSelectedObj; 
//}
//void CongaGui::setSelectedObject(NodeId ob) {
//    _pSelectedObj = ob;
//}
//NodeId CongaGui::getHoveredObject() {
//    return _pHoveredObj; 
//}
//
//
////WorldCell* CongaGui::getSelectedTile() {
////    return _pSelectedTile;
////}
////void CongaGui::setSelectedTile(WorldCell* ob) {
////    _pSelectedTile = ob;
////}
////WorldCell* CongaGui::getHoveredTile() {
////    return ;
////}
//////void CongaGui::setHoveredTile(WorldCell* ob) {
//////    _pHoveredTile = ob;
//////}
////const vec3& CongaGui::getHoveredPoint() {
////    ;
////}
//////void CongaGui::setHoveredPoint(vec3& pt) {
//////    _vHoverPt = pt;
//////}
////const vec3& CongaGui::getHoveredNormal() {
////    return ;
////}
////void CongaGui::setHoveredNormal(vec3& pt) {
////    _vHoverNorm = pt;
////}
//void CongaGui::screenHasChanged(uint32_t uiWidth, uint32_t uiHeight) {
//    //Refresh everything.
//    editModeChanged();
//}
//void CongaGui::drawEditText(){
//    //Draw edit text.
//    t_string editMode = "";
//    t_string editTool = "";
//    EditMode::e eEditMode = getEditMode();
//    EditTool::e eEditTool = getEditTool();
//
//    if (eEditMode == EditMode::e::Tile) {
//        editMode = "  Base Tile";
//    }
//    else if (eEditMode == EditMode::e::Object) {
//        editMode = "  Object";
//    }
//    else if (eEditMode == EditMode::e::Block) {
//        editMode = "  Block";
//    }
//    else if (eEditMode == EditMode::e::Select) {
//        editMode = "  Select And Move";
//    }
//    else if (eEditMode == EditMode::e::DelChars) {
//        editMode = "  Delete All Characters";
//        editTool = "  Click the world to delete all characters!";
//    }
//
//    if (eEditTool == EditTool::e::Eraser) {
//        editTool = "  Delete";
//    }
//    else if (eEditTool == EditTool::e::Pencil) {
//        editTool = "  Create";
//    }
//
//    t_string fnt = std::string("Nunito");
//    getContext()->getTextBoss()->setFontSize(24);
//    getContext()->getTextBoss()->setFont(fnt);
//    getContext()->getTextBoss()->pstrb(
//        TStr("M:", editMode, " T:", editTool),
//        (int32_t)getContext()->getViewport()->pctW(2),
//        (int32_t)getContext()->getViewport()->pctH(5));
//
//}
//
//void CongaGui::addGroupLine(std::shared_ptr<EditButtonGroup> ebg, float dy, float& baseX, float& baseY){
//    ebg->enablePos(baseX, baseY);
//    
//    float dyPct = ebg->getMaxHeightPixels() / (float)getContext()->getViewport()->getHeight();
//    dyPct *= 100;
//    baseY += dy + dyPct;
//}
//void CongaGui::editModeChanged(){
//    for(std::shared_ptr<EditButtonGroup> ebg : _vecEditButtonGroups){
//        ebg->calcMaxHeight(); // We need to have the max height before we do anything here.
//        ebg->setVisible(false);
//       ebg->hide();
//    }
//
//    float baseX = 1;
//    float baseY = 1;
//    float dx = 2;
//    float dy = 2;
//
//    //Mode is always visible.
//    addGroupLine(_pModeGroup, dy, baseX, baseY);
//
//    EditMode::e eEditMode = getEditMode();
//
//    if(eEditMode == EditMode::e::Object){
//        addGroupLine(_pToolGroup, dy, baseX, baseY);
//     //   addGroupLine(_pObjTileGroup, dy, baseX, baseY);
//    }
//    else if (eEditMode == EditMode::e::Block) {
//        addGroupLine(_pToolGroup, dy, baseX, baseY);
//        addGroupLine(_pMatterGroup, dy, baseX, baseY);
//        addTileGroups(dy, baseX, baseY);
//        addGroupLine(_pBlockModifierGroup, dy, baseX, baseY);
//    }
//    else if (eEditMode == EditMode::e::DelChars) {
//    }
//    else if (eEditMode == EditMode::e::Select) {
//    }
//    else if (eEditMode == EditMode::e::Tile) {
//        addGroupLine(_pToolGroup, dy, baseX, baseY);
//        addGroupLine(_pMatterGroup, dy, baseX, baseY);
//        addTileGroups(dy, baseX, baseY);
//        addGroupLine(_pBlockModifierGroup, dy, baseX, baseY);
//    }
//    else if (eEditMode == EditMode::e::Vertex) {
//        addGroupLine(_pToolGroup, dy, baseX, baseY);
//        addTileGroups(dy, baseX, baseY);
//        addGroupLine(_pBlockModifierGroup, dy, baseX, baseY);
//    }
//    else if (eEditMode == EditMode::e::VertexGroup) {
//        addGroupLine(_pToolGroup, dy, baseX, baseY);
//        addGroupLine(_pMatterGroup, dy, baseX, baseY);
//        addTileGroups(dy, baseX, baseY);
//        addGroupLine(_pBlockModifierGroup, dy, baseX, baseY);
//    }
//    else if (eEditMode == EditMode::e::HillTile) {
//        addGroupLine(_pToolGroup, dy, baseX, baseY);
//        addGroupLine(_pMatterGroup, dy, baseX, baseY);
//        addTileGroups(dy, baseX, baseY);
//        addGroupLine(_pBlockModifierGroup, dy, baseX, baseY);
//    }
//    else if (eEditMode == EditMode::e::Proc) {
//        addGroupLine(_pProcModeGroup, dy, baseX, baseY);
//        addGroupLine(_pRegionGroup, dy, baseX, baseY);
//    }
//    else {
//        BroThrowNotImplementedException();
//    }
//}
//void CongaGui::addTileGroups(float dy, float& baseX, float& baseY) {
//    //addGroupLine(_pMatterGroup, dy, baseX, baseY);
//    //if (getMatterMode() == MatterMode::e::Solid) {
//    //    addGroupLine(_pBaseTileGroup, dy, baseX, baseY);
//    //}
//    //else if (getMatterMode() == MatterMode::e::Liquid) {
//    //    addGroupLine(_pLiquidTileGroup, dy, baseX, baseY);
//    //}
//
//}
//bool CongaGui::updateTouch(std::shared_ptr<Fingers> pFingers){
//     bool b = Gui2d::updateTouch(pFingers);
//
//     b = b || _bInputCaptured;
//
//     return b;
//}
//void CongaGui::setHoverVertex(WorldCell* pc, vec3& normal, vec3& point, int i) {
//    _pHoveredTile = pc;
//    if(_pHoveredTile != nullptr){
//        _bIsHovering = true;
//        _vHoverNorm = normal;
//        _vHoverPt = point;
//        _iHoverVertex = i;
//
//        if (GetAsyncKeyState(VK_F9) & 0x8000) {
//            int nnn = 0;
//            nnn++;
//        }
//
//        //Box
//        Box3f* bnew = addHoverBox(pc->getBoundBoxBvh());
//        vec3 c = bnew->center();
//
//        if(i==0 || i==2 || i==4 || i==6) { bnew->_max.x = c.x; }
//        else { bnew->_min.x = c.x; }
//
//        if (i == 0 || i == 1 || i == 4 || i == 5) { bnew->_max.y = c.y; }
//        else { bnew->_min.y = c.y; }
//
//        if (i == 0 || i == 1 || i == 2 || i == 3) { bnew->_max.z = c.z; }
//        else { bnew->_min.z = c.z; }
//    }
//}
//void CongaGui::setHoverTile(WorldCell* pc, vec3& normal, vec3& point) {
//    _pHoveredTile = pc;
//    if (_pHoveredTile != nullptr) {
//        _bIsHovering = true;
//        _vHoverNorm = normal;
//        _vHoverPt = point;
//        //Box
//        addHoverBox(pc->getBoundBoxBvh());
//    }
//}
//void CongaGui::setHoverObject(std::shared_ptr<WorldObject> ob) {
//    if(ob == nullptr){
//        _pHoveredObj = NO_NODE_ID; 
//    }
//    else {
//        _bIsHovering = true;
//        _pHoveredObj = ob->getId();
//        //Box
//        addHoverBox(ob->getBoundBoxObject());
//    }
//}
//Box3f* CongaGui::addHoverBox(Box3f* b) {
//    Box3f* bNew = new Box3f();
//    *(bNew) = *(b);
//    _vecHoverBoxes.push_back(bNew);
//    return bNew;
//}
//Box3f* CongaGui::addHoverBox(Box3f b) {
//    Box3f* bNew = new Box3f();
//    *(bNew) = b;
//    _vecHoverBoxes.push_back(bNew);
//    return bNew;
//}
////void CongaGui::addHoverNode(World25Grid* pg){
////    _bIsHovering = true;
////    _vecHoveredNodes.push_back(pg->getGridPos());
////    addHoverBox(pg->getBoundBox());
////}
//void CongaGui::addHoverNode(const ivec3& n) { 
//    _bIsHovering = true;
//    _vecHoveredNodes.push_back(n);
//   
//    Box3f b;
//    b._min = _pWorld25->i3tov3Node(n);
//    b._max = b._min + vec3(CongaUtils::getNodeWidth(), CongaUtils::getNodeHeight(), CongaUtils::getNodeWidth());
//    addHoverBox(&b);
//}
//void CongaGui::clearHover() {
//    _bIsHovering = false;
//    _pHoveredObj = NO_NODE_ID;
//    _pHoveredTile = nullptr;
//    _vHoverNorm.construct(0, 0, 0);
//    _vHoverPt.construct(0, 0, 0);
//    _iHoverVertex = -1;
//    _vecHoveredNodes.clear();
//    for(size_t i=0; i<_vecHoverBoxes.size(); ++i){
//        delete _vecHoverBoxes[i];
//    }
//    _vecHoverBoxes.clear();
//}
//
//void CongaGui::setEditMode(EditMode::e em) {
//    _eEditMode = em;
//    editModeChanged();
//}
//
//
//
//
//#pragma endregion
//
//
//
//}//ns Game




///**
//*
//*    @file CongaGui.h
//*    @date March 10, 2017
//*    @author Derek Page
//*
//*     2017 
//*
//*
//*/
//#pragma once
//#ifndef __CONGAGUI_1489161669960358316_H__
//#define __CONGAGUI_1489161669960358316_H__
//
//#include "../display/Gui2d.h"
//#include "../display/ObjectButton.h"
//
//#include "../bottle/CongaHeader.h"
//
//namespace Game {
//class CongaGui;
//namespace EditButtonMode { typedef enum { Press, Toggle }e; }
//#pragma region EditButtonGroup
//
//class EditButtonGroup : public VirtualMemory {
//    bool _bDeselecting = false;
//    float _xpct, _ypct;
//    std::shared_ptr<EditButton> _pSelected = nullptr;
//    std::shared_ptr<GLContext> _pContext = nullptr;
//    bool _bVisible = true;
//    void setPct(float x, float y) { _xpct = x, _ypct = y; }
//    t_string _strName;
//    std::shared_ptr<CongaGui> _pGui = nullptr;
//    std::vector<std::shared_ptr<EditButton>> _vecButtons;
//
//    float _fMaxWidthPixels = -1;
//    float _fMaxHeightPixels = -1;
//public:
//    EditButtonGroup(std::shared_ptr<CongaGui> pGui, std::shared_ptr<GLContext> pContext, t_string name);
//    virtual ~EditButtonGroup();
//
//    void initSel();
//    void erect();
//    void de_erect(std::shared_ptr<EditButton> eb);
//    void calcMaxHeight();
//    std::shared_ptr<GLContext> getContext() { return _pContext; }
//    float getMaxWidthPixels() { return _fMaxWidthPixels; }
//    float getMaxHeightPixels() { return _fMaxHeightPixels; }
//
//    void enablePos(float x, float y) { 
//        setPct(x, y);
//        setVisible(true);
//        de_erect(getSelected());
//    }
//    void setXPct(float f) { _xpct = f; }
//    void setYPct(float f) { _ypct = f; }
//    bool getVisible() { return _bVisible; }
//    void setVisible(bool b);
//
//    std::shared_ptr<EditButton> getSelected() { return _pSelected; }
//
//    void addButton(std::shared_ptr<EditButton> eb){ _vecButtons.push_back(eb); }
//
//    void show();
//    void hide();
//};
//#pragma endregion
//#pragma region EditButton
//class EditButton: public Widget {
//    ButtonState::e _eState = ButtonState::e::Up;
//    std::shared_ptr<EditButtonGroup> _pGroup = nullptr;
//    EditButtonMode::e _eMode = EditButtonMode::e::Press;
//
//    std::vector<std::shared_ptr<Texture2DSpec>> _vecTextures;
//
//    Motion25Spec* _pMotionSpec = nullptr;
//    WorldObjectSpec* _pPixObjSpec = nullptr;
//
//    float _wpct;
//    float _fTxWh;
//public:
//
//    EditButton(std::shared_ptr<Gui2d> g, std::shared_ptr<EditButtonGroup> pGroup, float wpct);
//    virtual ~EditButton() override;
//
//  //  WorldObjectSpec* getPixObjSpec() { return _pPixObjSpec; }
//    Motion25Spec* getMotionSpec() { return _pMotionSpec; }
//
//    void erect_self(float x, float y, float& outW, float& outH);
//    //void de_erect_self();
//    Motion25Spec* getTileSpec() { return _pMotionSpec; }
//    void setTileSpec(Motion25Spec* ps) { _pMotionSpec = ps; }
//
//    WorldObjectSpec* getObjSpec() { return _pPixObjSpec; }
//    void setObjSpec(WorldObjectSpec* ps) { _pPixObjSpec = ps; }
//
//
//    void setTxWh(float w) { _fTxWh = w; }
//    float getTxWh() {return _fTxWh ; }
//
//    std::shared_ptr<Texture2DSpec> getUpTx() { return getTx(0); }
//    std::shared_ptr<Texture2DSpec> getDownTx() { return getTx(1); }
//    std::shared_ptr<Texture2DSpec> getTx(size_t i) { 
//        AssertOrThrow2(i < _vecTextures.size());
//        return _vecTextures[i];
//    }
//    std::shared_ptr<Texture2DSpec> setTx(size_t i);
//    const std::vector<std::shared_ptr<Texture2DSpec>>& getTxs() { return _vecTextures; }
//
//    void addTexture(std::shared_ptr<Texture2DSpec> tx) {
//        _vecTextures.push_back(tx);
//    }
//
//    void setMode(EditButtonMode::e em) { _eMode = em; }
//    EditButtonMode::e getMode() { return _eMode ; }
//
//    std::shared_ptr<EditButtonGroup> getGroup() { return _pGroup; }
//   // void updateState(ButtonState bt);
//    ButtonState::e getState() { return _eState; }
//};
//#pragma endregion
////////////////////////////////////////////////////////////////////////////
//class CongaGui : public Gui2d {
//    std::shared_ptr<Motion25Bucket> _pBucket = nullptr;
//
//    std::vector<std::shared_ptr<EditButton>> _vecEditButtons;
//    std::vector<std::shared_ptr<EditButtonGroup>> _vecEditButtonGroups;
//    std::vector<std::shared_ptr<Widget>> _vecGameWidgets;
//
//    std::shared_ptr<EditButtonGroup> _pToolGroup = nullptr;
//    std::shared_ptr<EditButtonGroup> _pModeGroup = nullptr;
//    std::shared_ptr<EditButtonGroup> _pUndoGroup = nullptr;
//    std::shared_ptr<EditButtonGroup> _pBlockModifierGroup = nullptr;
//    std::shared_ptr<EditButtonGroup> _pBaseTileGroup = nullptr;
//    std::shared_ptr<EditButtonGroup> _pObjTileGroup = nullptr;
//    std::shared_ptr<EditButtonGroup> _pRegionGroup = nullptr;
//    std::shared_ptr<EditButtonGroup> _pProcModeGroup = nullptr;
//    std::shared_ptr<EditButtonGroup> _pMatterGroup = nullptr;
//    std::shared_ptr<EditButtonGroup> _pLiquidTileGroup = nullptr;
//    //State
//    GameMode::e _eGameMode = GameMode::e::Play; //Duplicate data - this is set in room.
//    BlockMode::e _eBlockMode = BlockMode::e::Single;
//    EditTool::e _eEditTool = EditTool::e::Pencil;
//    EditMode::e _eEditMode = EditMode::e::Tile;
//    RegionSize::e _eRegionSize = RegionSize::e::Region_1x1;
//    ProcMode::e _eProcMode = ProcMode::e::Block;
//    MatterMode::e _eMatterMode = MatterMode::e::Solid;
//
//    WorldObjectSpec* _pSelectedPixObj = nullptr;
//    W25Tile _pSelectedBaseTile = W25TILE_EMPTY;
//    W25Tile _pSelectedLiquidTile = W25TILE_EMPTY;
//    bool _bUndoPressed = false;
//
//    //Selection
//    NodeId _pSelectedObj = 0;
//    NodeId _pHoveredObj = 0;
//    WorldCell* _pSelectedTile = nullptr; // So we don't have a selected tile.  Select mode is for objjects onlyh.
//    WorldCell* _pHoveredTile = nullptr;
//    vec3 _vHoverPt;
//    vec3 _vHoverNorm;
//   // Box3f* _pHoveredBox = nullptr;
//    bool _bIsHovering = false;
//    std::vector<ivec3> _vecHoveredNodes;
//    std::vector<Box3f*> _vecHoverBoxes;
//    
//
//    //WorldCell* _pHoverVertexCell = nullptr;
//  //  vec3 _vHoverVertexPoint;
//  //  vec3 _vHoverVertexNormal;
//
//    void buildEditButtons();
//    std::shared_ptr<EditButton> buildEditButton(std::shared_ptr<EditButtonGroup> ebg, std::vector<std::shared_ptr<Texture2DSpec>>& txs, 
//        float wpct, Motion25Spec* pTileSpec, WorldObjectSpec* pPixObjSpec);
//    std::shared_ptr<EditButton> buildEditButtonDef(
//        std::shared_ptr<EditButtonGroup> ebg, t_string txUp, t_string txDown, float wpct,
//        std::function<void(ButtonState::e, void*)>&& vup,
//        std::function<void(ButtonState::e, void*)>&& vdn
//    );
//    std::shared_ptr<EditButton> buildEditButtonDef2(
//        std::shared_ptr<EditButtonGroup> ebg, std::vector<std::shared_ptr<Texture2DSpec>>& txs, float wpct,
//        std::function<void(ButtonState::e, void*)>&& vdn,
//        std::function<void(ButtonState::e, void*)>&& vup,
//        Motion25Spec* pTileSpec, WorldObjectSpec* pPixObjSpec
//    );
//    std::shared_ptr<EditButton> buildEditButtonDef3(
//        std::shared_ptr<EditButtonGroup> ebg, std::vector<t_string>& txs, float wpct,
//        std::function<void(ButtonState::e, void*)>&& vdn,
//        std::function<void(ButtonState::e, void*)>&& vup,
//        Motion25Spec* pTileSpec, WorldObjectSpec* pPixObjSpec
//    );
//    //std::shared_ptr<EditButton> buildToggleButtonDef(
//    //    std::shared_ptr<EditButtonGroup> ebg, std::vector<t_string>& txs , float wpct,
//    //    std::function<void(ButtonState, void*)>&& vup
//    //);
//    void buildTiles(std::map<Hash32, WorldObjectSpec*>& specs);
//    void updateUi();
//    //TileButton* createTileButton(Motion25Spec* motion, PixObjSpec* ps, std::shared_ptr<EditButtonGroup> pGroup);
//    void buildGameWidgets();
//    void setSelectedTile(TileButton* b){  /*_pSelected = b;*/ }
//    void drawEditText();
//    
//    void editModeChanged();
//
//    void addGroupLine(std::shared_ptr<EditButtonGroup> ebg, float dy, float& baseX, float& baseY);
//    void addTileGroups(float dy, float& baseX, float& baseY);
//    
//
//    bool _bInputCaptured = false;
//    Box3f* addHoverBox(Box3f* b);
//    Box3f* addHoverBox(Box3f b);
//
//    std::shared_ptr<World25> _pWorld25 = nullptr;
//public:
//    CongaGui(std::shared_ptr<GLContext> pc, std::shared_ptr<Motion25Bucket> pb, std::map<Hash32, WorldObjectSpec*>& specs, std::shared_ptr<World25> pw);
//    virtual ~CongaGui() override;
//
//    virtual void init() override;
//
//    virtual void draw(RenderParams&& rp) override;

//

//};
//
//}//ns Game
//
//
//
//#endif




//UI Grid code
    int nAssets = 30;
    //////////////////////////////////////////////////////////////////////////
    //Create the asset pad grid.
    int buttonHeight = 130;
    int buttonWidth = 110;
    //int nSlots = nAssets;
    //int nSlotsRow = 5;
    //float spacingX = 15;
    //float spacingY = 15;
    //float nRows = (nSlots / nSlotsRow + (nSlots % nSlotsRow > 0 ? 1 : 0)) * 2;
    //float nCols = nSlotsRow * 2; // the *2 is for paddig

    //std::shared_ptr<UiGrid> grid = UiGrid::create(0, 0);
    //grid->width() = uDim((nCols / 2) * spacingX + (nCols / 2) * buttonWidth, UiDimUnit::e::Pixel);
    //grid->height() = uDim((nRows / 2) * spacingY + (nRows / 2) * buttonHeight, UiDimUnit::e::Pixel);

    //std::vector<std::shared_ptr<UiElement>> vecSlots; //saved for easy access
    //for (int i = 0; i < nRows; ++i) {
    //    std::shared_ptr<UiGridRow> rowx = grid->addRow(1);
    //    rowx->width() = "100%";
    //    if (i % 2 == 0) {
    //        //Even = Content
    //        rowx->height() = uDim(buttonHeight, UiDimUnit::e::Pixel);
    //        for (int j = 0; j < nCols; ++j) {
    //            std::shared_ptr<UiElement> colx = rowx->addCol(1);
    //            colx->height() = "100%";
    //            if (j % 2 == 0) {
    //                //Even = Content
    //                colx->width() = uDim(buttonWidth, UiDimUnit::e::Pixel);
    //                vecSlots.push_back(colx);
    //            }
    //            else {
    //                colx->width() = uDim(spacingX, UiDimUnit::e::Pixel);

    //            }
    //        }
    //    }
    //    else {
    //        rowx->height() = uDim(spacingY, UiDimUnit::e::Pixel);
    //    }

    //}
    //winObjects->getContentContainer()->addChild(grid);

    //std::shared_ptr<UiWindowGrid> grid




	    //Draw the selectable objects
    //Really, we should be using basic shaders for this as this uses inline mode.

//#ifdef COMPATIBILITY_PROFILE_ENABLED
//    std::vector<const Box3f*> vecObjectBoxes;
//
//    //we should probaly treat selecting the saem as hovering
//    if (_pWorldEditState->getSelectedObject() != NO_NODE_ID) {
//        std::shared_ptr<WorldObject> ob = std::dynamic_pointer_cast<WorldObject>(_pWorld25->getObj(_pWorldEditState->getSelectedObject()));
//        if (ob == nullptr) {
//            _pWorldEditState->setSelectedObject(NO_NODE_ID);
//        }
//        else {
//            vecObjectBoxes.push_back(ob->getBoundBoxObject());
//        }
//    }
//
//    if (_pWorldEditState->getIsHovering()) {
//        for (Box3f* b : _pWorldEditState->getHoverBoxes()) {
//            vecObjectBoxes.push_back(b);
//        }
//    }
//
//    //**Draw
//    _pContext->chkErrDbg();
//    Gu::beginWin32InlineDebug(getContext());
//    _pContext->chkErrDbg();
//    glEnable(GL_DEPTH_TEST);
//    glBindTexture(GL_TEXTURE_2D, 0);
//    //Draw object helpers.
//    _pContext->setLineWidth(1.0f);
//    glColor4f(1, 1, 1, 1);
//    _pContext->chkErrDbg();
//    glBegin(GL_LINES);
//    {
//        for (const Box3f* bb : vecObjectBoxes) {
//            if (getContext()->getCamera()->getFrustum()->hasBox(bb)) {
//                //    Gu::inlineDrawBoxCont(bb);
//            }
//        }
//    }
//    glEnd();
//    _pContext->chkErrDbg();
//
//    glColor4f(1.0f, .5f, .3f, 1.0f);
//    glPointSize(3);
//    glBegin(GL_POINTS);
//    {
//        vec3 pt = _pWorldEditState->getHoveredPoint();
//        glVertex3fv((GLfloat*)&pt);
//    }
//    glEnd();
//    _pContext->chkErrDbg();
//
//    if (_pWorldEditState->getIsHovering()) {
//        MatterMode::e eMatterMode = _pWorldEditState->getMatterMode();
//        if (_pWorldEditState->getHoveredTile()) {
//            if (eMatterMode == MatterMode::e::Solid) {
//                glColor4f(1.0f, .1f, .1f, 1.0f);
//            }
//            else if (eMatterMode == MatterMode::e::Liquid) {
//                glColor4f(.1f, .1f, 1.0f, 1.0f);
//            }
//            glPointSize(9);
//            glBegin(GL_POINTS);
//            {
//                W25Geom cg = _pWorldEditState->getHoveredTile()->getGeom(eMatterMode);
//                vec3 c = _pWorldEditState->getHoveredTile()->getBoundBoxBvh().center();
//                vec3 p[8];
//                float cw = BottleUtils::getCellWidth() * 0.5f;
//                float ch = BottleUtils::getCellHeight() * 0.5f;
//
//                p[0] = c + vec3(-cw, -ch, -cw);
//                p[1] = c + vec3(cw, -ch, -cw);
//                p[2] = c + vec3(-cw, ch, -cw);
//                p[3] = c + vec3(cw, ch, -cw);
//                p[4] = c + vec3(-cw, -ch, cw);
//                p[5] = c + vec3(cw, -ch, cw);
//                p[6] = c + vec3(-cw, ch, cw);
//                p[7] = c + vec3(cw, ch, cw);
//
//                for (int iv = 0; iv < 8; ++iv) {
//                    if (cg & (1 << iv)) {
//                        glVertex3fv((GLfloat*)&(p[iv]));
//                    }
//                }
//            }
//            glEnd();
//        }
//
//    }
//    _pContext->chkErrDbg();
//
//    glColor4f(0.8f, 0.6f, 1.6f, 1.6f);
//    glPointSize(3);
//    glBegin(GL_LINES);
//    {
//        vec3 pt0 = _pWorldEditState->getHoveredPoint();
//        vec3 pt1 = pt0 + _pWorldEditState->getHoveredNormal();
//        glVertex3fv((GLfloat*)&pt0);
//        glVertex3fv((GLfloat*)&pt1);
//    }
//    glEnd();
//    _pContext->chkErrDbg();
//    vecObjectBoxes.clear();
//
//#endif



